; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	d:\SySal2\SmartTracker8.5\SmartTrackerClass.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?pHelpPath@CSmartTrackerClass@@2PADA		; CSmartTrackerClass::pHelpPath
PUBLIC	?ConfigDataQDI@@3PAUQueryDataInfo@@A		; ConfigDataQDI
_BSS	SEGMENT
?pHelpPath@CSmartTrackerClass@@2PADA DD 01H DUP (?)	; CSmartTrackerClass::pHelpPath
_BSS	ENDS
_DATA	SEGMENT
?ConfigDataQDI@@3PAUQueryDataInfo@@A DB 'MaxGrains', 00H ; ConfigDataQDI
	ORG $+54
	DB	01H
	ORG $+3
	DD	00H
	DB	'10000', 00H
	ORG $+58
	DB	'CellOverflow', 00H
	ORG $+51
	DB	01H
	ORG $+3
	DD	08H
	DB	'32', 00H
	ORG $+61
	DB	'LayerNum', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	04H
	DB	'20', 00H
	ORG $+61
	DB	'CellNumX', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0cH
	DB	'10', 00H
	ORG $+61
	DB	'CellNumY', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	010H
	DB	'10', 00H
	ORG $+61
	DB	'PixMin', 00H
	ORG $+57
	DB	01H
	ORG $+3
	DD	014H
	DB	'2', 00H
	ORG $+62
	DB	'PixMax', 00H
	ORG $+57
	DB	01H
	ORG $+3
	DD	018H
	DB	'64', 00H
	ORG $+61
	DB	'AlignTol', 00H
	ORG $+55
	DB	02H
	ORG $+3
	DD	01cH
	DB	'.7', 00H
	ORG $+61
	DB	'TrialCount', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	020H
	DB	'0', 00H
	ORG $+62
	DB	'NptMinV', 00H
	ORG $+56
	DB	02H
	ORG $+3
	DD	02e4H
	DB	'8.1', 00H
	ORG $+60
	DB	'NptMinH', 00H
	ORG $+56
	DB	02H
	ORG $+3
	DD	02e8H
	DB	'7', 00H
	ORG $+62
	DB	'NptMin01', 00H
	ORG $+55
	DB	02H
	ORG $+3
	DD	02ecH
	DB	'8', 00H
	ORG $+62
	DB	'MinSlope', 00H
	ORG $+55
	DB	02H
	ORG $+3
	DD	02f0H
	DB	'-.0005', 00H
	ORG $+57
	DB	'MaxSlope', 00H
	ORG $+55
	DB	02H
	ORG $+3
	DD	02f4H
	DB	'1', 00H
	ORG $+62
	DB	'Processors', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02f8H
	DB	'2', 00H
	ORG $+62
	DB	'MaxTrackingTime', 00H
	ORG $+48
	DB	01H
	ORG $+3
	DD	02fcH
	DB	'300', 00H
	ORG $+60
	DB	'ReplicaRadius', 00H
	ORG $+50
	DB	02H
	ORG $+3
	DD	0300H
	DB	'2', 00H
	ORG $+62
	DB	'ReplicaSampleDivider', 00H
	ORG $+43
	DB	01H
	ORG $+3
	DD	0304H
	DB	'8', 00H
	ORG $+62
	DB	'MinReplicas', 00H
	ORG $+52
	DB	01H
	ORG $+3
	DD	0308H
	DB	'40', 00H
	ORG $+61
	DB	'MaxReplicaSpread', 00H
	ORG $+47
	DB	02H
	ORG $+3
	DD	030cH
	DB	'1', 00H
	ORG $+62
	DB	'DiscardShadowSigma', 00H
	ORG $+45
	DB	02H
	ORG $+3
	DD	0310H
	DB	'2', 00H
	ORG $+62
	DB	'CheckGrainSpacing', 00H
	ORG $+46
	DB	01H
	ORG $+3
	DD	0314H
	DB	'1', 00H
	ORG $+62
	DB	'InitialMultiplicity', 00H
	ORG $+44
	DB	01H
	ORG $+3
	DD	0318H
	DB	'2', 00H
	ORG $+62
	DB	'TransverseSigmaLimit', 00H
	ORG $+43
	DB	02H
	ORG $+3
	DD	031cH
	DB	'0.2', 00H
	ORG $+60
	DB	'TTop0', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	024H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom0', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	028H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggers0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger00', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	030H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger01', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	034H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger02', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	038H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger03', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	03cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger04', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	040H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger05', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	044H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger06', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	048H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger07', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	04cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTop1', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	050H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom1', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	054H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger1', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	058H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger10', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	05cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger11', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	060H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger12', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	064H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger13', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	068H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger14', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	06cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger15', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	070H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger16', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	074H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger17', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	078H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop2', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	07cH
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom2', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	080H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger2', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	084H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger20', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	088H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger21', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	08cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger22', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	090H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger23', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	094H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger24', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	098H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger25', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	09cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger26', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0a0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger27', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0a4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop3', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0a8H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom3', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0acH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger3', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0b0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger30', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0b4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger31', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0b8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger32', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0bcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger33', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0c0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger34', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0c4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger35', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0c8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger36', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0ccH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger37', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0d0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop4', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0d4H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom4', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0d8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger4', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0dcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger40', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0e0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger41', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0e4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger42', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0e8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger43', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0ecH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger44', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0f0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger45', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0f4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger46', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0f8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger47', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0fcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTop5', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0100H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom5', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0104H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger5', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0108H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger50', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	010cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger51', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0110H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger52', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0114H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger53', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0118H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger54', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	011cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger55', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0120H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger56', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0124H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger57', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0128H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop6', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	012cH
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom6', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0130H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger6', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0134H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger60', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0138H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger61', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	013cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger62', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0140H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger63', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0144H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger64', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0148H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger65', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	014cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger66', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0150H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger67', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0154H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop7', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0158H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom7', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	015cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger7', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0160H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger70', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0164H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger71', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0168H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger72', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	016cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger73', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0170H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger74', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0174H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger75', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0178H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger76', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	017cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger77', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0180H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop8', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0184H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom8', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0188H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger8', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	018cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger80', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0190H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger81', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0194H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger82', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0198H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger83', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	019cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger84', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01a0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger85', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01a4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger86', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01a8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger87', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01acH
	DB	'-1', 00H
	ORG $+61
	DB	'TTop9', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	01b0H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom9', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	01b4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger9', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	01b8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger90', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01bcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger91', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01c0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger92', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01c4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger93', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01c8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger94', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01ccH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger95', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01d0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger96', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01d4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger97', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01d8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopA', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	01dcH
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomA', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	01e0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	01e4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01e8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01ecH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01f0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01f4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01f8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01fcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0200H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0204H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopB', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0208H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomB', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	020cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0210H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0214H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0218H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	021cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0220H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0224H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0228H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	022cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0230H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopC', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0234H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomC', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0238H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	023cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0240H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0244H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0248H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	024cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0250H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0254H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0258H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	025cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTopD', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0260H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomD', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0264H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0268H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	026cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0270H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0274H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0278H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	027cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0280H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0284H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0288H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopE', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	028cH
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomE', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0290H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0294H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0298H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	029cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02a0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02a4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02a8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02acH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02b0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02b4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopF', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	02b8H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomF', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	02bcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	02c0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02c4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02c8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02ccH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02d0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02d4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02d8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02dcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02e0H
	DB	'-1', 00H
	ORG $+61
_DATA	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
; Function compile flags: /Ogtpy
; File d:\sysal2\common\vectors.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 16   : 	Vector() {};

	mov	eax, ecx
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	?SetName@CSmartTrackerClass@@UAGJQAD@Z		; CSmartTrackerClass::SetName
EXTRN	__imp__strncpy:PROC
; Function compile flags: /Ogtpy
; File d:\sysal2\smarttracker8.5\smarttrackerclass.cpp
;	COMDAT ?SetName@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_name$ = 12						; size = 4
?SetName@CSmartTrackerClass@@UAGJQAD@Z PROC		; CSmartTrackerClass::SetName, COMDAT

; 243  : 	// TODO: Add your implementation code here
; 244  : 	strncpy(Name, name, SYSAL_MAX_CONN_NAME_LEN);

	mov	eax, DWORD PTR _name$[esp-4]
	mov	ecx, DWORD PTR _this$[esp-4]
	push	64					; 00000040H
	push	eax
	add	ecx, 36					; 00000024H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 245  : 	return S_OK;

	xor	eax, eax

; 246  : }

	ret	8
?SetName@CSmartTrackerClass@@UAGJQAD@Z ENDP		; CSmartTrackerClass::SetName
_TEXT	ENDS
PUBLIC	?GetName@CSmartTrackerClass@@UAGJQAD@Z		; CSmartTrackerClass::GetName
; Function compile flags: /Ogtpy
;	COMDAT ?GetName@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_name$ = 12						; size = 4
?GetName@CSmartTrackerClass@@UAGJQAD@Z PROC		; CSmartTrackerClass::GetName, COMDAT

; 250  : 	// TODO: Add your implementation code here
; 251  : 	strncpy(name, Name, SYSAL_MAX_CONN_NAME_LEN);

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ecx, DWORD PTR _name$[esp-4]
	push	64					; 00000040H
	add	eax, 36					; 00000024H
	push	eax
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 252  : 	return S_OK;

	xor	eax, eax

; 253  : }

	ret	8
?GetName@CSmartTrackerClass@@UAGJQAD@Z ENDP		; CSmartTrackerClass::GetName
_TEXT	ENDS
PUBLIC	??1CEditConfig@@UAE@XZ				; CEditConfig::~CEditConfig
EXTRN	??1CDialog@@UAE@XZ:PROC				; CDialog::~CDialog
EXTRN	??1CListCtrl@@UAE@XZ:PROC			; CListCtrl::~CListCtrl
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CEditConfig@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CEditConfig@@UAE@XZ$0
__ehfuncinfo$??1CEditConfig@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CEditConfig@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CEditConfig@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CEditConfig@@UAE@XZ PROC				; CEditConfig::~CEditConfig, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CEditConfig@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	lea	ecx, DWORD PTR [esi+1008]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR [esi+916]
	call	??1CListCtrl@@UAE@XZ			; CListCtrl::~CListCtrl
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CDialog@@UAE@XZ			; CDialog::~CDialog
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CEditConfig@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CDialog@@UAE@XZ			; CDialog::~CDialog
__ehhandler$??1CEditConfig@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CEditConfig@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CEditConfig@@UAE@XZ ENDP				; CEditConfig::~CEditConfig
PUBLIC	?EnableMonitor@CSmartTrackerClass@@UAGJE@Z	; CSmartTrackerClass::EnableMonitor
; Function compile flags: /Ogtpy
;	COMDAT ?EnableMonitor@CSmartTrackerClass@@UAGJE@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_bEnable$ = 12						; size = 1
?EnableMonitor@CSmartTrackerClass@@UAGJE@Z PROC		; CSmartTrackerClass::EnableMonitor, COMDAT

; 347  : 	// TODO: Add your implementation code here
; 348  : 
; 349  : 	return (bEnable) ? S_FALSE : S_OK;

	xor	eax, eax
	cmp	BYTE PTR _bEnable$[esp-4], al
	setne	al

; 350  : }

	ret	8
?EnableMonitor@CSmartTrackerClass@@UAGJE@Z ENDP		; CSmartTrackerClass::EnableMonitor
_TEXT	ENDS
PUBLIC	?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z ; CSmartTrackerClass::GetNumberOfConnections
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pNumber$ = 12						; size = 4
?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z PROC ; CSmartTrackerClass::GetNumberOfConnections, COMDAT

; 354  : 	// TODO: Add your implementation code here
; 355  : 
; 356  : 	*pNumber = 0;

	mov	eax, DWORD PTR _pNumber$[esp-4]
	mov	DWORD PTR [eax], 0

; 357  : 	return S_OK;

	xor	eax, eax

; 358  : }

	ret	8
?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z ENDP ; CSmartTrackerClass::GetNumberOfConnections
_TEXT	ENDS
PUBLIC	?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z ; CSmartTrackerClass::SetConnection
; Function compile flags: /Ogtpy
;	COMDAT ?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_n$ = 12						; size = 4
_connection$ = 16					; size = 72
?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z PROC ; CSmartTrackerClass::SetConnection, COMDAT

; 362  : 	// TODO: Add your implementation code here
; 363  : 
; 364  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 365  : }

	ret	80					; 00000050H
?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z ENDP ; CSmartTrackerClass::SetConnection
_TEXT	ENDS
PUBLIC	?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z ; CSmartTrackerClass::GetConnection
; Function compile flags: /Ogtpy
;	COMDAT ?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_n$ = 12						; size = 4
_pConnection$ = 16					; size = 4
?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z PROC ; CSmartTrackerClass::GetConnection, COMDAT

; 369  : 	// TODO: Add your implementation code here
; 370  : 
; 371  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 372  : }

	ret	12					; 0000000cH
?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z ENDP ; CSmartTrackerClass::GetConnection
_TEXT	ENDS
PUBLIC	??_C@_0BC@EKPIEICJ@Smart?5Tracker?58?45?$AA@	; `string'
PUBLIC	?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z	; CSmartTrackerClass::GetClassNameA
;	COMDAT ??_C@_0BC@EKPIEICJ@Smart?5Tracker?58?45?$AA@
CONST	SEGMENT
??_C@_0BC@EKPIEICJ@Smart?5Tracker?58?45?$AA@ DB 'Smart Tracker 8.5', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_name$ = 12						; size = 4
?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z PROC	; CSmartTrackerClass::GetClassNameA, COMDAT

; 396  : 	// TODO: Add your implementation code here
; 397  : 	
; 398  : 	strncpy(name, "Smart Tracker 8.5", SYSAL_MAX_CONN_NAME_LEN);

	mov	eax, DWORD PTR _name$[esp-4]
	push	64					; 00000040H
	push	OFFSET ??_C@_0BC@EKPIEICJ@Smart?5Tracker?58?45?$AA@
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 399  : 	return S_OK;

	xor	eax, eax

; 400  : }

	ret	8
?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z ENDP	; CSmartTrackerClass::GetClassNameA
_TEXT	ENDS
PUBLIC	?SyncExec@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::SyncExec
; Function compile flags: /Ogtpy
;	COMDAT ?SyncExec@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?SyncExec@CSmartTrackerClass@@UAGJXZ PROC		; CSmartTrackerClass::SyncExec, COMDAT

; 404  : 	// TODO: Add your implementation code here
; 405  : 
; 406  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 407  : }

	ret	4
?SyncExec@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::SyncExec
_TEXT	ENDS
PUBLIC	?AsyncExec@CSmartTrackerClass@@UAGJJ@Z		; CSmartTrackerClass::AsyncExec
EXTRN	__imp__SetEvent@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AsyncExec@CSmartTrackerClass@@UAGJJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_HNotifyStatusChangeEvent$ = 12				; size = 4
?AsyncExec@CSmartTrackerClass@@UAGJJ@Z PROC		; CSmartTrackerClass::AsyncExec, COMDAT

; 411  : 	// TODO: Add your implementation code here
; 412  : 
; 413  : 	HStatusChangeEvent = (HANDLE)HNotifyStatusChangeEvent;

	mov	eax, DWORD PTR _HNotifyStatusChangeEvent$[esp-4]

; 414  : 	if (HStatusChangeEvent) SetEvent(HStatusChangeEvent);

	test	eax, eax
	mov	ecx, DWORD PTR _this$[esp-4]
	mov	DWORD PTR [ecx+100], eax
	je	SHORT $LN4@AsyncExec
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN4@AsyncExec:

; 415  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 416  : }

	ret	8
?AsyncExec@CSmartTrackerClass@@UAGJJ@Z ENDP		; CSmartTrackerClass::AsyncExec
_TEXT	ENDS
PUBLIC	?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z	; CSmartTrackerClass::AsyncCheckStatus
; Function compile flags: /Ogtpy
;	COMDAT ?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pStatus$ = 12						; size = 4
?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z PROC	; CSmartTrackerClass::AsyncCheckStatus, COMDAT

; 420  : 	// TODO: Add your implementation code here
; 421  : 	
; 422  : 	*pStatus = SYSAL_ASYNC_STATUS_IDLE;

	mov	eax, DWORD PTR _pStatus$[esp-4]
	mov	DWORD PTR [eax], 0

; 423  : 	return S_OK;

	xor	eax, eax

; 424  : }

	ret	8
?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z ENDP	; CSmartTrackerClass::AsyncCheckStatus
_TEXT	ENDS
PUBLIC	?AsyncWait@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::AsyncWait
; Function compile flags: /Ogtpy
;	COMDAT ?AsyncWait@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AsyncWait@CSmartTrackerClass@@UAGJXZ PROC		; CSmartTrackerClass::AsyncWait, COMDAT

; 428  : 	// TODO: Add your implementation code here
; 429  : 
; 430  : 	return S_OK;

	xor	eax, eax

; 431  : }

	ret	4
?AsyncWait@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::AsyncWait
_TEXT	ENDS
PUBLIC	?AsyncPause@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::AsyncPause
; Function compile flags: /Ogtpy
;	COMDAT ?AsyncPause@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AsyncPause@CSmartTrackerClass@@UAGJXZ PROC		; CSmartTrackerClass::AsyncPause, COMDAT

; 435  : 	// TODO: Add your implementation code here
; 436  : 
; 437  : 	if (HStatusChangeEvent) SetEvent(HStatusChangeEvent);

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+100]
	test	eax, eax
	je	SHORT $LN4@AsyncPause
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN4@AsyncPause:

; 438  : 	return S_OK;

	xor	eax, eax

; 439  : }

	ret	4
?AsyncPause@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::AsyncPause
_TEXT	ENDS
PUBLIC	?AsyncStop@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::AsyncStop
; Function compile flags: /Ogtpy
;	COMDAT ?AsyncStop@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AsyncStop@CSmartTrackerClass@@UAGJXZ PROC		; CSmartTrackerClass::AsyncStop, COMDAT

; 442  : {

	push	esi

; 443  : 	// TODO: Add your implementation code here
; 444  : 
; 445  : 	if (HStatusChangeEvent) 

	mov	esi, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [esi+100]
	test	eax, eax
	je	SHORT $LN4@AsyncStop

; 446  : 	{
; 447  : 		SetEvent(HStatusChangeEvent);

	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 448  : 		HStatusChangeEvent = 0;

	mov	DWORD PTR [esi+100], 0
$LN4@AsyncStop:

; 449  : 		};
; 450  : 	return S_OK;

	xor	eax, eax
	pop	esi

; 451  : }

	ret	4
?AsyncStop@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::AsyncStop
_TEXT	ENDS
PUBLIC	?AsyncResume@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::AsyncResume
; Function compile flags: /Ogtpy
;	COMDAT ?AsyncResume@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AsyncResume@CSmartTrackerClass@@UAGJXZ PROC		; CSmartTrackerClass::AsyncResume, COMDAT

; 455  : 	// TODO: Add your implementation code here
; 456  : 
; 457  : 	if (HStatusChangeEvent) SetEvent(HStatusChangeEvent);

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+100]
	test	eax, eax
	je	SHORT $LN4@AsyncResum
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN4@AsyncResum:

; 458  : 	return S_OK;

	xor	eax, eax

; 459  : }

	ret	4
?AsyncResume@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::AsyncResume
_TEXT	ENDS
PUBLIC	?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z		; CSmartTrackerClass::IsReady
; Function compile flags: /Ogtpy
;	COMDAT ?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pWrongConn$ = 12					; size = 4
_pRetCode$ = 16						; size = 4
?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z PROC		; CSmartTrackerClass::IsReady, COMDAT

; 463  : 	// TODO: Add your implementation code here
; 464  : 
; 465  : 	*pWrongConn = -1;

	mov	eax, DWORD PTR _pWrongConn$[esp-4]

; 466  : 	*pRetCode = SYSAL_READYSTATUS_READY;

	mov	ecx, DWORD PTR _pRetCode$[esp-4]
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [ecx], 0

; 467  : 	return S_OK;

	xor	eax, eax

; 468  : }

	ret	12					; 0000000cH
?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z ENDP		; CSmartTrackerClass::IsReady
_TEXT	ENDS
PUBLIC	?SetConfigManagerInterface@CSmartTrackerClass@@UAGJPAUConfigManagerInterface@@@Z ; CSmartTrackerClass::SetConfigManagerInterface
; Function compile flags: /Ogtpy
;	COMDAT ?SetConfigManagerInterface@CSmartTrackerClass@@UAGJPAUConfigManagerInterface@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pCMI$ = 12						; size = 4
?SetConfigManagerInterface@CSmartTrackerClass@@UAGJPAUConfigManagerInterface@@@Z PROC ; CSmartTrackerClass::SetConfigManagerInterface, COMDAT

; 473  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 474  : }

	ret	8
?SetConfigManagerInterface@CSmartTrackerClass@@UAGJPAUConfigManagerInterface@@@Z ENDP ; CSmartTrackerClass::SetConfigManagerInterface
_TEXT	ENDS
PUBLIC	?GetCLSID@CSmartTrackerClass@@UAGJPAU_GUID@@@Z	; CSmartTrackerClass::GetCLSID
EXTRN	_CLSID_SmartTracker8:BYTE
; Function compile flags: /Ogtpy
;	COMDAT ?GetCLSID@CSmartTrackerClass@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pCLSID$ = 12						; size = 4
?GetCLSID@CSmartTrackerClass@@UAGJPAU_GUID@@@Z PROC	; CSmartTrackerClass::GetCLSID, COMDAT

; 478  : 	*pCLSID = CLSID_SmartTracker8;

	mov	ecx, DWORD PTR _CLSID_SmartTracker8
	mov	eax, DWORD PTR _pCLSID$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _CLSID_SmartTracker8+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _CLSID_SmartTracker8+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _CLSID_SmartTracker8+12
	mov	DWORD PTR [eax+12], edx

; 479  : 	return S_OK;	

	xor	eax, eax

; 480  : }

	ret	8
?GetCLSID@CSmartTrackerClass@@UAGJPAU_GUID@@@Z ENDP	; CSmartTrackerClass::GetCLSID
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?StartFilling@CSmartTrackerClass@@UAGJXZ	; CSmartTrackerClass::StartFilling
EXTRN	__fltused:DWORD
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?StartFilling@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?StartFilling@CSmartTrackerClass@@UAGJXZ PROC		; CSmartTrackerClass::StartFilling, COMDAT

; 484  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 485  : 
; 486  : 	// TODO: Add your implementation code here
; 487  : 	if (!OkToRun) return S_FALSE;

	mov	eax, DWORD PTR _this$[esp-4]
	xor	ecx, ecx
	cmp	BYTE PTR [eax+1112], cl
	jne	SHORT $LN1@StartFilli
	mov	eax, 1

; 496  : }

	ret	4
$LN1@StartFilli:

; 488  : 	T.Layer = 0;
; 489  : 	T.NumGrains = 0;
; 490  : 	T.DispX = T.DispY = 0.0f;

	fldz
	mov	DWORD PTR [eax+1016], ecx
	fst	DWORD PTR [eax+1024]
	mov	DWORD PTR [eax+1012], ecx
	fst	DWORD PTR [eax+1020]

; 491  : 	T.ShadowSigmaMeasures = 0;

	mov	DWORD PTR [eax+1044], ecx

; 492  : 	T.ShadowSigmaXAccumulator = T.ShadowSigmaYAccumulator = 0.0f;

	fst	DWORD PTR [eax+1032]

; 493  : 	T.Side = 1;

	mov	DWORD PTR [eax+1100], 1
	fst	DWORD PTR [eax+1028]

; 494  : 	T.TotalLX = T.TotalLY = 0.0f;

	fst	DWORD PTR [eax+1108]
	fstp	DWORD PTR [eax+1104]

; 495  : 	return S_OK;

	xor	eax, eax

; 496  : }

	ret	4
?StartFilling@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::StartFilling
_TEXT	ENDS
PUBLIC	?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z ; CSmartTrackerClass::GetCameraSpec
; Function compile flags: /Ogtpy
;	COMDAT ?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pSpec$ = 12						; size = 4
?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z PROC ; CSmartTrackerClass::GetCameraSpec, COMDAT

; 542  : {

	push	esi

; 543  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 544  : 
; 545  : 	// TODO: Add your implementation code here
; 546  : 	*pSpec = CamSpec;

	mov	esi, DWORD PTR _this$[esp]
	push	edi
	mov	edi, DWORD PTR _pSpec$[esp+4]
	add	esi, 108				; 0000006cH
	mov	ecx, 8
	rep movsd
	pop	edi

; 547  : 	return S_OK;

	xor	eax, eax
	pop	esi

; 548  : }

	ret	8
?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z ENDP ; CSmartTrackerClass::GetCameraSpec
_TEXT	ENDS
PUBLIC	?CorrectChains@CSmartTrackerClass@@IAEXXZ	; CSmartTrackerClass::CorrectChains
; Function compile flags: /Ogtpy
;	COMDAT ?CorrectChains@CSmartTrackerClass@@IAEXXZ
_TEXT	SEGMENT
_DX$ = -24						; size = 4
_DY$ = -20						; size = 4
_pCellEnd$ = -16					; size = 4
_pCellBase$ = -12					; size = 4
tv307 = -8						; size = 4
_n$ = -8						; size = 4
tv237 = -4						; size = 4
?CorrectChains@CSmartTrackerClass@@IAEXXZ PROC		; CSmartTrackerClass::CorrectChains, COMDAT
; _this$ = ecx

; 902  : {

	sub	esp, 24					; 00000018H

; 903  : 	int CellsInLayer = T.CellsInLayer;

	mov	eax, DWORD PTR [ecx+976]
	push	ebp

; 904  : 	Cell *CellSpace = T.CellSpace;
; 905  : 	Cell *pCell, *pCellBase, *pCellEnd;
; 906  : 	IntGrain *pG, *pGE, *pC, *pNC;	
; 907  : 	int lay, n;	
; 908  : 	float DX, DY;
; 909  : 	for ((lay = T.Layer - 1), (pCellBase = CellSpace + lay * CellsInLayer), (pCellEnd = pCellBase + CellsInLayer); lay >= 0; (lay--), (pCellEnd = pCellBase), (pCellBase -= CellsInLayer))	

	mov	ebp, DWORD PTR [ecx+1016]
	mov	ecx, DWORD PTR [ecx+972]
	sub	ebp, 1
	mov	edx, ebp
	imul	edx, eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	lea	edx, DWORD PTR [ecx+edx*8]
	push	esi
	xor	esi, esi
	cmp	ebp, esi
	lea	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR _pCellBase$[esp+32], edx
	mov	DWORD PTR tv237[esp+32], eax
	mov	DWORD PTR _pCellEnd$[esp+32], ecx
	jl	$LN13@CorrectCha
	push	ebx
	push	edi
$LL28@CorrectCha:

; 910  : 		for (pCell = pCellBase; pCell < pCellEnd; pCell++)

	cmp	edx, DWORD PTR _pCellEnd$[esp+40]
	mov	ebx, edx
	jae	$LN14@CorrectCha
	npad	1
$LL12@CorrectCha:

; 911  : 			if (pCell->Free)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, esi
	je	$LN11@CorrectCha

; 912  : 				for ((pG = pCell->FirstG), (pGE = pG + pCell->Free); pG < pGE; pG++)

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [eax+eax*8]
	lea	edi, DWORD PTR [ecx+eax*4]
	cmp	ecx, edi
	jae	$LN11@CorrectCha
	npad	5
$LL8@CorrectCha:

; 913  : 				{
; 914  : 					if (pG->pChainHead)

	mov	eax, DWORD PTR [ecx+32]
	cmp	eax, esi
	je	$LN7@CorrectCha

; 915  : 					{
; 916  : 						DX = pG->Xcm - pG->Xunc;

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _DX$[esp+40]

; 917  : 						DY = pG->Ycm - pG->Yunc;

	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _DY$[esp+40]
	npad	2
$LL4@CorrectCha:

; 918  : 						pC = pG->pChainHead;
; 919  : 						while (pC)
; 920  : 						{
; 921  : 							DX += (pC->Xcm - pC->Xunc);

	fld	DWORD PTR [eax]
	fsub	DWORD PTR [eax+20]
	fadd	DWORD PTR _DX$[esp+40]
	fstp	DWORD PTR _DX$[esp+40]

; 922  : 							DY += (pC->Ycm - pC->Yunc);

	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [eax+24]

; 923  : 							pC = pC->pChainHead;

	mov	eax, DWORD PTR [eax+32]
	cmp	eax, esi
	fadd	DWORD PTR _DY$[esp+40]
	fstp	DWORD PTR _DY$[esp+40]
	jne	SHORT $LL4@CorrectCha

; 924  : 							}
; 925  : 						n = pG->ChainLinkNumber + 1;

	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	DWORD PTR _n$[esp+40], edx

; 926  : 						DX /= n;

	fild	DWORD PTR _n$[esp+40]

; 927  : 						DY /= n;
; 928  : 						pC = pG;

	mov	eax, ecx
	fstp	DWORD PTR tv307[esp+40]
	fld	DWORD PTR _DX$[esp+40]
	fld	DWORD PTR tv307[esp+40]
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _DX$[esp+40]
	fdivr	DWORD PTR _DY$[esp+40]
	fstp	DWORD PTR _DY$[esp+40]
	fld	DWORD PTR _DX$[esp+40]
	fld	DWORD PTR _DY$[esp+40]
$LN2@CorrectCha:

; 929  : 						while (pC)
; 930  : 						{
; 931  : 							pC->Xcm -= DX;

	fld	DWORD PTR [eax]

; 932  : 							pC->Ycm -= DY;
; 933  : 							pNC = pC->pChainHead;

	mov	edx, DWORD PTR [eax+32]
	cmp	edx, esi
	fsub	ST(0), ST(2)

; 934  : 							pC->pChainHead = 0;

	mov	DWORD PTR [eax+32], esi

; 935  : 							pC->ChainLinkNumber = 0;

	mov	DWORD PTR [eax+28], esi
	fstp	DWORD PTR [eax]
	fld	DWORD PTR [eax+4]
	fsub	ST(0), ST(1)
	fstp	DWORD PTR [eax+4]

; 936  : 							pC = pNC;

	mov	eax, edx
	jne	SHORT $LN2@CorrectCha
	fstp	ST(1)
	fstp	ST(0)
$LN7@CorrectCha:
	add	ecx, 36					; 00000024H
	cmp	ecx, edi
	jb	$LL8@CorrectCha

; 912  : 				for ((pG = pCell->FirstG), (pGE = pG + pCell->Free); pG < pGE; pG++)

	mov	edx, DWORD PTR _pCellBase$[esp+40]
$LN11@CorrectCha:

; 910  : 		for (pCell = pCellBase; pCell < pCellEnd; pCell++)

	add	ebx, 8
	cmp	ebx, DWORD PTR _pCellEnd$[esp+40]
	jb	$LL12@CorrectCha
	mov	eax, DWORD PTR tv237[esp+40]
$LN14@CorrectCha:

; 904  : 	Cell *CellSpace = T.CellSpace;
; 905  : 	Cell *pCell, *pCellBase, *pCellEnd;
; 906  : 	IntGrain *pG, *pGE, *pC, *pNC;	
; 907  : 	int lay, n;	
; 908  : 	float DX, DY;
; 909  : 	for ((lay = T.Layer - 1), (pCellBase = CellSpace + lay * CellsInLayer), (pCellEnd = pCellBase + CellsInLayer); lay >= 0; (lay--), (pCellEnd = pCellBase), (pCellBase -= CellsInLayer))	

	sub	ebp, 1
	mov	DWORD PTR _pCellEnd$[esp+40], edx
	sub	edx, eax
	cmp	ebp, esi
	mov	DWORD PTR _pCellBase$[esp+40], edx
	jge	$LL28@CorrectCha
	pop	edi
	pop	ebx
$LN13@CorrectCha:
	pop	esi
	pop	ebp

; 937  : 							}
; 938  : 						}
; 939  : 					}
; 940  : }

	add	esp, 24					; 00000018H
	ret	0
?CorrectChains@CSmartTrackerClass@@IAEXXZ ENDP		; CSmartTrackerClass::CorrectChains
_TEXT	ENDS
PUBLIC	__TI1H
PUBLIC	__real@0000000000000000
PUBLIC	?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z ; CSmartTrackerClass::GetClusters
PUBLIC	__CTA1H
PUBLIC	__CT??_R0H@84
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0H@8
_DATA	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
_DATA	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z$0
__unwindtable$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z$2
__ehfuncinfo$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z
_TEXT	SEGMENT
_TCell$131161 = -32					; size = 8
_pCells$ = -24						; size = 4
$T132878 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
_i$ = 12						; size = 4
_Layer$ = 12						; size = 4
_pSpace$ = 16						; size = 4
_pMaxNumber$ = 20					; size = 4
_ccount$ = 24						; size = 4
_pZ$ = 24						; size = 4
?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z PROC ; CSmartTrackerClass::GetClusters, COMDAT

; 1125 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1126 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1127 : 
; 1128 : 	// TODO: Add your implementation code here	
; 1129 : 	if (!OkToRun) return S_FALSE;	

	mov	esi, DWORD PTR _this$[ebp]
	cmp	BYTE PTR [esi+1112], 0
	jne	SHORT $LN11@GetCluster
	mov	eax, 1

; 1155 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN11@GetCluster:

; 1130 : 	if (Layer < 0 || Layer >= T.LayerNum) return E_INVALIDARG;

	mov	eax, DWORD PTR _Layer$[ebp]
	xor	ecx, ecx
	cmp	eax, ecx
	jl	$LN9@GetCluster
	cmp	eax, DWORD PTR [esi+144]
	jge	$LN9@GetCluster

; 1131 : 	int MaxNumber = *pMaxNumber;

	mov	edx, DWORD PTR _pMaxNumber$[ebp]
	mov	ebx, DWORD PTR [edx]

; 1132 : 	*pZ = T.ZLayer[Layer];

	mov	edx, DWORD PTR [esi+964]
	fld	DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _pZ$[ebp]
	fstp	DWORD PTR [eax]

; 1133 : 	int i, j, ccount = 0;
; 1134 : 	Cell *pCells = T.CellSpace;

	mov	edx, DWORD PTR [esi+972]

; 1135 : 	try
; 1136 : 	{
; 1137 : 		for (i = 0; i < T.CellsInLayer; i++)

	fldz
	mov	eax, DWORD PTR _pSpace$[ebp]
	fldz
	xor	edi, edi
	mov	DWORD PTR _ccount$[ebp], edi
	mov	DWORD PTR _pCells$[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], ecx
	mov	DWORD PTR _i$[ebp], ecx
$LN7@GetCluster:
	cmp	ecx, DWORD PTR [esi+976]
	jge	$LN25@GetCluster

; 1138 : 		{
; 1139 : 			Cell TCell = pCells[i];

	mov	esi, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	DWORD PTR _TCell$131161[ebp+4], ecx

; 1140 : 			for (j = 0; j < TCell.Free; j++)

	xor	edx, edx
$LN4@GetCluster:
	cmp	edx, DWORD PTR _TCell$131161[ebp+4]
	jge	SHORT $LN6@GetCluster

; 1141 : 			{
; 1142 : 				pSpace->X = TCell.FirstG[j].Xcm;

	lea	ecx, DWORD PTR [edx+edx*8]
	fld	DWORD PTR [esi+ecx*4]
	lea	ecx, DWORD PTR [esi+ecx*4]
	fstp	DWORD PTR [eax]

; 1143 : 				pSpace->Y = TCell.FirstG[j].Ycm;
; 1144 : 				pSpace->Area = 0;
; 1145 : 				pSpace->GrayLevel = 0;
; 1146 : 				pSpace->Inertia.IXX = pSpace->Inertia.IYY = pSpace->Inertia.IXY = 0;
; 1147 : 				pSpace++;

	add	eax, 40					; 00000028H

; 1148 : 				if (ccount >= MaxNumber) throw ccount;

	cmp	edi, ebx
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax-36]
	mov	DWORD PTR [eax-32], 0
	fxch	ST(1)
	fst	DWORD PTR [eax-4]
	fxch	ST(1)
	fst	QWORD PTR [eax-20]
	fst	QWORD PTR [eax-12]
	fst	QWORD PTR [eax-28]
	jl	SHORT $LN3@GetCluster
	push	OFFSET __TI1H
	fstp	ST(0)
	lea	edx, DWORD PTR $T132878[ebp]
	fstp	ST(0)
	push	edx
	mov	DWORD PTR $T132878[ebp], edi
	call	__CxxThrowException@8
__catch$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z$0:

; 1149 : 				};
; 1150 : 			}
; 1151 : 		}
; 1152 : 	catch (...) {};

	mov	eax, $LN17@GetCluster
	ret	0
$LN17@GetCluster:

; 1153 : 	*pMaxNumber = ccount;

	mov	eax, DWORD PTR _pMaxNumber$[ebp]
	mov	edi, DWORD PTR _ccount$[ebp]
	mov	DWORD PTR [eax], edi

; 1154 : 	return S_OK;

	xor	eax, eax

; 1155 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN3@GetCluster:

; 1140 : 			for (j = 0; j < TCell.Free; j++)

	add	edx, 1
	jmp	SHORT $LN4@GetCluster
$LN6@GetCluster:

; 1135 : 	try
; 1136 : 	{
; 1137 : 		for (i = 0; i < T.CellsInLayer; i++)

	add	DWORD PTR _i$[ebp], 1
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pCells$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	jmp	$LN7@GetCluster
$LN25@GetCluster:

; 1153 : 	*pMaxNumber = ccount;

	mov	eax, DWORD PTR _pMaxNumber$[ebp]
	fstp	ST(0)
	mov	DWORD PTR [eax], edi
	fstp	ST(0)

; 1154 : 	return S_OK;

	xor	eax, eax

; 1155 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN9@GetCluster:

; 1130 : 	if (Layer < 0 || Layer >= T.LayerNum) return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 1155 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN34@GetCluster:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z ENDP ; CSmartTrackerClass::GetClusters
PUBLIC	?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z	; CSmartTrackerClass::PresetSlope
; Function compile flags: /Ogtpy
;	COMDAT ?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_SX$ = 12						; size = 4
_SY$ = 16						; size = 4
_AccX$ = 20						; size = 4
_AccY$ = 24						; size = 4
?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z PROC	; CSmartTrackerClass::PresetSlope, COMDAT

; 1159 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1160 : 
; 1161 : 	// TODO: Add your implementation code here
; 1162 : 	T.PresetSlopeX = SX;

	mov	eax, DWORD PTR _this$[esp-4]
	fld	DWORD PTR _SX$[esp-4]
	fstp	DWORD PTR [eax+944]

; 1163 : 	T.PresetSlopeY = SY;

	fld	DWORD PTR _SY$[esp-4]
	fstp	DWORD PTR [eax+948]

; 1164 : 	T.PresetSlopeAccX = AccX;

	fld	DWORD PTR _AccX$[esp-4]
	fstp	DWORD PTR [eax+952]

; 1165 : 	T.PresetSlopeAccY = AccY;

	fld	DWORD PTR _AccY$[esp-4]
	fstp	DWORD PTR [eax+956]

; 1166 : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 1167 : }

	ret	20					; 00000014H
?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z ENDP	; CSmartTrackerClass::PresetSlope
_TEXT	ENDS
PUBLIC	?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z ; CSmartTrackerClass::EnableSlopePresetting
; Function compile flags: /Ogtpy
;	COMDAT ?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_SlPresEnable$ = 12					; size = 1
?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z PROC	; CSmartTrackerClass::EnableSlopePresetting, COMDAT

; 1171 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1172 : 
; 1173 : 	// TODO: Add your implementation code here
; 1174 : 	T.PresetSlope = SlPresEnable;

	cmp	BYTE PTR _SlPresEnable$[esp-4], 0
	mov	ecx, DWORD PTR _this$[esp-4]
	setne	al
	mov	BYTE PTR [ecx+940], al

; 1175 : 	return S_OK;

	xor	eax, eax

; 1176 : }

	ret	8
?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z ENDP	; CSmartTrackerClass::EnableSlopePresetting
_TEXT	ENDS
PUBLIC	?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z ; CSmartTrackerClass::GetSlopePresetStatus
; Function compile flags: /Ogtpy
;	COMDAT ?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pSlPresEnable$ = 12					; size = 4
?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z PROC ; CSmartTrackerClass::GetSlopePresetStatus, COMDAT

; 1180 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1181 : 
; 1182 : 	// TODO: Add your implementation code here
; 1183 : 	*pSlPresEnable = T.PresetSlope;

	mov	eax, DWORD PTR _this$[esp-4]
	mov	cl, BYTE PTR [eax+940]
	mov	edx, DWORD PTR _pSlPresEnable$[esp-4]
	mov	BYTE PTR [edx], cl

; 1184 : 	return S_OK;

	xor	eax, eax

; 1185 : }

	ret	8
?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z ENDP ; CSmartTrackerClass::GetSlopePresetStatus
_TEXT	ENDS
PUBLIC	?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z ; CSmartTrackerClass::GetFlatTracks
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pSpace$ = 12						; size = 4
_pMaxNumber$ = 16					; size = 4
_MaxStripsInTrack$ = 20					; size = 4
_StartLayer$ = 24					; size = 4
_EndLayer$ = 28						; size = 4
?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z PROC ; CSmartTrackerClass::GetFlatTracks, COMDAT

; 1189 : 	*pMaxNumber = 0;

	mov	eax, DWORD PTR _pMaxNumber$[esp-4]
	mov	DWORD PTR [eax], 0

; 1190 : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 1191 : 	};

	ret	24					; 00000018H
?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z ENDP ; CSmartTrackerClass::GetFlatTracks
_TEXT	ENDS
PUBLIC	?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z ; CSmartTrackerClass::GetFlatStrips
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_Layer$ = 12						; size = 4
_pSpace$ = 16						; size = 4
_pMaxNumber$ = 20					; size = 4
_pZ$ = 24						; size = 4
?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z PROC ; CSmartTrackerClass::GetFlatStrips, COMDAT

; 1195 : 	*pMaxNumber = 0;

	mov	eax, DWORD PTR _pMaxNumber$[esp-4]
	mov	DWORD PTR [eax], 0

; 1196 : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 1197 : 	};

	ret	20					; 00000014H
?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z ENDP ; CSmartTrackerClass::GetFlatStrips
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z ; CSmartTrackerClass::GetDirAndTol
EXTRN	__imp__hypot:PROC
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z
_TEXT	SEGMENT
_slope2$ = -4						; size = 4
_SlopeX$ = 8						; size = 4
_SlopeY$ = 12						; size = 4
_avgdz$ = 16						; size = 4
_pDirX$ = 20						; size = 4
_pDirY$ = 24						; size = 4
_pdirtol$ = 28						; size = 4
?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z PROC	; CSmartTrackerClass::GetDirAndTol, COMDAT
; _this$ = ecx

; 1204 : {

	push	ecx

; 1205 : 	float slope2 = (float)hypot(SlopeX, SlopeY);

	fld	DWORD PTR _SlopeY$[esp]
	push	esi
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	mov	esi, ecx
	fld	DWORD PTR _SlopeX$[esp+20]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__hypot

; 1207 : 	{
; 1208 : 		*pDirX = 1.0f;
; 1209 : 		*pDirY = 0.0f;

	mov	ecx, DWORD PTR _pDirY$[esp+20]
	fstp	DWORD PTR _slope2$[esp+24]
	fldz

; 1210 : 		*pdirtol = T.AlignTol;					

	mov	edx, DWORD PTR _pdirtol$[esp+20]
	fld	DWORD PTR _slope2$[esp+24]
	add	esp, 16					; 00000010H
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	mov	eax, DWORD PTR _pDirX$[esp+4]
	jp	SHORT $LN6@GetDirAndT
	fstp	ST(0)
	fld1
	fstp	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR [esi+168]
	pop	esi

; 1216 : 		*pdirtol = T.AlignTol + avgdz * slope2;

	fstp	DWORD PTR [edx]

; 1217 : 	}
; 1218 : };

	pop	ecx
	ret	24					; 00000018H
$LN6@GetDirAndT:

; 1206 : 	if (slope2 <= 0.0f)

	fstp	ST(1)

; 1211 : 	}
; 1212 : 	else
; 1213 : 	{
; 1214 : 		*pDirX = SlopeX / slope2;

	fld	DWORD PTR _SlopeX$[esp+4]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR [eax]

; 1215 : 		*pDirY = SlopeY / slope2;

	fld	DWORD PTR _SlopeY$[esp+4]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR [ecx]

; 1216 : 		*pdirtol = T.AlignTol + avgdz * slope2;

	fmul	DWORD PTR _avgdz$[esp+4]
	fadd	DWORD PTR [esi+168]
	pop	esi
	fstp	DWORD PTR [edx]

; 1217 : 	}
; 1218 : };

	pop	ecx
	ret	24					; 00000018H
?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z ENDP	; CSmartTrackerClass::GetDirAndTol
_TEXT	ENDS
PUBLIC	?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z ; CSmartTrackerClass::GetMaxGrainsPerTrack
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pMaxGrains$ = 12					; size = 4
?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z PROC ; CSmartTrackerClass::GetMaxGrainsPerTrack, COMDAT

; 1936 : 	*pMaxGrains = T.LayerNum * T.InitialMultiplicity;

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ecx, DWORD PTR [eax+932]
	imul	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _pMaxGrains$[esp-4]
	mov	DWORD PTR [edx], ecx

; 1937 : 	return S_OK;

	xor	eax, eax

; 1938 : 	}

	ret	8
?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z ENDP ; CSmartTrackerClass::GetMaxGrainsPerTrack
_TEXT	ENDS
PUBLIC	?StartFilling2@CSmartTrackerClass@@UAGJH@Z	; CSmartTrackerClass::StartFilling2
; Function compile flags: /Ogtpy
;	COMDAT ?StartFilling2@CSmartTrackerClass@@UAGJH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_Side$ = 12						; size = 4
?StartFilling2@CSmartTrackerClass@@UAGJH@Z PROC		; CSmartTrackerClass::StartFilling2, COMDAT

; 1941 : {	

	push	esi

; 1942 : 	//if (Side < 0 || Side > 1) return E_INVALIDARG;
; 1943 : 	HRESULT HRes = StartFilling();

	mov	esi, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+12]
	push	esi
	call	ecx

; 1944 : 	T.Side = Side;

	mov	edx, DWORD PTR _Side$[esp]
	mov	DWORD PTR [esi+1100], edx
	pop	esi

; 1945 : 	return HRes;
; 1946 : 	}

	ret	8
?StartFilling2@CSmartTrackerClass@@UAGJH@Z ENDP		; CSmartTrackerClass::StartFilling2
_TEXT	ENDS
PUBLIC	?GetCell@CSmartTrackerClass@@IAEHMM@Z		; CSmartTrackerClass::GetCell
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetCell@CSmartTrackerClass@@IAEHMM@Z
_TEXT	SEGMENT
_Xp$ = 8						; size = 4
_Yp$ = 12						; size = 4
?GetCell@CSmartTrackerClass@@IAEHMM@Z PROC		; CSmartTrackerClass::GetCell, COMDAT
; _this$ = ecx

; 1969 : 	int Icl;
; 1970 : 	if ((Xp < T.Win.Xmin) || (Xp >= T.Win.Xmax) ||
; 1971 : 		(Yp < T.Win.Ymin) || (Yp >= T.Win.Ymax)) return -1;

	fld	DWORD PTR _Xp$[esp-4]
	push	esi
	mov	esi, ecx
	fld	DWORD PTR [esi+980]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN8@GetCell
	fld	DWORD PTR [esi+984]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN8@GetCell
	fld	DWORD PTR _Yp$[esp]
	fld	DWORD PTR [esi+988]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN17@GetCell
	fld	DWORD PTR [esi+992]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN17@GetCell

; 1972 : 	Icl = ((int)((Yp - T.Win.Ymin) / T.DyCell)) * T.CellNumX +
; 1973 : 		(int)((Xp - T.Win.Xmin) / T.DxCell);

	fsub	DWORD PTR [esi+988]
	push	edi
	fdiv	DWORD PTR [esi+1000]
	call	__ftol2_sse
	fsub	DWORD PTR [esi+980]
	mov	edi, eax
	imul	edi, DWORD PTR [esi+152]
	fdiv	DWORD PTR [esi+996]
	call	__ftol2_sse
	add	edi, eax

; 1974 : 	if ((Icl >= 0) && (Icl < T.CellsInLayer)) return Icl;

	js	SHORT $LN1@GetCell
	cmp	edi, DWORD PTR [esi+976]
	jge	SHORT $LN1@GetCell
	mov	eax, edi
	pop	edi
	pop	esi

; 1976 : 	};

	ret	8
$LN1@GetCell:
	pop	edi

; 1975 : 	return -1;

	or	eax, -1
	pop	esi

; 1976 : 	};

	ret	8
$LN17@GetCell:

; 1969 : 	int Icl;
; 1970 : 	if ((Xp < T.Win.Xmin) || (Xp >= T.Win.Xmax) ||
; 1971 : 		(Yp < T.Win.Ymin) || (Yp >= T.Win.Ymax)) return -1;

	fstp	ST(0)
$LN8@GetCell:
	fstp	ST(0)
	or	eax, -1
	pop	esi

; 1976 : 	};

	ret	8
?GetCell@CSmartTrackerClass@@IAEHMM@Z ENDP		; CSmartTrackerClass::GetCell
_TEXT	ENDS
PUBLIC	?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z ; CSmartTrackerClass::InsertNewTrack
; Function compile flags: /Ogtpy
;	COMDAT ?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv785 = -12						; size = 4
tv89 = -8						; size = 4
tv781 = -4						; size = 4
_pTempGrains$ = 8					; size = 4
_Layers$ = 12						; size = 4
_SequenceLength$ = 16					; size = 4
tv688 = 20						; size = 4
_pTracks$ = 20						; size = 4
_i$ = 24						; size = 4
_NTracks$ = 24						; size = 4
?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z PROC ; CSmartTrackerClass::InsertNewTrack, COMDAT
; _this$ = ecx

; 2053 : {

	sub	esp, 16					; 00000010H
	push	ebp

; 2054 : 	int i, j;
; 2055 : 	for (i = 0; i < Layers; i++)

	mov	ebp, DWORD PTR _SequenceLength$[esp+16]
	push	edi
	mov	edi, DWORD PTR _Layers$[esp+20]
	mov	DWORD PTR _this$[esp+24], ecx
	xor	ecx, ecx
	xor	eax, eax
	cmp	edi, ecx
	jle	SHORT $LN34@InsertNewT
	npad	7
$LL15@InsertNewT:

; 2056 : 		if (pTempGrains[i] && pTempGrains[i]->TrackLength >= SequenceLength) return;

	mov	edx, DWORD PTR _pTempGrains$[esp+20]
	mov	edx, DWORD PTR [edx+eax*4]
	cmp	edx, ecx
	je	SHORT $LN14@InsertNewT
	cmp	DWORD PTR [edx+12], ebp
	jge	$LN16@InsertNewT
$LN14@InsertNewT:

; 2054 : 	int i, j;
; 2055 : 	for (i = 0; i < Layers; i++)

	add	eax, 1
	cmp	eax, edi
	jl	SHORT $LL15@InsertNewT
$LN34@InsertNewT:
	push	ebx

; 2057 : 	for (i = 0; i < Layers; i++)

	xor	ebx, ebx
	cmp	edi, ecx
	push	esi
	jle	SHORT $LN9@InsertNewT
$LL11@InsertNewT:

; 2058 : 		if (pTempGrains[i] && pTempGrains[i]->pTrack)

	mov	eax, DWORD PTR _pTempGrains$[esp+28]
	mov	eax, DWORD PTR [eax+ebx*4]
	cmp	eax, ecx
	je	SHORT $LN10@InsertNewT
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, ecx
	je	SHORT $LN10@InsertNewT

; 2061 : 			for (j = 0; j < N.PointsN; j++)

	xor	esi, esi
	cmp	DWORD PTR [edx+4], ecx
	jbe	SHORT $LN5@InsertNewT

; 2059 : 		{
; 2060 : 			Track &N = *pTempGrains[i]->pTrack;

	xor	edi, edi
	npad	2
$LL7@InsertNewT:

; 2062 : 			{
; 2063 : 				IntGrain *pG = ((IntTrackVector *)N.pPoints)[j].T.pG;

	mov	eax, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edi+eax]
	add	esi, 1

; 2064 : 				pG->TrackLength = 0;

	mov	DWORD PTR [eax+12], ecx

; 2065 : 				pG->pTrack = 0;

	mov	DWORD PTR [eax+16], ecx
	add	edi, 12					; 0000000cH
	cmp	esi, DWORD PTR [edx+4]
	jb	SHORT $LL7@InsertNewT

; 2061 : 			for (j = 0; j < N.PointsN; j++)

	mov	edi, DWORD PTR _Layers$[esp+28]
$LN5@InsertNewT:

; 2066 : 				}
; 2067 : 			N.Valid = false;

	mov	BYTE PTR [edx+76], cl

; 2068 : 			N.PointsN = 0;

	mov	DWORD PTR [edx+4], ecx
$LN10@InsertNewT:
	add	ebx, 1
	cmp	ebx, edi
	jl	SHORT $LL11@InsertNewT
$LN9@InsertNewT:

; 2069 : 			}
; 2070 : 	Track &N = pTracks[NTracks++];

	mov	esi, DWORD PTR _NTracks$[esp+28]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+edx*4]
	add	edx, 1
	shl	eax, 4
	add	eax, DWORD PTR _pTracks$[esp+28]
	mov	DWORD PTR [esi], edx

; 2071 : 	for (i = j = 0; i < Layers; i++)

	xor	ebx, ebx
	xor	esi, esi
	cmp	edi, 4
	jl	$LC28@InsertNewT
	mov	ecx, DWORD PTR _Layers$[esp+28]
	mov	edi, DWORD PTR _pTempGrains$[esp+28]
	mov	esi, 4
	sub	esi, DWORD PTR _pTempGrains$[esp+28]
	add	ecx, -4					; fffffffcH
	mov	DWORD PTR tv781[esp+32], esi
	mov	esi, -8					; fffffff8H
	sub	esi, DWORD PTR _pTempGrains$[esp+28]
	shr	ecx, 2
	xor	edx, edx
	add	edi, 8
	add	ecx, 1
	mov	DWORD PTR tv785[esp+32], esi
	lea	esi, DWORD PTR [ecx*4]
	mov	DWORD PTR tv688[esp+28], 8
	mov	DWORD PTR tv89[esp+32], ecx
	mov	DWORD PTR _i$[esp+28], esi
$LL35@InsertNewT:

; 2072 : 		if (pTempGrains[i])

	mov	ecx, DWORD PTR [edi-8]
	test	ecx, ecx
	je	SHORT $LN36@InsertNewT

; 2073 : 		{
; 2074 : 			IntTrackVector *pIG = ((IntTrackVector *)N.pPoints) + j++;

	mov	esi, DWORD PTR [eax+8]

; 2075 : 			pIG->T.pG = pTempGrains[i];

	mov	DWORD PTR [esi+edx], ecx
	add	esi, edx

; 2076 : 			pIG->T.pG->pTrack = &N;

	mov	DWORD PTR [ecx+16], eax

; 2077 : 			pIG->T.pG->TrackLength = SequenceLength;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], ebp

; 2078 : 			pIG->T.Z = T.ZLayer[i];

	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+964]
	mov	ebp, DWORD PTR _SequenceLength$[esp+28]
	add	ebx, 1
	add	edx, 12					; 0000000cH
	add	ecx, DWORD PTR tv785[esp+32]
	fld	DWORD PTR [ecx+edi]
	fstp	DWORD PTR [esi+4]
	mov	esi, DWORD PTR _i$[esp+28]
$LN36@InsertNewT:
	mov	ecx, DWORD PTR [edi-4]
	test	ecx, ecx
	je	SHORT $LN30@InsertNewT
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+edx], ecx
	add	esi, edx
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], ebp
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+964]
	mov	ebp, DWORD PTR _SequenceLength$[esp+28]
	add	ebx, 1
	add	edx, 12					; 0000000cH
	add	ecx, DWORD PTR tv785[esp+32]
	fld	DWORD PTR [ecx+edi+4]
	fstp	DWORD PTR [esi+4]
	mov	esi, DWORD PTR _i$[esp+28]
$LN30@InsertNewT:
	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN31@InsertNewT
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+edx], ecx
	add	esi, edx
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], ebp
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+964]
	mov	ebp, DWORD PTR tv688[esp+28]
	fld	DWORD PTR [ecx+ebp]
	mov	ebp, DWORD PTR _SequenceLength$[esp+28]
	fstp	DWORD PTR [esi+4]
	mov	esi, DWORD PTR _i$[esp+28]
	add	ebx, 1
	add	edx, 12					; 0000000cH
$LN31@InsertNewT:
	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN32@InsertNewT
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+edx], ecx
	add	esi, edx
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], ebp
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+964]
	mov	ebp, DWORD PTR _SequenceLength$[esp+28]
	add	ebx, 1
	add	edx, 12					; 0000000cH
	add	ecx, DWORD PTR tv781[esp+32]
	fld	DWORD PTR [ecx+edi]
	fstp	DWORD PTR [esi+4]
	mov	esi, DWORD PTR _i$[esp+28]
$LN32@InsertNewT:
	add	DWORD PTR tv688[esp+28], 16		; 00000010H
	add	edi, 16					; 00000010H
	sub	DWORD PTR tv89[esp+32], 1
	jne	$LL35@InsertNewT
	mov	edi, DWORD PTR _Layers$[esp+28]
	xor	ecx, ecx
$LC28@InsertNewT:

; 2071 : 	for (i = j = 0; i < Layers; i++)

	cmp	esi, edi
	jge	SHORT $LN27@InsertNewT
	lea	ebx, DWORD PTR [ebx+ebx*2]
	add	ebx, ebx
	add	ebx, ebx
	npad	7
$LL37@InsertNewT:

; 2072 : 		if (pTempGrains[i])

	mov	edx, DWORD PTR _pTempGrains$[esp+28]
	mov	edi, DWORD PTR [edx+esi*4]
	cmp	edi, ecx
	je	SHORT $LN3@InsertNewT

; 2073 : 		{
; 2074 : 			IntTrackVector *pIG = ((IntTrackVector *)N.pPoints) + j++;

	mov	edx, DWORD PTR [eax+8]
	add	edx, ebx

; 2075 : 			pIG->T.pG = pTempGrains[i];

	mov	DWORD PTR [edx], edi

; 2076 : 			pIG->T.pG->pTrack = &N;

	mov	DWORD PTR [edi+16], eax

; 2077 : 			pIG->T.pG->TrackLength = SequenceLength;

	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edi+12], ebp

; 2078 : 			pIG->T.Z = T.ZLayer[i];

	mov	edi, DWORD PTR _this$[esp+32]
	mov	edi, DWORD PTR [edi+964]
	fld	DWORD PTR [edi+esi*4]
	add	ebx, 12					; 0000000cH
	fstp	DWORD PTR [edx+4]
$LN3@InsertNewT:
	add	esi, 1
	cmp	esi, DWORD PTR _Layers$[esp+28]
	jl	SHORT $LL37@InsertNewT
$LN27@InsertNewT:
	pop	esi

; 2079 : 			}
; 2080 : 	N.Valid = true;

	mov	BYTE PTR [eax+76], 1

; 2081 : 	N.PointsN = SequenceLength;

	mov	DWORD PTR [eax+4], ebp
	pop	ebx
$LN16@InsertNewT:
	pop	edi
	pop	ebp

; 2082 : };

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z ENDP ; CSmartTrackerClass::InsertNewTrack
_TEXT	ENDS
PUBLIC	?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z ; CSmartTrackerClass::InsertNewTrack
; Function compile flags: /Ogtpy
;	COMDAT ?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv785 = -12						; size = 4
tv89 = -8						; size = 4
tv781 = -4						; size = 4
_pTempGrains$ = 8					; size = 4
_Layers$ = 12						; size = 4
_SequenceLength$ = 16					; size = 4
tv688 = 20						; size = 4
_pTracks$ = 20						; size = 4
_i$ = 24						; size = 4
_NTracks$ = 24						; size = 4
?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z PROC ; CSmartTrackerClass::InsertNewTrack, COMDAT
; _this$ = ecx

; 2085 : {

	sub	esp, 16					; 00000010H
	push	ebp

; 2086 : 	int i, j;
; 2087 : 	for (i = 0; i < Layers; i++)

	mov	ebp, DWORD PTR _SequenceLength$[esp+16]
	push	edi
	mov	edi, DWORD PTR _Layers$[esp+20]
	mov	DWORD PTR _this$[esp+24], ecx
	xor	ecx, ecx
	xor	eax, eax
	cmp	edi, ecx
	jle	SHORT $LN34@InsertNewT@2
	npad	7
$LL15@InsertNewT@2:

; 2088 : 		if (pTempGrains[i] && pTempGrains[i]->TrackLength >= SequenceLength) return;

	mov	edx, DWORD PTR _pTempGrains$[esp+20]
	mov	edx, DWORD PTR [edx+eax*4]
	cmp	edx, ecx
	je	SHORT $LN14@InsertNewT@2
	cmp	DWORD PTR [edx+12], ebp
	jge	$LN16@InsertNewT@2
$LN14@InsertNewT@2:

; 2086 : 	int i, j;
; 2087 : 	for (i = 0; i < Layers; i++)

	add	eax, 1
	cmp	eax, edi
	jl	SHORT $LL15@InsertNewT@2
$LN34@InsertNewT@2:
	push	ebx

; 2089 : 	for (i = 0; i < Layers; i++)

	xor	ebx, ebx
	cmp	edi, ecx
	push	esi
	jle	SHORT $LN9@InsertNewT@2
$LL11@InsertNewT@2:

; 2090 : 		if (pTempGrains[i] && pTempGrains[i]->pTrack2)

	mov	eax, DWORD PTR _pTempGrains$[esp+28]
	mov	eax, DWORD PTR [eax+ebx*4]
	cmp	eax, ecx
	je	SHORT $LN10@InsertNewT@2
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, ecx
	je	SHORT $LN10@InsertNewT@2

; 2093 : 			for (j = 0; j < N.Grains; j++)

	xor	esi, esi
	cmp	DWORD PTR [edx+4], ecx
	jbe	SHORT $LN5@InsertNewT@2

; 2091 : 		{
; 2092 : 			Track2 &N = *pTempGrains[i]->pTrack2;

	xor	edi, edi
	npad	2
$LL7@InsertNewT@2:

; 2094 : 			{
; 2095 : 				IntGrain *pG = ((IntTrackGrain *)N.pGrains)[j].T.pG;

	mov	eax, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [edi+eax]
	add	esi, 1

; 2096 : 				pG->TrackLength = 0;

	mov	DWORD PTR [eax+12], ecx

; 2097 : 				pG->pTrack2 = 0;

	mov	DWORD PTR [eax+16], ecx
	add	edi, 16					; 00000010H
	cmp	esi, DWORD PTR [edx+4]
	jb	SHORT $LL7@InsertNewT@2

; 2093 : 			for (j = 0; j < N.Grains; j++)

	mov	edi, DWORD PTR _Layers$[esp+28]
$LN5@InsertNewT@2:

; 2098 : 				}
; 2099 : 			N.Valid = false;

	mov	BYTE PTR [edx+56], cl

; 2100 : 			N.Grains = 0;

	mov	DWORD PTR [edx+4], ecx
$LN10@InsertNewT@2:
	add	ebx, 1
	cmp	ebx, edi
	jl	SHORT $LL11@InsertNewT@2
$LN9@InsertNewT@2:

; 2101 : 			}
; 2102 : 	Track2 &N = pTracks[NTracks++];

	mov	esi, DWORD PTR _NTracks$[esp+28]
	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR _pTracks$[esp+28]
	mov	eax, edx
	shl	eax, 4
	sub	eax, edx
	add	edx, 1
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi], edx

; 2103 : 	for (i = j = 0; i < Layers; i++)

	xor	ebx, ebx
	xor	esi, esi
	cmp	edi, 4
	jl	$LC28@InsertNewT@2
	mov	ecx, DWORD PTR _Layers$[esp+28]
	mov	edi, DWORD PTR _pTempGrains$[esp+28]
	mov	esi, 4
	sub	esi, DWORD PTR _pTempGrains$[esp+28]
	add	ecx, -4					; fffffffcH
	mov	DWORD PTR tv781[esp+32], esi
	mov	esi, -8					; fffffff8H
	sub	esi, DWORD PTR _pTempGrains$[esp+28]
	shr	ecx, 2
	xor	edx, edx
	add	edi, 8
	add	ecx, 1
	mov	DWORD PTR tv785[esp+32], esi
	lea	esi, DWORD PTR [ecx*4]
	mov	DWORD PTR tv688[esp+28], 8
	mov	DWORD PTR tv89[esp+32], ecx
	mov	DWORD PTR _i$[esp+28], esi
$LL35@InsertNewT@2:

; 2104 : 		if (pTempGrains[i])

	mov	ecx, DWORD PTR [edi-8]
	test	ecx, ecx
	je	SHORT $LN36@InsertNewT@2

; 2105 : 		{
; 2106 : 			IntTrackGrain *pIG = ((IntTrackGrain *)N.pGrains) + j++;

	mov	esi, DWORD PTR [eax+12]

; 2107 : 			pIG->T.pG = pTempGrains[i];

	mov	DWORD PTR [esi+edx], ecx
	add	esi, edx

; 2108 : 			pIG->T.pG->pTrack2 = &N;

	mov	DWORD PTR [ecx+16], eax

; 2109 : 			pIG->T.pG->TrackLength = SequenceLength;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], ebp

; 2110 : 			pIG->T.Z = T.ZLayer[i];

	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+964]
	mov	ebp, DWORD PTR _SequenceLength$[esp+28]
	add	ebx, 1
	add	edx, 16					; 00000010H
	add	ecx, DWORD PTR tv785[esp+32]
	fld	DWORD PTR [ecx+edi]
	fstp	DWORD PTR [esi+4]
	mov	esi, DWORD PTR _i$[esp+28]
$LN36@InsertNewT@2:
	mov	ecx, DWORD PTR [edi-4]
	test	ecx, ecx
	je	SHORT $LN30@InsertNewT@2
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+edx], ecx
	add	esi, edx
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], ebp
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+964]
	mov	ebp, DWORD PTR _SequenceLength$[esp+28]
	add	ebx, 1
	add	edx, 16					; 00000010H
	add	ecx, DWORD PTR tv785[esp+32]
	fld	DWORD PTR [ecx+edi+4]
	fstp	DWORD PTR [esi+4]
	mov	esi, DWORD PTR _i$[esp+28]
$LN30@InsertNewT@2:
	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN31@InsertNewT@2
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+edx], ecx
	add	esi, edx
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], ebp
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+964]
	mov	ebp, DWORD PTR tv688[esp+28]
	fld	DWORD PTR [ecx+ebp]
	mov	ebp, DWORD PTR _SequenceLength$[esp+28]
	fstp	DWORD PTR [esi+4]
	mov	esi, DWORD PTR _i$[esp+28]
	add	ebx, 1
	add	edx, 16					; 00000010H
$LN31@InsertNewT@2:
	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN32@InsertNewT@2
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+edx], ecx
	add	esi, edx
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], ebp
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+964]
	mov	ebp, DWORD PTR _SequenceLength$[esp+28]
	add	ebx, 1
	add	edx, 16					; 00000010H
	add	ecx, DWORD PTR tv781[esp+32]
	fld	DWORD PTR [ecx+edi]
	fstp	DWORD PTR [esi+4]
	mov	esi, DWORD PTR _i$[esp+28]
$LN32@InsertNewT@2:
	add	DWORD PTR tv688[esp+28], 16		; 00000010H
	add	edi, 16					; 00000010H
	sub	DWORD PTR tv89[esp+32], 1
	jne	$LL35@InsertNewT@2
	mov	edi, DWORD PTR _Layers$[esp+28]
	xor	ecx, ecx
$LC28@InsertNewT@2:

; 2103 : 	for (i = j = 0; i < Layers; i++)

	cmp	esi, edi
	jge	SHORT $LN27@InsertNewT@2
	shl	ebx, 4
	npad	7
$LL37@InsertNewT@2:

; 2104 : 		if (pTempGrains[i])

	mov	edx, DWORD PTR _pTempGrains$[esp+28]
	mov	edi, DWORD PTR [edx+esi*4]
	cmp	edi, ecx
	je	SHORT $LN3@InsertNewT@2

; 2105 : 		{
; 2106 : 			IntTrackGrain *pIG = ((IntTrackGrain *)N.pGrains) + j++;

	mov	edx, DWORD PTR [eax+12]
	add	edx, ebx

; 2107 : 			pIG->T.pG = pTempGrains[i];

	mov	DWORD PTR [edx], edi

; 2108 : 			pIG->T.pG->pTrack2 = &N;

	mov	DWORD PTR [edi+16], eax

; 2109 : 			pIG->T.pG->TrackLength = SequenceLength;

	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edi+12], ebp

; 2110 : 			pIG->T.Z = T.ZLayer[i];

	mov	edi, DWORD PTR _this$[esp+32]
	mov	edi, DWORD PTR [edi+964]
	fld	DWORD PTR [edi+esi*4]
	add	ebx, 16					; 00000010H
	fstp	DWORD PTR [edx+4]
$LN3@InsertNewT@2:
	add	esi, 1
	cmp	esi, DWORD PTR _Layers$[esp+28]
	jl	SHORT $LL37@InsertNewT@2
$LN27@InsertNewT@2:
	pop	esi

; 2111 : 			}
; 2112 : 	N.Valid = true;

	mov	BYTE PTR [eax+56], 1

; 2113 : 	N.Grains = SequenceLength;

	mov	DWORD PTR [eax+4], ebp
	pop	ebx
$LN16@InsertNewT@2:
	pop	edi
	pop	ebp

; 2114 : };

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z ENDP ; CSmartTrackerClass::InsertNewTrack
_TEXT	ENDS
PUBLIC	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z ; CSmartTrackerClass::FinalizeTracks
; Function compile flags: /Ogtpy
;	COMDAT ?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z
_TEXT	SEGMENT
tv287 = -4						; size = 4
tv158 = 8						; size = 4
_ntracks$ = 8						; size = 4
_j$ = 12						; size = 4
_pspace$ = 12						; size = 4
?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z PROC ; CSmartTrackerClass::FinalizeTracks, COMDAT
; _this$ = ecx

; 2117 : {

	push	ecx

; 2118 : 	int i, j, k;
; 2119 : 	for (i = j = 0; i < ntracks; i++)

	mov	ecx, DWORD PTR _ntracks$[esp]
	xor	eax, eax
	test	ecx, ecx
	jle	$LN5@FinalizeTr
	mov	edx, DWORD PTR _pspace$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
	lea	ebp, DWORD PTR [edx+76]
	mov	DWORD PTR tv158[esp+16], ecx
	npad	2
$LL16@FinalizeTr:

; 2120 : 		if (pspace[i].Valid)

	cmp	BYTE PTR [ebp], 0
	je	SHORT $LN6@FinalizeTr

; 2123 : 			Track &N = pspace[j++];
; 2124 : 			N.PointsN = O.PointsN;

	mov	esi, DWORD PTR [ebp-72]
	mov	ecx, edx
	mov	DWORD PTR [ecx+4], esi
	add	eax, 1
	add	edx, 80					; 00000050H

; 2125 : 			O.Valid = false;

	mov	BYTE PTR [ebp], 0

; 2126 : 			N.Valid = true;
; 2127 : 			for (k = 0; k < N.PointsN; k++)

	xor	ebx, ebx
	cmp	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR _j$[esp+16], eax
	mov	DWORD PTR tv287[esp+20], edx
	mov	BYTE PTR [ecx+76], 1
	jbe	SHORT $LN6@FinalizeTr

; 2121 : 		{
; 2122 : 			Track &O = pspace[i];

	xor	edx, edx
	npad	3
$LL3@FinalizeTr:

; 2128 : 			{
; 2129 : 				IntGrain *pG = ((IntTrackVector *)O.pPoints)[k].T.pG;

	mov	eax, DWORD PTR [ebp-68]
	mov	edi, DWORD PTR [eax+edx]

; 2130 : 				N.pPoints[k].Z = ((IntTrackVector *)O.pPoints)[k].T.Z;

	fld	DWORD PTR [eax+edx+4]
	lea	esi, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+edx+8]

; 2131 : 				N.pPoints[k].X = pG->Xcm;

	mov	eax, DWORD PTR [ecx+8]
	fld	DWORD PTR [edi]
	add	ebx, 1
	fstp	DWORD PTR [edx+eax]

; 2132 : 				N.pPoints[k].Y = pG->Ycm;

	mov	eax, DWORD PTR [ecx+8]
	fld	DWORD PTR [edi+4]
	add	edx, 12					; 0000000cH
	fstp	DWORD PTR [eax+edx-8]
	cmp	ebx, DWORD PTR [ecx+4]
	jb	SHORT $LL3@FinalizeTr
	mov	eax, DWORD PTR _j$[esp+16]
	mov	edx, DWORD PTR tv287[esp+20]
$LN6@FinalizeTr:
	add	ebp, 80					; 00000050H
	sub	DWORD PTR tv158[esp+16], 1
	jne	SHORT $LL16@FinalizeTr
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN5@FinalizeTr:

; 2133 : 				}
; 2134 : 			}
; 2135 : 	return j;
; 2136 : 	}

	pop	ecx
	ret	8
?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z ENDP ; CSmartTrackerClass::FinalizeTracks
_TEXT	ENDS
PUBLIC	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z ; CSmartTrackerClass::FinalizeTracks
; Function compile flags: /Ogtpy
;	COMDAT ?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z
_TEXT	SEGMENT
_dsx$ = -24						; size = 4
_k$ = -20						; size = 4
_dsy$ = -20						; size = 4
_this$ = -16						; size = 4
tv327 = -12						; size = 4
tv326 = -12						; size = 4
tv210 = -12						; size = 4
tv565 = -8						; size = 4
_avglx$ = -8						; size = 4
_j$ = -4						; size = 4
_avgly$ = -4						; size = 4
_a$ = 8							; size = 4
_ntracks$ = 8						; size = 4
tv578 = 12						; size = 4
tv576 = 12						; size = 4
_dz$131851 = 12						; size = 4
_pspace$ = 12						; size = 4
?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z PROC ; CSmartTrackerClass::FinalizeTracks, COMDAT
; _this$ = ecx

; 2139 : {

	sub	esp, 24					; 00000018H

; 2140 : 	float avglx = T.TotalLX / T.Layer;

	mov	eax, DWORD PTR [ecx+1016]

; 2141 : 	float avgly = T.TotalLY / T.Layer;
; 2142 : 	int i, j, k, a, ta;
; 2143 : 	float dsx, dsy;
; 2144 : 	if (T.Layer > 1)

	cmp	eax, 1
	mov	DWORD PTR tv326[esp+24], eax
	fild	DWORD PTR tv326[esp+24]
	mov	DWORD PTR _this$[esp+24], ecx
	fstp	DWORD PTR tv327[esp+24]
	fld	DWORD PTR [ecx+1104]
	fld	DWORD PTR tv327[esp+24]
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _avglx$[esp+24]
	fdivr	DWORD PTR [ecx+1108]
	fstp	DWORD PTR _avgly$[esp+24]
	jle	SHORT $LN11@FinalizeTr@2

; 2145 : 	{
; 2146 : 		dsx = T.DispX / (T.ZLayer[0] - T.ZLayer[T.Layer - 1]);

	mov	eax, DWORD PTR [ecx+964]
	fld	DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+1016]
	fsub	DWORD PTR [eax+edx*4-4]
	fld	DWORD PTR [ecx+1020]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _dsx$[esp+24]

; 2147 : 		dsy = T.DispY / (T.ZLayer[0] - T.ZLayer[T.Layer - 1]);

	fdivr	DWORD PTR [ecx+1024]
	fstp	DWORD PTR _dsy$[esp+24]
	jmp	SHORT $LN10@FinalizeTr@2
$LN11@FinalizeTr@2:

; 2148 : 		}
; 2149 : 	else dsx = dsy = 0.0f;

	fldz
	fst	DWORD PTR _dsy$[esp+24]
	fstp	DWORD PTR _dsx$[esp+24]
$LN10@FinalizeTr@2:

; 2150 : 	for (i = j = 0; i < ntracks; i++)

	mov	edx, DWORD PTR _ntracks$[esp+20]
	push	ebx
	xor	ebx, ebx
	xor	eax, eax
	cmp	edx, ebx
	jle	$LN7@FinalizeTr@2
	mov	ecx, DWORD PTR _pspace$[esp+24]
	fld	DWORD PTR _avglx$[esp+28]
	fld	DWORD PTR _avgly$[esp+28]
	push	ebp
	fld	DWORD PTR _dsx$[esp+32]
	push	esi
	fld	DWORD PTR _dsy$[esp+36]
	mov	esi, ecx
	push	edi
	add	ecx, 56					; 00000038H
	mov	DWORD PTR tv210[esp+40], edx
$LN9@FinalizeTr@2:

; 2151 : 		if (pspace[i].Valid)

	cmp	BYTE PTR [ecx], bl
	je	$LN8@FinalizeTr@2

; 2154 : 			Track2 &N = pspace[j++];
; 2155 : 			N.Grains = O.Grains;

	mov	edi, DWORD PTR [ecx-52]
	mov	edx, esi
	mov	DWORD PTR [edx+4], edi
	add	eax, 1
	add	esi, 60					; 0000003cH

; 2156 : 			O.Valid = false;

	mov	BYTE PTR [ecx], bl

; 2157 : 			N.Valid = true;
; 2158 : 			a = 0;
; 2159 : 			for (k = 0; k < N.Grains; k++)

	cmp	DWORD PTR [edx+4], ebx
	mov	DWORD PTR _j$[esp+40], eax
	mov	DWORD PTR tv565[esp+40], esi
	mov	BYTE PTR [edx+56], 1
	mov	DWORD PTR _a$[esp+36], ebx
	mov	DWORD PTR _k$[esp+40], ebx
	jbe	$LN3@FinalizeTr@2

; 2152 : 		{
; 2153 : 			Track2 &O = pspace[i];

	xor	esi, esi
$LN19@FinalizeTr@2:

; 2160 : 			{
; 2161 : 				IntGrain *pG = ((IntTrackGrain *)O.pGrains)[k].T.pG;

	mov	eax, DWORD PTR [ecx-44]
	mov	edi, DWORD PTR [esi+eax]

; 2162 : 				a += (ta = pG->Area);
; 2163 : 				float dz = (N.pGrains[k].Z = ((IntTrackGrain *)O.pGrains)[k].T.Z) - T.ZLayer[0];

	fld	DWORD PTR [esi+eax+4]
	mov	ebp, DWORD PTR [edi+8]
	lea	ebx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edx+12]
	add	DWORD PTR _a$[esp+36], ebp
	fstp	DWORD PTR [eax+esi+12]
	mov	eax, DWORD PTR [edx+12]
	fld	DWORD PTR [eax+esi+12]
	lea	ebx, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR _this$[esp+40]
	mov	eax, DWORD PTR [eax+964]
	fsub	DWORD PTR [eax]

; 2164 : 				if (T.Side == 0)

	mov	eax, DWORD PTR _this$[esp+40]
	cmp	DWORD PTR [eax+1100], 0
	fstp	DWORD PTR _dz$131851[esp+36]

; 2165 : 				{
; 2166 : 					N.pGrains[k].X = pG->Xcm + dsx * dz - avglx;

	fld	DWORD PTR _dz$131851[esp+36]
	fld	ST(0)
	fmul	ST(0), ST(3)
	fadd	DWORD PTR [edi]
	jne	SHORT $LN2@FinalizeTr@2
	fsub	ST(0), ST(5)
	fstp	DWORD PTR [ebx+4]

; 2167 : 					N.pGrains[k].Y = pG->Ycm + dsy * dz - avgly;

	fmul	ST(0), ST(1)
	fadd	DWORD PTR [edi+4]
	fsub	ST(0), ST(3)
	fstp	DWORD PTR tv578[esp+36]
	fld	DWORD PTR tv578[esp+36]

; 2168 : 					N.pGrains[k].Area = ta;
; 2169 : 					}
; 2170 : 				else

	jmp	SHORT $LN36@FinalizeTr@2
$LN2@FinalizeTr@2:

; 2171 : 				{
; 2172 : 					N.pGrains[k].X = pG->Xcm + dsx * dz;

	fstp	DWORD PTR [ebx+4]

; 2173 : 					N.pGrains[k].Y = pG->Ycm + dsy * dz;				

	fmul	ST(0), ST(1)
	fadd	DWORD PTR [edi+4]
	fstp	DWORD PTR tv576[esp+36]
	fld	DWORD PTR tv576[esp+36]
$LN36@FinalizeTr@2:
	mov	eax, DWORD PTR [edx+12]
	fstp	DWORD PTR [eax+esi+8]

; 2174 : 					N.pGrains[k].Area = ta;

	mov	eax, DWORD PTR [edx+12]
	mov	WORD PTR [esi+eax], bp
	mov	eax, DWORD PTR _k$[esp+40]
	add	eax, 1
	add	esi, 16					; 00000010H
	cmp	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _k$[esp+40], eax
	jb	$LN19@FinalizeTr@2
	mov	eax, DWORD PTR _j$[esp+40]
	mov	esi, DWORD PTR tv565[esp+40]
	xor	ebx, ebx
$LN3@FinalizeTr@2:

; 2175 : 					}
; 2176 : 				}
; 2177 : 			N.AreaSum = a;

	mov	edi, DWORD PTR _a$[esp+36]
	mov	DWORD PTR [edx+8], edi
$LN8@FinalizeTr@2:
	add	ecx, 60					; 0000003cH
	sub	DWORD PTR tv210[esp+40], 1
	jne	$LN9@FinalizeTr@2
	fstp	ST(1)
	pop	edi
	fstp	ST(0)
	pop	esi
	fstp	ST(1)
	pop	ebp
	fstp	ST(0)
$LN7@FinalizeTr@2:
	pop	ebx

; 2178 : 			}
; 2179 : 	return j;
; 2180 : }

	add	esp, 24					; 00000018H
	ret	8
?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z ENDP ; CSmartTrackerClass::FinalizeTracks
_TEXT	ENDS
PUBLIC	?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z ; CSmartTrackerClass::IsSigmaValid
; Function compile flags: /Ogtpy
;	COMDAT ?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z
_TEXT	SEGMENT
_pTempGrains$ = 8					; size = 4
_Layers$ = 12						; size = 4
?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z PROC ; CSmartTrackerClass::IsSigmaValid, COMDAT
; _this$ = ecx

; 2205 : 	return false;

	xor	al, al

; 2206 : }

	ret	8
?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z ENDP ; CSmartTrackerClass::IsSigmaValid
_TEXT	ENDS
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ; GetData
EXTRN	__imp__sscanf:PROC
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
; File d:\sysal2\common\config2.cpp
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_C$ = 8							; size = 4
_QueryDataCount$ = 12					; size = 4
_pQDI$ = 16						; size = 4
_pC$ = 20						; size = 4
_UseDefault$ = 24					; size = 1
?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z PROC ; GetData, COMDAT

; 6    : {

	push	ecx

; 7    : 	int i, j;
; 8    : 	char *pD;
; 9    : 	for (i = 0; i < QueryDataCount; i++)

	cmp	DWORD PTR _QueryDataCount$[esp], 0
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _i$[esp+20], 0
	jle	$LN16@GetData
	mov	ebx, DWORD PTR _pQDI$[esp+16]
	add	ebx, 68					; 00000044H
	npad	1
$LL18@GetData:

; 10   : 	{
; 11   : 		for (j = 0; (j < C.CountOfItems) && strcmp(pQDI[i].Name, C.pItems + j * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN)); j++);

	mov	eax, DWORD PTR _C$[esp+16]
	mov	ebp, DWORD PTR [eax+64]
	xor	esi, esi
	test	ebp, ebp
	jle	SHORT $LN13@GetData
	mov	edi, DWORD PTR [eax+68]
$LL15@GetData:
	mov	ecx, edi
	lea	eax, DWORD PTR [ebx-68]
$LL27@GetData:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN28@GetData
	test	dl, dl
	je	SHORT $LN29@GetData
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN28@GetData
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL27@GetData
$LN29@GetData:
	xor	eax, eax
	jmp	SHORT $LN30@GetData
$LN28@GetData:
	sbb	eax, eax
	sbb	eax, -1
$LN30@GetData:
	test	eax, eax
	je	SHORT $LN33@GetData
	add	esi, 1
	add	edi, 128				; 00000080H
	cmp	esi, ebp
	jl	SHORT $LL15@GetData
$LN33@GetData:
	mov	eax, DWORD PTR _C$[esp+16]
$LN13@GetData:

; 12   : 		if (j == C.CountOfItems)

	cmp	esi, ebp
	jne	SHORT $LN12@GetData

; 13   : 		{
; 14   : 			if (UseDefault) pD = pQDI[i].Default;

	cmp	BYTE PTR _UseDefault$[esp+16], 0
	je	SHORT $LN16@GetData
	lea	eax, DWORD PTR [ebx+4]

; 15   : 			else return i;

	jmp	SHORT $LN9@GetData
$LN12@GetData:

; 16   : 			}
; 17   : 		else pD = C.pItems + j * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN;

	mov	eax, DWORD PTR [eax+68]
	shl	esi, 7
	lea	eax, DWORD PTR [esi+eax+64]
$LN9@GetData:

; 18   : 		switch (pQDI[i].Format)

	movsx	ecx, BYTE PTR [ebx-4]
	sub	ecx, 1
	je	SHORT $LN6@GetData
	sub	ecx, 1
	je	SHORT $LN4@GetData
	sub	ecx, 1
	jne	SHORT $LN16@GetData

; 25   : 
; 26   : 			case ST_STRING:	strncpy(((char *)pC + pQDI[i].Position), pD, SYSAL_MAXCONFIG_ENTRY_VALUE_LEN);

	mov	ecx, DWORD PTR [ebx]
	add	ecx, DWORD PTR _pC$[esp+16]
	push	64					; 00000040H
	push	eax
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 27   : 							break;

	jmp	SHORT $LN17@GetData
$LN4@GetData:

; 21   : 							break;
; 22   : 
; 23   : 			case ST_FLOAT:	if (sscanf(pD, "%f", (float *)((char *)pC + pQDI[i].Position)) != 1) return i;

	mov	edx, DWORD PTR [ebx]
	add	edx, DWORD PTR _pC$[esp+16]
	push	edx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@

; 24   : 							break;

	jmp	SHORT $LN35@GetData
$LN6@GetData:

; 19   : 		{
; 20   : 			case ST_INT:	if (sscanf(pD, "%d", (int *)((char *)pC + pQDI[i].Position)) != 1) return i;

	mov	ecx, DWORD PTR [ebx]
	add	ecx, DWORD PTR _pC$[esp+16]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
$LN35@GetData:
	push	eax
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN16@GetData
$LN17@GetData:

; 7    : 	int i, j;
; 8    : 	char *pD;
; 9    : 	for (i = 0; i < QueryDataCount; i++)

	mov	eax, DWORD PTR _i$[esp+20]
	add	eax, 1
	add	ebx, 136				; 00000088H
	cmp	eax, DWORD PTR _QueryDataCount$[esp+16]
	mov	DWORD PTR _i$[esp+20], eax
	jl	$LL18@GetData
$LN16@GetData:

; 28   : 
; 29   : 			default:		return i;			
; 30   : 			};
; 31   : 		};
; 32   : 	return i;

	mov	eax, DWORD PTR _i$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 33   : 	};

	pop	ecx
	ret	0
?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ENDP ; GetData
_TEXT	ENDS
PUBLIC	??_C@_02BEIEFPIG@?$CFg?$AA@			; `string'
PUBLIC	?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutData
EXTRN	__imp__sprintf:PROC
EXTRN	__imp__CoTaskMemAlloc@4:PROC
EXTRN	__imp__CoTaskMemFree@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_02BEIEFPIG@?$CFg?$AA@
CONST	SEGMENT
??_C@_02BEIEFPIG@?$CFg?$AA@ DB '%g', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z
_TEXT	SEGMENT
_C$ = 8							; size = 4
_QueryDataCount$ = 12					; size = 4
_pQDI$ = 16						; size = 4
_pC$ = 20						; size = 4
?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z PROC ; PutData, COMDAT

; 36   : {

	push	ebx
	push	ebp
	push	esi

; 37   : 	if (C.pItems) CoTaskMemFree(C.pItems);

	mov	esi, DWORD PTR _C$[esp+8]
	mov	eax, DWORD PTR [esi+68]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN12@PutData
	push	eax
	call	DWORD PTR __imp__CoTaskMemFree@4
$LN12@PutData:

; 38   : 	C.pItems = 0;
; 39   : 	C.CountOfItems = 0;
; 40   : 	if (!QueryDataCount) return 0;

	mov	ebp, DWORD PTR _QueryDataCount$[esp+8]
	cmp	ebp, ebx
	mov	DWORD PTR [esi+68], ebx
	mov	DWORD PTR [esi+64], ebx
	jne	SHORT $LN11@PutData
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 64   : 	};

	ret	0
$LN11@PutData:
	push	edi

; 41   : 	if (!(C.pItems = (char *)CoTaskMemAlloc(QueryDataCount * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN)))) return 0;

	mov	edi, ebp
	shl	edi, 7
	push	edi
	call	DWORD PTR __imp__CoTaskMemAlloc@4
	cmp	eax, ebx
	mov	DWORD PTR [esi+68], eax
	jne	SHORT $LN10@PutData
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 64   : 	};

	ret	0
$LN10@PutData:

; 42   : 	memset(C.pItems, 0, QueryDataCount * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN));

	push	edi
	push	ebx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 43   : 	for (C.CountOfItems = 0; C.CountOfItems < QueryDataCount; C.CountOfItems++)

	cmp	ebp, ebx
	mov	DWORD PTR [esi+64], ebx
	jle	$LN7@PutData
	mov	edi, DWORD PTR _pC$[esp+12]
	mov	ebx, DWORD PTR _pQDI$[esp+12]
	mov	ebp, DWORD PTR __imp__strncpy
	npad	6
$LL9@PutData:

; 44   : 	{
; 45   : 		switch (pQDI[C.CountOfItems].Format)

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, eax
	imul	ecx, 136				; 00000088H
	movsx	edx, BYTE PTR [ecx+ebx+64]
	add	ecx, ebx
	sub	edx, 1
	je	SHORT $LN4@PutData
	sub	edx, 1
	je	SHORT $LN3@PutData
	sub	edx, 1
	jne	$LN19@PutData

; 54   : 
; 55   : 			case ST_STRING:	strncpy(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 56   : 								((char *)pC + pQDI[C.CountOfItems].Position), SYSAL_MAXCONFIG_ENTRY_VALUE_LEN);

	mov	edx, DWORD PTR [ecx+68]
	mov	ecx, DWORD PTR [esi+68]
	add	edx, edi
	push	64					; 00000040H
	push	edx
	shl	eax, 7
	lea	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	ebp

; 57   : 							break;

	jmp	SHORT $LN20@PutData
$LN3@PutData:

; 49   : 							break;
; 50   : 
; 51   : 			case ST_FLOAT:	sprintf(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 52   : 								"%g", *(float *)((char *)pC + pQDI[C.CountOfItems].Position));

	mov	ecx, DWORD PTR [ecx+68]
	fld	DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [esi+68]
	sub	esp, 8
	shl	eax, 7
	fstp	QWORD PTR [esp]
	lea	eax, DWORD PTR [eax+edx+64]
	push	OFFSET ??_C@_02BEIEFPIG@?$CFg?$AA@
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 53   : 							break;

	jmp	SHORT $LN5@PutData
$LN4@PutData:

; 46   : 		{
; 47   : 			case ST_INT:	sprintf(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 48   : 								"%d", *(int *)((char *)pC + pQDI[C.CountOfItems].Position));

	mov	ecx, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR [esi+68]
	push	edx
	shl	eax, 7
	lea	edx, DWORD PTR [eax+ecx+64]
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	edx
	call	DWORD PTR __imp__sprintf
$LN20@PutData:
	add	esp, 12					; 0000000cH
$LN5@PutData:

; 58   : 
; 59   : 			default:		return C.CountOfItems;
; 60   : 			};
; 61   : 		strncpy(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN), pQDI[C.CountOfItems].Name, SYSAL_MAXCONFIG_ENTRY_NAME_LEN);

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, eax
	imul	ecx, 136				; 00000088H
	shl	eax, 7
	add	eax, DWORD PTR [esi+68]
	push	64					; 00000040H
	add	ecx, ebx
	push	ecx
	push	eax
	call	ebp
	mov	edx, DWORD PTR _QueryDataCount$[esp+24]
	add	DWORD PTR [esi+64], 1
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+64], edx
	jl	$LL9@PutData
$LN7@PutData:

; 62   : 		};	
; 63   : 	return C.CountOfItems;

	mov	eax, DWORD PTR [esi+64]
$LN19@PutData:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 64   : 	};

	ret	0
?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ENDP ; PutData
_TEXT	ENDS
PUBLIC	?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutDataPreserve
EXTRN	__imp__CoTaskMemRealloc@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z
_TEXT	SEGMENT
$T133058 = 8						; size = 4
_C$ = 8							; size = 4
_QueryDataCount$ = 12					; size = 4
_pQDI$ = 16						; size = 4
_pC$ = 20						; size = 4
?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z PROC ; PutDataPreserve, COMDAT

; 67   : {

	push	ebx
	push	ebp
	push	esi

; 68   : 	C.pItems = (char *)CoTaskMemRealloc(C.pItems, (QueryDataCount + C.CountOfItems) * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN));

	mov	esi, DWORD PTR _C$[esp+8]
	mov	eax, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+68]
	push	edi
	mov	edi, DWORD PTR _QueryDataCount$[esp+12]
	add	eax, edi
	shl	eax, 7
	push	eax
	push	ecx
	call	DWORD PTR __imp__CoTaskMemRealloc@8

; 69   : 	memset(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN), 0, QueryDataCount * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN));

	mov	ecx, DWORD PTR [esi+64]
	mov	edx, edi
	shl	edx, 7
	push	edx
	shl	ecx, 7
	add	ecx, eax
	push	0
	push	ecx
	mov	DWORD PTR [esi+68], eax
	call	_memset

; 70   : 	int OldCount = C.CountOfItems;

	mov	eax, DWORD PTR [esi+64]
	mov	ebx, eax

; 71   : 	for (; C.CountOfItems < (QueryDataCount + OldCount); C.CountOfItems++)

	add	edi, ebx
	add	esp, 12					; 0000000cH
	cmp	eax, edi
	mov	DWORD PTR $T133058[esp+12], edi
	jge	$LN7@PutDataPre
	mov	edi, DWORD PTR _pC$[esp+12]
	mov	ebp, DWORD PTR _pQDI$[esp+12]
$LL9@PutDataPre:

; 72   : 	{
; 73   : 		switch (pQDI[C.CountOfItems - OldCount].Format)

	mov	eax, DWORD PTR [esi+64]
	mov	edx, eax
	sub	edx, ebx
	imul	edx, 136				; 00000088H
	lea	ecx, DWORD PTR [edx+ebp]
	movsx	edx, BYTE PTR [ecx+64]
	sub	edx, 1
	je	SHORT $LN4@PutDataPre
	sub	edx, 1
	je	SHORT $LN3@PutDataPre
	sub	edx, 1
	jne	$LN10@PutDataPre

; 82   : 
; 83   : 			case ST_STRING:	strncpy(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 84   : 								((char *)pC + pQDI[C.CountOfItems - OldCount].Position), SYSAL_MAXCONFIG_ENTRY_VALUE_LEN);

	mov	ecx, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [esi+68]
	push	64					; 00000040H
	add	ecx, edi
	shl	eax, 7
	push	ecx
	lea	eax, DWORD PTR [eax+edx+64]
	push	eax
	call	DWORD PTR __imp__strncpy

; 85   : 							break;

	jmp	SHORT $LN16@PutDataPre
$LN3@PutDataPre:

; 77   : 							break;
; 78   : 
; 79   : 			case ST_FLOAT:	sprintf(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 80   : 								"%g", *(float *)((char *)pC + pQDI[C.CountOfItems - OldCount].Position));

	mov	ecx, DWORD PTR [ecx+68]
	fld	DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [esi+68]
	sub	esp, 8
	shl	eax, 7
	fstp	QWORD PTR [esp]
	lea	eax, DWORD PTR [eax+edx+64]
	push	OFFSET ??_C@_02BEIEFPIG@?$CFg?$AA@
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 81   : 							break;

	jmp	SHORT $LN5@PutDataPre
$LN4@PutDataPre:

; 74   : 		{
; 75   : 			case ST_INT:	sprintf(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 76   : 								"%d", *(int *)((char *)pC + pQDI[C.CountOfItems - OldCount].Position));

	mov	ecx, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR [esi+68]
	push	edx
	shl	eax, 7
	lea	edx, DWORD PTR [eax+ecx+64]
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	edx
	call	DWORD PTR __imp__sprintf
$LN16@PutDataPre:
	add	esp, 12					; 0000000cH
$LN5@PutDataPre:

; 86   : 
; 87   : 			default:		return C.CountOfItems;
; 88   : 			};
; 89   : 		strncpy(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN), pQDI[C.CountOfItems - OldCount].Name, SYSAL_MAXCONFIG_ENTRY_NAME_LEN);

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, eax
	sub	ecx, ebx
	imul	ecx, 136				; 00000088H
	shl	eax, 7
	add	eax, DWORD PTR [esi+68]
	push	64					; 00000040H
	add	ecx, ebp
	push	ecx
	push	eax
	call	DWORD PTR __imp__strncpy
	mov	edx, DWORD PTR $T133058[esp+24]
	add	DWORD PTR [esi+64], 1
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+64], edx
	jl	$LL9@PutDataPre
$LN7@PutDataPre:

; 90   : 		};	
; 91   : 	return C.CountOfItems;

	mov	eax, DWORD PTR [esi+64]
$LN10@PutDataPre:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 92   : 	};

	ret	0
?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ENDP ; PutDataPreserve
_TEXT	ENDS
PUBLIC	?_AfxInitManaged@@YAHXZ				; _AfxInitManaged
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\afx.inl
;	COMDAT ?_AfxInitManaged@@YAHXZ
_TEXT	SEGMENT
?_AfxInitManaged@@YAHXZ PROC				; _AfxInitManaged, COMDAT

; 77   : 	return 0;

	xor	eax, eax

; 78   : }

	ret	0
?_AfxInitManaged@@YAHXZ ENDP				; _AfxInitManaged
_TEXT	ENDS
PUBLIC	?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ	; AfxGetResourceHandle
EXTRN	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ:PROC ; AfxGetModuleState
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\afxwin1.inl
;	COMDAT ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ PROC	; AfxGetResourceHandle, COMDAT

; 25   : 		return afxCurrentResourceHandle; }

	call	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
	mov	eax, DWORD PTR [eax+12]
	ret	0
?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ ENDP	; AfxGetResourceHandle
_TEXT	ENDS
PUBLIC	??1AFX_MAINTAIN_STATE2@@QAE@XZ			; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2
EXTRN	?AfxDeactivateActCtx@@YGHKK@Z:PROC		; AfxDeactivateActCtx
; Function compile flags: /Ogtpy
;	COMDAT ??1AFX_MAINTAIN_STATE2@@QAE@XZ
_TEXT	SEGMENT
??1AFX_MAINTAIN_STATE2@@QAE@XZ PROC			; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2, COMDAT
; _this$ = ecx

; 52   : #ifdef _AFXDLL
; 53   : 	// Not a good place to report errors here, so just be safe
; 54   : 	if(m_pThreadState)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@AFX_MAINTA

; 55   : 	{
; 56   : 		m_pThreadState->m_pModuleState = m_pPrevModuleState;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
$LN2@AFX_MAINTA:

; 57   : 	}
; 58   : #endif
; 59   : 
; 60   : 	if (m_bValidActCtxCookie)

	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN1@AFX_MAINTA

; 61   : 	{
; 62   : 		BOOL bRet;
; 63   : 		bRet = AfxDeactivateActCtx(0, m_ulActCtxCookie);

	mov	eax, DWORD PTR [ecx+8]
	push	eax
	push	0
	call	?AfxDeactivateActCtx@@YGHKK@Z		; AfxDeactivateActCtx
$LN1@AFX_MAINTA:

; 64   : 		ASSERT(bRet == TRUE);
; 65   : 	}
; 66   : }

	ret	0
??1AFX_MAINTAIN_STATE2@@QAE@XZ ENDP			; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2
_TEXT	ENDS
PUBLIC	_fabsf
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv129 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 384  :         {return ((float)fabs((double)_X)); }

	fld	DWORD PTR __X$[esp-4]
	fabs
	fstp	DWORD PTR tv129[esp-4]
	fld	DWORD PTR tv129[esp-4]
	ret	0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	_floorf
EXTRN	_floor:PROC
; Function compile flags: /Ogtpy
;	COMDAT _floorf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 405  :         {return ((float)floor((double)_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	DWORD PTR tv69[esp+4]
	add	esp, 8
	fld	DWORD PTR tv69[esp-4]
	ret	0
_floorf	ENDP
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtpy
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	fld	DWORD PTR __X$[esp-4]
	call	__CIsqrt
	fstp	DWORD PTR tv69[esp-4]
	fld	DWORD PTR tv69[esp-4]
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?fabs@@YAMM@Z					; fabs
; Function compile flags: /Ogtpy
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv131 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 510  :         {return (fabsf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	fabs
	fstp	DWORD PTR tv131[esp-4]
	fld	DWORD PTR tv131[esp-4]
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
PUBLIC	?floor@@YAMM@Z					; floor
; Function compile flags: /Ogtpy
;	COMDAT ?floor@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?floor@@YAMM@Z PROC					; floor, COMDAT

; 512  :         {return (floorf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	DWORD PTR tv73[esp+4]
	add	esp, 8
	fld	DWORD PTR tv73[esp-4]
	ret	0
?floor@@YAMM@Z ENDP					; floor
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtpy
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	call	__CIsqrt
	fstp	DWORD PTR tv73[esp-4]
	fld	DWORD PTR tv73[esp-4]
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
PUBLIC	?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z ; CSmartTrackerClass::GetConfig
; Function compile flags: /Ogtpy
; File d:\sysal2\smarttracker8.5\smarttrackerclass.cpp
;	COMDAT ?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z
_TEXT	SEGMENT
_C$ = -800						; size = 800
_this$ = 8						; size = 4
_pConfig$ = 12						; size = 4
?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z PROC ; CSmartTrackerClass::GetConfig, COMDAT

; 317  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 800				; 00000320H

; 318  : 	// TODO: Add your implementation code here
; 319  : 	ConfigData C = T;

	mov	eax, DWORD PTR _this$[ebp]

; 320  : 	C.Processors = ConfigMaxProcessors_backup;
; 321  : 	if (::PutData(*pConfig, ConfigDataN, ConfigDataQDI, &C) != ConfigDataN) return S_FALSE;

	mov	edx, DWORD PTR _pConfig$[ebp]
	push	esi
	push	edi
	lea	esi, DWORD PTR [eax+136]
	mov	eax, DWORD PTR [eax+1128]
	mov	ecx, 200				; 000000c8H
	lea	edi, DWORD PTR _C$[esp+808]
	rep movsd
	lea	ecx, DWORD PTR _C$[esp+808]
	push	ecx
	push	OFFSET ?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	edx
	mov	DWORD PTR _C$[esp+1584], eax
	call	?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutData
	add	esp, 16					; 00000010H
	xor	ecx, ecx
	cmp	eax, 200				; 000000c8H
	setne	cl

; 322  : 	return S_OK;	
; 323  : }

	pop	edi
	pop	esi
	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z ENDP ; CSmartTrackerClass::GetConfig
_TEXT	ENDS
PUBLIC	?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z ; CSmartTrackerClass::EditConfig
EXTRN	??1CWnd@@UAE@XZ:PROC				; CWnd::~CWnd
EXTRN	?Detach@CWnd@@QAEPAUHWND__@@XZ:PROC		; CWnd::Detach
EXTRN	?DoModal@CDialog@@UAEHXZ:PROC			; CDialog::DoModal
EXTRN	??0CEditConfig@@QAE@PAVCSmartTrackerClass@@PAVCWnd@@@Z:PROC ; CEditConfig::CEditConfig
EXTRN	?Attach@CWnd@@QAEHPAUHWND__@@@Z:PROC		; CWnd::Attach
EXTRN	??0CWnd@@QAE@XZ:PROC				; CWnd::CWnd
EXTRN	??0AFX_MAINTAIN_STATE2@@QAE@PAVAFX_MODULE_STATE@@@Z:PROC ; AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2
EXTRN	?AfxGetStaticModuleState@@YGPAVAFX_MODULE_STATE@@XZ:PROC ; AfxGetStaticModuleState
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\afxwin1.inl
xdata$x	SEGMENT
__unwindtable$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z$2
__ehfuncinfo$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\sysal2\smarttracker8.5\smarttrackerclass.cpp
xdata$x	ENDS
;	COMDAT ?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z
_TEXT	SEGMENT
__ctlState$ = -1128					; size = 16
_Owner$ = -1112						; size = 84
_MyDlg$ = -1028						; size = 1016
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_pConfig$ = 12						; size = 4
_hWnd$ = 16						; size = 4
?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z PROC ; CSmartTrackerClass::EditConfig, COMDAT

; 326  : {

	push	-1
	push	__ehhandler$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1116				; 0000045cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+1136]
	mov	DWORD PTR fs:0, eax

; 327  : 	// TODO: Add your implementation code here
; 328  : 	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	call	?AfxGetStaticModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetStaticModuleState
	push	eax
	lea	ecx, DWORD PTR __ctlState$[esp+1140]
	call	??0AFX_MAINTAIN_STATE2@@QAE@PAVAFX_MODULE_STATE@@@Z ; AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2

; 329  : 	CWnd Owner;

	lea	ecx, DWORD PTR _Owner$[esp+1136]
	mov	DWORD PTR __$EHRec$[esp+1144], 0
	call	??0CWnd@@QAE@XZ				; CWnd::CWnd

; 330  : 	Owner.Attach((HWND)hWnd);

	mov	eax, DWORD PTR _hWnd$[esp+1132]
	push	eax
	lea	ecx, DWORD PTR _Owner$[esp+1140]
	mov	BYTE PTR __$EHRec$[esp+1148], 1
	call	?Attach@CWnd@@QAEHPAUHWND__@@@Z		; CWnd::Attach

; 331  : 	CEditConfig MyDlg(this, &Owner);

	mov	edx, DWORD PTR _this$[esp+1132]
	lea	ecx, DWORD PTR _Owner$[esp+1136]
	push	ecx
	add	edx, -4					; fffffffcH
	push	edx
	lea	ecx, DWORD PTR _MyDlg$[esp+1144]
	call	??0CEditConfig@@QAE@PAVCSmartTrackerClass@@PAVCWnd@@@Z ; CEditConfig::CEditConfig

; 332  : 
; 333  : 	GetData(*pConfig, ConfigDataN, ConfigDataQDI, &MyDlg.C, true);

	mov	esi, DWORD PTR _pConfig$[esp+1132]
	push	1
	lea	eax, DWORD PTR _MyDlg$[esp+1256]
	push	eax
	push	OFFSET ?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	esi
	mov	BYTE PTR __$EHRec$[esp+1164], 2
	call	?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ; GetData
	add	esp, 20					; 00000014H

; 334  : 
; 335  : 	if (MyDlg.DoModal() == IDOK)

	lea	ecx, DWORD PTR _MyDlg$[esp+1136]
	call	?DoModal@CDialog@@UAEHXZ		; CDialog::DoModal
	cmp	eax, 1
	jne	SHORT $LN1@EditConfig

; 336  : 	{
; 337  : 		::PutData(*pConfig, ConfigDataN, ConfigDataQDI, &MyDlg.C);

	lea	ecx, DWORD PTR _MyDlg$[esp+1252]
	push	ecx
	push	OFFSET ?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	esi
	call	?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutData
	add	esp, 16					; 00000010H

; 338  : 		Owner.Detach();

	lea	ecx, DWORD PTR _Owner$[esp+1136]
	call	?Detach@CWnd@@QAEPAUHWND__@@XZ		; CWnd::Detach

; 339  : 		return S_OK;

	lea	ecx, DWORD PTR _MyDlg$[esp+1136]
	mov	BYTE PTR __$EHRec$[esp+1144], 1
	call	??1CEditConfig@@UAE@XZ
	lea	ecx, DWORD PTR _Owner$[esp+1136]
	mov	BYTE PTR __$EHRec$[esp+1144], 0
	call	??1CWnd@@UAE@XZ				; CWnd::~CWnd
	mov	eax, DWORD PTR __ctlState$[esp+1140]
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+1144], -1
	je	SHORT $LN8@EditConfig
	mov	edx, DWORD PTR __ctlState$[esp+1136]
	mov	DWORD PTR [eax+4], edx
$LN8@EditConfig:
	cmp	DWORD PTR __ctlState$[esp+1148], 0
	je	SHORT $LN7@EditConfig
	mov	eax, DWORD PTR __ctlState$[esp+1144]
	push	eax
	push	0
	call	?AfxDeactivateActCtx@@YGHKK@Z		; AfxDeactivateActCtx
$LN7@EditConfig:
	xor	eax, eax
	jmp	SHORT $LN2@EditConfig
$LN1@EditConfig:

; 340  : 		};
; 341  : 	Owner.Detach();

	lea	ecx, DWORD PTR _Owner$[esp+1136]
	call	?Detach@CWnd@@QAEPAUHWND__@@XZ		; CWnd::Detach

; 342  : 	return S_FALSE;

	lea	ecx, DWORD PTR _MyDlg$[esp+1136]
	mov	BYTE PTR __$EHRec$[esp+1144], 1
	call	??1CEditConfig@@UAE@XZ
	lea	ecx, DWORD PTR _Owner$[esp+1136]
	mov	BYTE PTR __$EHRec$[esp+1144], 0
	call	??1CWnd@@UAE@XZ				; CWnd::~CWnd
	mov	eax, DWORD PTR __ctlState$[esp+1140]
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+1144], -1
	je	SHORT $LN12@EditConfig
	mov	ecx, DWORD PTR __ctlState$[esp+1136]
	mov	DWORD PTR [eax+4], ecx
$LN12@EditConfig:
	cmp	DWORD PTR __ctlState$[esp+1148], 0
	je	SHORT $LN11@EditConfig
	mov	edx, DWORD PTR __ctlState$[esp+1144]
	push	edx
	push	0
	call	?AfxDeactivateActCtx@@YGHKK@Z		; AfxDeactivateActCtx
$LN11@EditConfig:
	mov	eax, 1
$LN2@EditConfig:

; 343  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1136]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 1128				; 00000468H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z$0:
	lea	ecx, DWORD PTR __ctlState$[ebp]
	jmp	??1AFX_MAINTAIN_STATE2@@QAE@XZ		; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2
__unwindfunclet$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z$1:
	lea	ecx, DWORD PTR _Owner$[ebp]
	jmp	??1CWnd@@UAE@XZ				; CWnd::~CWnd
__unwindfunclet$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z$2:
	lea	ecx, DWORD PTR _MyDlg$[ebp]
	jmp	??1CEditConfig@@UAE@XZ
__ehhandler$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-1120]
	mov	ecx, DWORD PTR [edx-1124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z ENDP ; CSmartTrackerClass::EditConfig
PUBLIC	?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z		; CSmartTrackerClass::GetIcon
EXTRN	__imp__LoadImageA@24:PROC
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\afxwin1.inl
xdata$x	SEGMENT
__unwindtable$?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z$0
__ehfuncinfo$?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\sysal2\smarttracker8.5\smarttrackerclass.cpp
xdata$x	ENDS
;	COMDAT ?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z
_TEXT	SEGMENT
__ctlState$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_n$ = 12						; size = 4
_pHICON$ = 16						; size = 4
?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z PROC		; CSmartTrackerClass::GetIcon, COMDAT

; 375  : {

	push	-1
	push	__ehhandler$?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax

; 376  : 	// TODO: Add your implementation code here
; 377  : 	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	call	?AfxGetStaticModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetStaticModuleState
	push	eax
	lea	ecx, DWORD PTR __ctlState$[esp+36]
	call	??0AFX_MAINTAIN_STATE2@@QAE@PAVAFX_MODULE_STATE@@@Z ; AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2

; 378  : 
; 379  : 	HANDLE HTemp = 0;
; 380  : 	switch (n)

	mov	eax, DWORD PTR _n$[esp+28]
	sub	eax, 0
	mov	DWORD PTR __$EHRec$[esp+40], 0
	je	SHORT $LN3@GetIcon
	sub	eax, 1
	je	SHORT $LN2@GetIcon

; 387  : 
; 388  : 		default:	return E_INVALIDARG;

	mov	eax, DWORD PTR __ctlState$[esp+36]
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+40], -1
	je	SHORT $LN14@GetIcon
	mov	ecx, DWORD PTR __ctlState$[esp+32]
	mov	DWORD PTR [eax+4], ecx
$LN14@GetIcon:
	cmp	DWORD PTR __ctlState$[esp+44], 0
	je	SHORT $LN13@GetIcon
	mov	edx, DWORD PTR __ctlState$[esp+40]
	push	edx
	push	0
	call	?AfxDeactivateActCtx@@YGHKK@Z		; AfxDeactivateActCtx
$LN13@GetIcon:
	mov	eax, -2147024809			; 80070057H

; 392  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
$LN2@GetIcon:

; 383  : 					break;
; 384  : 
; 385  : 		case 1:		HTemp = LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(IDI_ICON64), IMAGE_ICON, 64, 64, LR_SHARED);

	call	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
	push	32768					; 00008000H
	push	64					; 00000040H
	push	64					; 00000040H
	push	1
	push	202					; 000000caH

; 386  : 					break;

	jmp	SHORT $LN22@GetIcon
$LN3@GetIcon:

; 381  : 	{
; 382  : 		case 0:		HTemp = LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(IDI_ICON32), IMAGE_ICON, 32, 32, LR_SHARED);

	call	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
	push	32768					; 00008000H
	push	32					; 00000020H
	push	32					; 00000020H
	push	1
	push	201					; 000000c9H
$LN22@GetIcon:
	mov	eax, DWORD PTR [eax+12]
	push	eax
	call	DWORD PTR __imp__LoadImageA@24

; 389  : 		};
; 390  : 	*pHICON = (HSySalHICON)HTemp;

	mov	ecx, DWORD PTR _pHICON$[esp+28]
	mov	DWORD PTR [ecx], eax

; 391  : 	return S_OK;	

	mov	eax, DWORD PTR __ctlState$[esp+36]
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+40], -1
	je	SHORT $LN18@GetIcon
	mov	edx, DWORD PTR __ctlState$[esp+32]
	mov	DWORD PTR [eax+4], edx
$LN18@GetIcon:
	cmp	DWORD PTR __ctlState$[esp+44], 0
	je	SHORT $LN17@GetIcon
	mov	eax, DWORD PTR __ctlState$[esp+40]
	push	eax
	push	0
	call	?AfxDeactivateActCtx@@YGHKK@Z		; AfxDeactivateActCtx
$LN17@GetIcon:
	xor	eax, eax

; 392  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z$0:
	lea	ecx, DWORD PTR __ctlState$[ebp]
	jmp	??1AFX_MAINTAIN_STATE2@@QAE@XZ		; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2
__ehhandler$?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z ENDP		; CSmartTrackerClass::GetIcon
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z ; CSmartTrackerClass::PutClusters
;	COMDAT ?run@?7??PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z@4HA
; File f:\program files\microsoft visual studio 8\vc\include\math.h
_BSS	SEGMENT
?run@?7??PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z@4HA DD 01H DUP (?) ; `CSmartTrackerClass::PutClusters'::`8'::run
_BSS	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtpy
; File d:\sysal2\smarttracker8.5\smarttrackerclass.cpp
CONST	ENDS
;	COMDAT ?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z
_TEXT	SEGMENT
tv4884 = -184						; size = 4
tv4858 = -184						; size = 4
tv4707 = -184						; size = 4
tv4619 = -184						; size = 4
tv4610 = -184						; size = 4
tv4605 = -184						; size = 4
tv4602 = -184						; size = 4
tv4600 = -184						; size = 4
tv4595 = -184						; size = 4
tv4592 = -184						; size = 4
tv4590 = -184						; size = 4
tv4572 = -184						; size = 4
tv4568 = -184						; size = 4
tv4560 = -184						; size = 4
tv4556 = -184						; size = 4
tv4540 = -184						; size = 4
tv4536 = -184						; size = 4
tv4527 = -184						; size = 4
tv4523 = -184						; size = 4
tv4507 = -184						; size = 4
tv4503 = -184						; size = 4
tv4495 = -184						; size = 4
tv4491 = -184						; size = 4
tv4475 = -184						; size = 4
tv4471 = -184						; size = 4
tv4463 = -184						; size = 4
tv4459 = -184						; size = 4
tv4438 = -184						; size = 4
tv4434 = -184						; size = 4
tv4426 = -184						; size = 4
tv4422 = -184						; size = 4
tv4327 = -184						; size = 4
tv4323 = -184						; size = 4
tv3209 = -184						; size = 4
_pcy$ = -184						; size = 4
_pcx$ = -184						; size = 4
_V$130920 = -184					; size = 8
tv4679 = -176						; size = 4
tv4669 = -176						; size = 4
tv4224 = -176						; size = 4
tv4222 = -176						; size = 4
tv4128 = -176						; size = 4
tv3219 = -176						; size = 4
tv3172 = -176						; size = 4
_DY$ = -176						; size = 4
_CX$ = -176						; size = 4
tv2302 = -172						; size = 4
_PGrainEnd$ = -172					; size = 4
_Nc$ = -172						; size = 4
_CurrDispY$ = -172					; size = 4
_MaxHisto$ = -168					; size = 4
_CurrDispX$ = -168					; size = 4
_CurrentGCounter$ = -168				; size = 4
tv3154 = -164						; size = 4
tv2289 = -164						; size = 4
_rv$130909 = -164					; size = 4
_W$130921 = -160					; size = 8
_ReplicaRadius$ = -160					; size = 4
tv3902 = -152						; size = 4
tv2317 = -152						; size = 4
_MaxBin$ = -152						; size = 4
_DividerCount$ = -152					; size = 4
tv4133 = -148						; size = 4
tv2300 = -148						; size = 4
tv2263 = -148						; size = 4
_DeltaBins$ = -148					; size = 4
_rsp$130908 = -144					; size = 4
_DX$ = -144						; size = 4
_CY$ = -144						; size = 4
tv4138 = -140						; size = 4
tv1784 = -140						; size = 4
tv1309 = -140						; size = 4
_PixMin$ = -140						; size = 4
_SumPy$130915 = -136					; size = 8
_Icell$ = -136						; size = 4
_PixelToMicronX$ = -136					; size = 4
_ReplicaCount$ = -124					; size = 4
_SumYPy$130918 = -120					; size = 8
_ReplicaDivider$ = -120					; size = 4
tv3197 = -112						; size = 4
tv2292 = -112						; size = 4
_CellsInLayer$ = -108					; size = 4
tv5365 = -104						; size = 4
tv4159 = -104						; size = 4
tv3205 = -104						; size = 4
tv2314 = -104						; size = 4
tv3201 = -100						; size = 4
tv2527 = -100						; size = 4
tv2326 = -100						; size = 4
tv2259 = -100						; size = 4
_pDY$ = -96						; size = 4
_pX$ = -92						; size = 4
_Layer$ = -88						; size = 4
_pY$ = -84						; size = 4
_CellSpace$ = -80					; size = 4
_pDX$ = -76						; size = 4
tv2540 = -72						; size = 8
_L1X$ = -72						; size = 8
_SumY2$130917 = -64					; size = 8
_AvgLY$ = -64						; size = 8
_pReplicas$ = -56					; size = 4
_MaxGrains$ = -52					; size = 4
_L0X$ = -48						; size = 8
_CellOverflow$ = -36					; size = 4
_PixMax$ = -32						; size = 4
_PixelToMicronY$ = -28					; size = 4
_AvgLX$ = -24						; size = 8
_L1Y$ = -16						; size = 8
_L0Y$ = -8						; size = 8
_this$ = 8						; size = 4
_pClusters$ = 12					; size = 4
_CountOfClusters$ = 16					; size = 4
_Z$ = 20						; size = 4
?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z PROC ; CSmartTrackerClass::PutClusters, COMDAT

; 551  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi

; 552  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 553  : 
; 554  : 	// TODO: Add your implementation code here
; 555  : 	int Nc;
; 556  : 	int Icell;
; 557  : 	IntCluster *PClus;
; 558  : 	Cell *PCell;
; 559  : 	IntGrain *PGrain, *PGrainEnd;
; 560  : 	int PixMin = T.PixMin;

	mov	esi, DWORD PTR _this$[ebp]

; 561  : 	int PixMax = T.PixMax;
; 562  : 	float PixelToMicronX = T.PixelToMicronX;

	fld	DWORD PTR [esi+1004]
	mov	eax, DWORD PTR [esi+160]
	mov	ecx, DWORD PTR [esi+164]
	fstp	DWORD PTR _PixelToMicronX$[esp+252]

; 563  : 	float PixelToMicronY = T.PixelToMicronY;

	fld	DWORD PTR [esi+1008]
	push	edi

; 564  : 	float PixelToMicronXY = fabs(PixelToMicronX * PixelToMicronY);
; 565  : 	float PixelToMicronX3Y = PixelToMicronXY * PixelToMicronX * PixelToMicronX;
; 566  : 	float PixelToMicronY3X = PixelToMicronXY * PixelToMicronY * PixelToMicronY;
; 567  : 	float PixelToMicronX2Y2 = PixelToMicronXY * PixelToMicronXY;
; 568  : 	int CellsInLayer = T.CellsInLayer;
; 569  : 	Cell *CellSpace = T.CellSpace;
; 570  : 	int Layer = T.Layer;
; 571  : 	int CellOverflow = T.CellOverflow;

	mov	edi, DWORD PTR [esi+148]
	fstp	DWORD PTR _PixelToMicronY$[esp+256]

; 572  : 	int CurrentGCounter = T.NumGrains;
; 573  : 	int MaxGrains = T.MaxGrains;
; 574  : 	float CurrDispX = 0.0f;
; 575  : 	float CurrDispY = 0.0f;
; 576  : 	float CurrDispSigmaX = 0.0f;
; 577  : 	float CurrDispSigmaY = 0.0f;
; 578  : 	float DispX = T.DispX;
; 579  : 	float DispY = T.DispY;
; 580  : 	float CX, CY, DX, DY;
; 581  : 	double L0X = 0.0, L1X = 0.0, L0Y = 0.0, L1Y = 0.0;

	fldz
	mov	edx, DWORD PTR [esi+1016]

; 582  : 	double AvgLX = 0.0, AvgLY = 0.0;
; 583  : 	float *pX = T.pX;
; 584  : 	float *pY = T.pY;
; 585  : 	float *pDX = T.pDX;
; 586  : 	float *pDY = T.pDY;
; 587  : 	IntCluster **pReplicas = T.pReplicas;
; 588  : 	int ReplicaCount = 0;
; 589  : 	int ReplicaDivider = T.ReplicaSampleDivider;

	mov	ebx, DWORD PTR [esi+912]
	fst	QWORD PTR _L0X$[esp+256]
	mov	DWORD PTR _CellOverflow$[esp+256], edi
	fst	QWORD PTR _L1X$[esp+256]
	mov	edi, DWORD PTR [esi+1012]
	fst	QWORD PTR _L0Y$[esp+256]
	mov	DWORD PTR _CurrentGCounter$[esp+256], edi
	fst	QWORD PTR _L1Y$[esp+256]
	mov	edi, DWORD PTR [esi+140]
	fld	ST(0)
	mov	DWORD PTR _MaxGrains$[esp+256], edi
	fst	QWORD PTR _AvgLX$[esp+256]
	mov	edi, DWORD PTR [esi+1072]
	fld	ST(1)
	mov	DWORD PTR _pX$[esp+256], edi
	fst	QWORD PTR _AvgLY$[esp+256]
	mov	edi, DWORD PTR [esi+1076]

; 590  : 	int DividerCount;
; 591  : 	float ReplicaRadius = T.ReplicaRadius;

	fld	DWORD PTR [esi+908]
	mov	DWORD PTR _pY$[esp+256], edi
	fstp	DWORD PTR _ReplicaRadius$[esp+256]
	mov	edi, DWORD PTR [esi+1080]
	mov	DWORD PTR _pDX$[esp+256], edi
	mov	edi, DWORD PTR [esi+1084]
	mov	DWORD PTR _pDY$[esp+256], edi
	mov	edi, DWORD PTR [esi+1088]
	mov	DWORD PTR _PixMin$[esp+256], eax
	mov	eax, DWORD PTR [esi+972]
	mov	DWORD PTR _PixMax$[esp+256], ecx
	mov	ecx, DWORD PTR [esi+976]
	mov	DWORD PTR _pReplicas$[esp+256], edi
	xor	edi, edi

; 592  : 
; 593  : 	if (!OkToRun) return S_FALSE;

	cmp	BYTE PTR [esi+1112], 0
	mov	DWORD PTR _CellsInLayer$[esp+256], ecx
	mov	DWORD PTR _CellSpace$[esp+256], eax
	mov	DWORD PTR _Layer$[esp+256], edx
	mov	DWORD PTR _ReplicaCount$[esp+256], edi
	mov	DWORD PTR _ReplicaDivider$[esp+256], ebx
	jne	SHORT $LN68@PutCluster
$LN305@PutCluster:
	fstp	ST(2)
	mov	eax, 1
	fstp	ST(0)
	fstp	ST(0)

; 899  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN68@PutCluster:

; 594  : 
; 595  : 	if (Layer >= T.LayerNum) return S_FALSE;

	cmp	edx, DWORD PTR [esi+144]
	jge	SHORT $LN305@PutCluster

; 596  : 	T.ZLayer[Layer] = Z;
; 597  : 	for (Icell = 0; Icell < CellsInLayer; Icell++)

	cmp	ecx, edi
	fld	DWORD PTR _Z$[ebp]
	mov	ebx, DWORD PTR [esi+964]
	fstp	DWORD PTR [ebx+edx*4]
	jle	SHORT $LN64@PutCluster
	mov	ebx, edx
	imul	ebx, ecx
	lea	eax, DWORD PTR [eax+ebx*8]
$LN66@PutCluster:

; 598  : 	{	((Cell *)CellSpace)[Layer*CellsInLayer+Icell].FirstC = 0;

	mov	DWORD PTR [eax], edi

; 599  : 		((Cell *)CellSpace)[Layer*CellsInLayer+Icell].Free = 0;

	mov	DWORD PTR [eax+4], edi
	add	eax, 8
	sub	ecx, 1
	jne	SHORT $LN66@PutCluster
$LN64@PutCluster:

; 600  : 		};
; 601  : 
; 602  : 	static int run = 0;
; 603  : 	run++;
; 604  : 
; 605  : 	int DeltaBins = T.DeltaBinsX * T.DeltaBinsY;

	mov	ecx, DWORD PTR [esi+1056]
	imul	ecx, DWORD PTR [esi+1060]
	add	DWORD PTR ?run@?7??PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z@4HA, 1

; 606  : 	int MaxHisto, MaxBin;
; 607  : 	for (Nc = 0; Nc < DeltaBins; T.pDeltaHisto2d[Nc++] = 0);

	xor	eax, eax
	cmp	ecx, edi
	mov	DWORD PTR _DeltaBins$[esp+256], ecx
	jle	SHORT $LN61@PutCluster
$LN63@PutCluster:
	mov	ebx, DWORD PTR [esi+1064]
	mov	DWORD PTR [ebx+eax*4], edi
	add	eax, 1
	cmp	eax, ecx
	jl	SHORT $LN63@PutCluster
$LN61@PutCluster:

; 608  : 
; 609  : /*	FILE *fsmtg = fopen("c:\\acq\\smt8g.txt", "a+t");
; 610  : 	FILE *fsmtd = fopen("c:\\acq\\smt8d.txt", "a+t");
; 611  : */
; 612  : 
; 613  : 	if (T.ReplicaRadius > 0.0f && Layer > 0)

	fldz
	fcomp	DWORD PTR [esi+908]
	fnstsw	ax
	test	ah, 5
	jp	$LN158@PutCluster
	cmp	edx, edi
	jle	$LN158@PutCluster

; 614  : 	{
; 615  : 		for (Nc = DividerCount = 0; (Nc < CountOfClusters) && (CurrentGCounter < MaxGrains); Nc++)

	cmp	DWORD PTR _CountOfClusters$[ebp], edi
	mov	DWORD PTR _DividerCount$[esp+256], edi
	mov	DWORD PTR _Nc$[esp+256], edi
	jle	$LN57@PutCluster
	mov	edi, DWORD PTR _pY$[esp+256]
	mov	eax, DWORD PTR _pX$[esp+256]
	mov	edx, DWORD PTR _pClusters$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv3197[esp+256], eax
	mov	eax, DWORD PTR _pDX$[esp+256]
	sub	eax, edi
	mov	DWORD PTR tv3201[esp+256], eax
	mov	eax, DWORD PTR _pDY$[esp+256]
	sub	eax, edi
	mov	DWORD PTR tv3205[esp+256], eax
	mov	eax, DWORD PTR _pReplicas$[esp+256]
	add	edx, 4
	sub	eax, edi
	mov	DWORD PTR tv3154[esp+256], edx
	mov	DWORD PTR tv3209[esp+256], eax
$LN59@PutCluster:
	mov	eax, DWORD PTR _MaxGrains$[esp+256]
	cmp	DWORD PTR _CurrentGCounter$[esp+256], eax
	jge	$LN57@PutCluster

; 616  : 		{	
; 617  : 			PClus = (IntCluster *)(pClusters + Nc);

	mov	eax, DWORD PTR tv3154[esp+256]
	fstp	ST(1)
	lea	ebx, DWORD PTR [eax-4]
	fstp	ST(0)

; 618  : 			if ((PClus->Area >= PixMin) && (PClus->Area <= PixMax))

	mov	eax, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR _PixMin$[esp+256]
	jl	$LN58@PutCluster
	cmp	eax, DWORD PTR _PixMax$[esp+256]
	jg	$LN58@PutCluster

; 619  : 			{	
; 620  : 				Icell = GetCell(PClus->X *= PixelToMicronX, PClus->Y *= PixelToMicronY);

	mov	eax, DWORD PTR tv3154[esp+256]
	fstp	ST(0)
	fld	DWORD PTR [eax]
	sub	esp, 8
	fmul	DWORD PTR _PixelToMicronY$[esp+264]
	mov	ecx, esi
	fstp	DWORD PTR tv3172[esp+264]
	fld	DWORD PTR tv3172[esp+264]
	fst	DWORD PTR [eax]
	fld	DWORD PTR [ebx]
	fmul	DWORD PTR _PixelToMicronX$[esp+264]
	fstp	DWORD PTR tv3219[esp+264]
	fld	DWORD PTR tv3219[esp+264]
	fst	DWORD PTR [ebx]
	fxch	ST(1)
	fstp	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	call	?GetCell@CSmartTrackerClass@@IAEHMM@Z	; CSmartTrackerClass::GetCell

; 621  : 				if (Icell >= 0)

	test	eax, eax
	jl	$LN124@PutCluster

; 622  : 				{	
; 623  : 					PCell = (Cell *)(CellSpace+(Layer*CellsInLayer+Icell));

	mov	ecx, DWORD PTR _Layer$[esp+256]
	imul	ecx, DWORD PTR _CellsInLayer$[esp+256]
	mov	edx, DWORD PTR _CellSpace$[esp+256]
	add	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*8]

; 624  : 					PCell->Free++;
; 625  : 					CurrentGCounter++;
; 626  : 					PClus->NextFree = PCell->FirstC;

	mov	edx, DWORD PTR tv3154[esp+256]
	mov	ecx, 1
	add	DWORD PTR [eax+4], ecx
	add	DWORD PTR _CurrentGCounter$[esp+256], ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 627  : 					PCell->FirstC = PClus;
; 628  : 					if (++DividerCount == ReplicaDivider)

	mov	ecx, DWORD PTR _DividerCount$[esp+256]
	add	ecx, 1
	cmp	ecx, DWORD PTR _ReplicaDivider$[esp+256]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR _DividerCount$[esp+256], ecx
	jne	$LN124@PutCluster

; 629  : 					{
; 630  : 						DividerCount = 0;
; 631  : 						PCell -= CellsInLayer;

	mov	ecx, DWORD PTR _CellsInLayer$[esp+256]

; 632  : 						CX = PClus->X/* + DispX*/;

	fld	DWORD PTR [ebx]
	neg	ecx
	fstp	DWORD PTR _CX$[esp+256]

; 633  : 						CY = PClus->Y/* + DispY*/;

	fld	DWORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*8]

; 634  : 						IntGrain *pRep = PCell->FirstG;

	mov	ecx, DWORD PTR [eax]
	fstp	DWORD PTR _CY$[esp+256]

; 635  : 						IntGrain *pEnd = pRep + PCell->Free;

	mov	eax, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [eax+eax*8]
	lea	edx, DWORD PTR [ecx+eax*4]

; 636  : 						while (pRep < pEnd)

	cmp	ecx, edx
	mov	DWORD PTR _DividerCount$[esp+256], 0
	jae	$LN124@PutCluster
	fld	DWORD PTR _CX$[esp+256]
	fld	DWORD PTR _CY$[esp+256]
	fld	DWORD PTR _ReplicaRadius$[esp+256]
$LN53@PutCluster:

; 637  : 						{
; 638  : 							if (fabs(DX = (pRep->Xcm - CX)) < ReplicaRadius && fabs(DY = (pRep->Ycm - CY)) < ReplicaRadius) 

	fld	DWORD PTR [ecx]
	fsub	ST(0), ST(3)
	fstp	DWORD PTR _DX$[esp+256]
	fld	DWORD PTR _DX$[esp+256]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv4679[esp+256]
	fld	DWORD PTR tv4679[esp+256]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN295@PutCluster
	fld	DWORD PTR [ecx+4]
	fsub	ST(0), ST(3)
	fstp	DWORD PTR _DY$[esp+256]
	fld	DWORD PTR _DY$[esp+256]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv4669[esp+256]
	fld	DWORD PTR tv4669[esp+256]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN298@PutCluster
	fstp	ST(1)
$LN295@PutCluster:

; 657  : 								break;
; 658  : 								}
; 659  : 							pRep++;

	add	ecx, 36					; 00000024H
	fstp	ST(0)
	cmp	ecx, edx
	jb	SHORT $LN53@PutCluster
	fstp	ST(0)
	fstp	ST(1)
	fstp	ST(0)
	jmp	$LN124@PutCluster
$LN298@PutCluster:

; 639  : 							{
; 640  : 								*(IntGrain **)(void *)&PClus->Inertia.IYY = pRep;
; 641  : 								pX[ReplicaCount] = CX;
; 642  : 								pY[ReplicaCount] = CY;
; 643  : 								pDX[ReplicaCount] = DX;

	mov	edx, DWORD PTR tv3201[esp+256]
	fstp	ST(2)

; 644  : 								pDY[ReplicaCount] = DY;

	mov	eax, DWORD PTR tv3205[esp+256]
	fxch	ST(3)
	mov	DWORD PTR [ebx+28], ecx
	mov	ecx, DWORD PTR tv3197[esp+256]
	fstp	DWORD PTR [ecx+edi]

; 645  : 								pReplicas[ReplicaCount] = PClus;

	mov	ecx, DWORD PTR tv3209[esp+256]
	fxch	ST(1)
	mov	DWORD PTR [ecx+edi], ebx
	fstp	DWORD PTR [edi]

; 646  : 
; 647  : 								CurrDispX += DX;
; 648  : 								CurrDispSigmaX += DX * DX;
; 649  : 								CurrDispY += DY;
; 650  : 								CurrDispSigmaY += DY * DY;
; 651  : 
; 652  : 								T.pDeltaHisto2d[((int)floor(DY / T.DeltaDY + 0.5) + T.DeltaBinsY / 2) * T.DeltaBinsX + ((int)floor(DX / T.DeltaDX + 0.5) + T.DeltaBinsX / 2)]++;

	sub	esp, 8
	fxch	ST(1)
	fstp	DWORD PTR [edx+edi]
	fst	DWORD PTR [eax+edi]
	mov	ebx, DWORD PTR [esi+1056]
	fdiv	DWORD PTR [esi+1052]
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	_floor
	call	__ftol2_sse
	fld	DWORD PTR _DX$[esp+264]
	fdiv	DWORD PTR [esi+1048]
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+1060]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ecx, eax
	fadd	QWORD PTR __real@3fe0000000000000
	imul	ecx, ebx
	fstp	QWORD PTR [esp]
	mov	DWORD PTR tv4222[esp+264], ecx
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR tv4222[esp+256]

; 653  : /*
; 654  : 								fprintf(fsmtg, "%d %d %d %f %f %f %f\n", run, Layer, ReplicaCount, PClus->X, PClus->Y, DX, DY);
; 655  : */								
; 656  : 								ReplicaCount++;								

	add	DWORD PTR _ReplicaCount$[esp+256], 1
	add	ecx, eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR [esi+1064]
	sar	eax, 1
	add	ecx, eax
	add	DWORD PTR [edx+ecx*4], 1
	lea	eax, DWORD PTR [edx+ecx*4]
	add	edi, 4
$LN124@PutCluster:

; 637  : 						{
; 638  : 							if (fabs(DX = (pRep->Xcm - CX)) < ReplicaRadius && fabs(DY = (pRep->Ycm - CY)) < ReplicaRadius) 

	fldz
$LN58@PutCluster:

; 614  : 	{
; 615  : 		for (Nc = DividerCount = 0; (Nc < CountOfClusters) && (CurrentGCounter < MaxGrains); Nc++)

	mov	eax, DWORD PTR _Nc$[esp+256]
	fld	QWORD PTR _AvgLX$[esp+256]
	add	DWORD PTR tv3154[esp+256], 40		; 00000028H
	fld	QWORD PTR _AvgLY$[esp+256]
	add	eax, 1
	cmp	eax, DWORD PTR _CountOfClusters$[ebp]
	mov	DWORD PTR _Nc$[esp+256], eax
	jl	$LN59@PutCluster
$LN57@PutCluster:

; 660  : 							}
; 661  : 						}
; 662  : 					};
; 663  : 				};
; 664  : 			};
; 665  : 		MaxBin = DeltaBins / 2 + T.DeltaBinsX / 2;
; 666  : 		for (Nc = MaxHisto = MaxBin = 0; Nc < DeltaBins; Nc++)

	xor	eax, eax
	xor	edx, edx
	cmp	DWORD PTR _DeltaBins$[esp+256], eax
	mov	DWORD PTR _MaxHisto$[esp+256], eax
	jle	$LN175@PutCluster
	mov	edi, DWORD PTR [esi+1064]
	mov	ebx, DWORD PTR _DeltaBins$[esp+256]
$LN50@PutCluster:

; 667  : 			if (T.pDeltaHisto2d[Nc] > MaxHisto)

	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR _MaxHisto$[esp+256]
	jle	SHORT $LN49@PutCluster

; 668  : 			{
; 669  : 				MaxHisto = T.pDeltaHisto2d[Nc];

	mov	DWORD PTR _MaxHisto$[esp+256], ecx

; 670  : 				MaxBin = Nc;

	mov	edx, eax
$LN49@PutCluster:
	add	eax, 1
	add	edi, 4
	cmp	eax, ebx
	jl	SHORT $LN50@PutCluster

; 671  : 				};
; 672  : 
; 673  : 		if (MaxHisto)

	cmp	DWORD PTR _MaxHisto$[esp+256], 0
	mov	DWORD PTR _MaxBin$[esp+256], edx
	je	$LN175@PutCluster

; 674  : 			if ((MaxHisto = T.pDeltaHisto2d[MaxBin] + T.pDeltaHisto2d[MaxBin + 1] + T.pDeltaHisto2d[MaxBin - 1] + 
; 675  : 				T.pDeltaHisto2d[MaxBin + T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin + 1 + T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin - 1 + T.DeltaBinsX] + 
; 676  : 				T.pDeltaHisto2d[MaxBin - T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin + 1 - T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin - 1 - T.DeltaBinsX]) >= T.MinReplicas)

	mov	edi, DWORD PTR [esi+1056]
	mov	eax, DWORD PTR [esi+1064]
	mov	ebx, edx
	sub	ebx, edi
	lea	ecx, DWORD PTR [edx+edi]
	lea	edi, DWORD PTR [eax+ebx*4]
	lea	ebx, DWORD PTR [eax+edx*4-4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR tv2263[esp+256], eax
	mov	eax, DWORD PTR [edi-4]
	add	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR tv2259[esp+256], ebx
	add	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2263[esp+256]
	add	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [esi+1064]
	add	eax, DWORD PTR [edi+4]
	add	eax, DWORD PTR [edi]
	add	eax, DWORD PTR [ebx+edx*4]
	add	eax, DWORD PTR [ecx-4]
	add	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+916]
	mov	DWORD PTR _MaxHisto$[esp+256], eax
	jl	$LN175@PutCluster

; 677  : 		{
; 678  : 			DX = ((MaxBin % T.DeltaBinsX) - T.DeltaBinsX / 2) * T.DeltaDX;

	mov	eax, edx
	fstp	ST(1)
	cdq
	fstp	ST(0)
	idiv	DWORD PTR [esi+1056]
	mov	DWORD PTR tv5365[esp+256], eax
	mov	eax, DWORD PTR [esi+1056]
	mov	ebx, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ebx, eax

; 679  : 			DY = ((MaxBin / T.DeltaBinsX) - T.DeltaBinsY / 2) * T.DeltaDY;

	mov	eax, DWORD PTR [esi+1060]
	cdq
	sub	eax, edx
	mov	edx, eax
	mov	eax, DWORD PTR tv5365[esp+256]
	sar	edx, 1
	sub	eax, edx

; 680  : 			CurrDispX = (DX * (T.pDeltaHisto2d[MaxBin] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX]) + 
; 681  : 				(DX + T.DeltaDX) * (T.pDeltaHisto2d[MaxBin + 1] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX + 1] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX + 1]) + 
; 682  : 				(DX - T.DeltaDX) * (T.pDeltaHisto2d[MaxBin - 1] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX - 1] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX - 1])) / MaxHisto;

	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR tv4619[esp+256], ebx
	mov	ebx, DWORD PTR _MaxBin$[esp+256]
	mov	DWORD PTR tv2289[esp+256], edx
	fild	DWORD PTR tv4619[esp+256]
	mov	edx, DWORD PTR tv2263[esp+256]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR tv2292[esp+256], edx
	fmul	DWORD PTR [esi+1048]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv2300[esp+256], edx
	mov	edx, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi-4]
	fstp	DWORD PTR _DX$[esp+256]
	mov	DWORD PTR tv2314[esp+256], edi
	mov	edi, DWORD PTR tv2259[esp+256]
	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR tv4610[esp+256], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx-4]
	fild	DWORD PTR tv4610[esp+256]
	mov	DWORD PTR tv2302[esp+256], edx
	mov	edx, DWORD PTR [esi+1064]
	mov	edx, DWORD PTR [edx+ebx*4]
	fmul	DWORD PTR [esi+1052]
	mov	ebx, DWORD PTR tv2292[esp+256]
	mov	DWORD PTR tv2317[esp+256], edi
	mov	edi, DWORD PTR tv2289[esp+256]
	fstp	DWORD PTR _DY$[esp+256]
	add	ebx, edi
	fild	DWORD PTR _MaxHisto$[esp+256]
	mov	edi, DWORD PTR tv2302[esp+256]
	add	ebx, eax
	mov	DWORD PTR tv4605[esp+256], ebx
	mov	ebx, DWORD PTR tv2317[esp+256]
	fstp	DWORD PTR tv2326[esp+256]
	add	edi, edx
	fild	DWORD PTR tv4605[esp+256]
	add	edi, DWORD PTR tv2300[esp+256]
	fld	DWORD PTR [esi+1048]
	fld	DWORD PTR _DX$[esp+256]
	fld	ST(0)
	faddp	ST(2), ST(0)
	mov	DWORD PTR tv4602[esp+256], edi
	mov	edi, DWORD PTR tv2314[esp+256]
	fxch	ST(2)
	add	ebx, edi
	fmulp	ST(1), ST(0)
	add	ebx, ecx
	fild	DWORD PTR tv4602[esp+256]
	mov	DWORD PTR tv4600[esp+256], ebx
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fild	DWORD PTR tv4600[esp+256]
	fld	DWORD PTR [esi+1048]
	fsubp	ST(3), ST(0)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	DWORD PTR tv2326[esp+256]
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)

; 683  : 
; 684  : 			CurrDispY = (DY * (T.pDeltaHisto2d[MaxBin] + T.pDeltaHisto2d[MaxBin + 1] + T.pDeltaHisto2d[MaxBin - 1]) + 
; 685  : 				(DY + T.DeltaDY) * (T.pDeltaHisto2d[MaxBin + T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX + 1] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX - 1]) + 
; 686  : 				(DY - T.DeltaDY) * (T.pDeltaHisto2d[MaxBin - T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX + 1] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX - 1])) / MaxHisto;

	mov	ebx, DWORD PTR tv2300[esp+256]
	fstp	DWORD PTR _CurrDispX$[esp+256]
	add	ecx, ebx
	add	ecx, eax
	mov	eax, DWORD PTR tv2317[esp+256]
	mov	DWORD PTR tv4595[esp+256], ecx
	fild	DWORD PTR tv4595[esp+256]
	mov	ecx, DWORD PTR tv2302[esp+256]
	fld	DWORD PTR [esi+1052]
	add	eax, edx
	fld	DWORD PTR _DY$[esp+256]
	add	eax, DWORD PTR tv2292[esp+256]
	fld	ST(0)
	add	edi, ecx
	add	edi, DWORD PTR tv2289[esp+256]
	faddp	ST(2), ST(0)
	fxch	ST(2)
	mov	DWORD PTR tv4592[esp+256], eax

; 687  : 
; 688  : 			int rsp, rv;
; 689  : 			double SumPx = 0.0, SumX = 0.0, SumX2 = 0.0, SumXPx = 0.0, DenX = 0.0;
; 690  : 			double SumPy = 0.0, SumY = 0.0, SumY2 = 0.0, SumYPy = 0.0, DenY = 0.0;
; 691  : 			double V, W;
; 692  : 			for (rsp = rv = 0; rsp < ReplicaCount; rsp++)

	xor	ebx, ebx
	fmulp	ST(1), ST(0)
	mov	DWORD PTR _rsp$130908[esp+256], ebx
	fild	DWORD PTR tv4592[esp+256]
	mov	DWORD PTR tv4590[esp+256], edi
	xor	edi, edi
	cmp	DWORD PTR _ReplicaCount$[esp+256], 4
	fmul	ST(0), ST(2)
	mov	DWORD PTR _rv$130909[esp+256], edi
	faddp	ST(1), ST(0)
	fild	DWORD PTR tv4590[esp+256]
	fld	DWORD PTR [esi+1052]
	fsubp	ST(3), ST(0)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _CurrDispY$[esp+256]
	fld	ST(0)
	fld	ST(1)
	fld	ST(2)
	fld	ST(3)
	fxch	ST(4)
	fst	QWORD PTR _SumPy$130915[esp+256]
	fld	ST(0)
	fld	ST(1)
	fxch	ST(2)
	fstp	QWORD PTR _SumYPy$130918[esp+256]
	jl	$LC117@PutCluster
	mov	edi, DWORD PTR _pDX$[esp+256]
	mov	eax, DWORD PTR _pY$[esp+256]
	mov	ebx, DWORD PTR _pX$[esp+256]
	mov	edx, DWORD PTR _ReplicaCount$[esp+256]
	sub	ebx, edi
	mov	DWORD PTR tv4128[esp+256], ebx
	mov	ebx, eax
	sub	ebx, edi
	mov	DWORD PTR tv4133[esp+256], ebx
	mov	ebx, DWORD PTR _pDY$[esp+256]
	sub	ebx, edi
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv3902[esp+256], ecx
	lea	ecx, DWORD PTR [edi+4]
	add	edx, -3					; fffffffdH
	mov	edi, eax
	sub	edi, DWORD PTR _pDY$[esp+256]
	mov	DWORD PTR tv2527[esp+256], edx
	mov	edx, DWORD PTR _pDY$[esp+256]
	mov	DWORD PTR tv4159[esp+256], edi
	mov	edi, DWORD PTR _pX$[esp+256]
	add	edx, 8
	sub	edi, eax
	mov	DWORD PTR tv4138[esp+256], ebx
	mov	ebx, DWORD PTR _rsp$130908[esp+256]
	mov	DWORD PTR tv3197[esp+256], edi
	mov	edi, DWORD PTR _rv$130909[esp+256]
$LN122@PutCluster:

; 693  : 			{
; 694  : 				if (fabs(pDX[rsp] - CurrDispX) < T.DeltaDX && fabs(pDY[rsp] - CurrDispY) < T.DeltaDY)

	fld	DWORD PTR [ecx-4]
	fsub	DWORD PTR _CurrDispX$[esp+256]
	fstp	DWORD PTR tv4572[esp+256]
	fld	DWORD PTR tv4572[esp+256]
	fabs
	fstp	DWORD PTR tv4568[esp+256]
	fld	DWORD PTR tv4568[esp+256]
	fld	DWORD PTR [esi+1048]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN118@PutCluster
	fld	DWORD PTR [edx-8]
	fsub	DWORD PTR _CurrDispY$[esp+256]
	fstp	DWORD PTR tv4560[esp+256]
	fld	DWORD PTR tv4560[esp+256]
	fabs
	fstp	DWORD PTR tv4556[esp+256]
	fld	DWORD PTR tv4556[esp+256]
	fld	DWORD PTR [esi+1052]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN118@PutCluster

; 697  : 					V = pX[rsp];

	mov	eax, DWORD PTR _pX$[esp+256]
	fld	DWORD PTR [eax+ebx*4]

; 698  : 					W = pDX[rsp];
; 699  : 					SumX += V;
; 700  : 					SumX2 += V * V;
; 701  : 					SumPx += W;
; 702  : 					SumXPx += V * W;
; 703  : 					V = pY[rsp];

	mov	eax, DWORD PTR tv3902[esp+256]
	fld	DWORD PTR [ecx-4]
	add	edi, 1
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(5), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(4), ST(0)
	fld	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fmul	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fld	DWORD PTR [eax-12]
	fst	QWORD PTR _V$130920[esp+256]

; 704  : 					W = pDY[rsp];

	fld	DWORD PTR [edx-8]
	fstp	QWORD PTR _W$130921[esp+256]

; 705  : 					SumY += V;

	fld	ST(0)
	faddp	ST(2), ST(0)

; 706  : 					SumY2 += V * V;

	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)

; 707  : 					SumPy += W;

	fld	QWORD PTR _W$130921[esp+256]
	fadd	QWORD PTR _SumPy$130915[esp+256]
	fstp	QWORD PTR _SumPy$130915[esp+256]

; 708  : 					SumYPy += V * W;

	fld	QWORD PTR _W$130921[esp+256]
	fmul	QWORD PTR _V$130920[esp+256]
	fadd	QWORD PTR _SumYPy$130918[esp+256]
	fstp	QWORD PTR _SumYPy$130918[esp+256]
$LN118@PutCluster:
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _CurrDispX$[esp+256]
	fstp	DWORD PTR tv4540[esp+256]
	fld	DWORD PTR tv4540[esp+256]
	fabs
	fstp	DWORD PTR tv4536[esp+256]
	fld	DWORD PTR tv4536[esp+256]
	fld	DWORD PTR [esi+1048]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN119@PutCluster
	mov	eax, DWORD PTR tv4138[esp+256]
	fld	DWORD PTR [ecx+eax]
	fsub	DWORD PTR _CurrDispY$[esp+256]
	fstp	DWORD PTR tv4527[esp+256]
	fld	DWORD PTR tv4527[esp+256]
	fabs
	fstp	DWORD PTR tv4523[esp+256]
	fld	DWORD PTR tv4523[esp+256]
	fld	DWORD PTR [esi+1052]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN119@PutCluster
	mov	eax, DWORD PTR tv4128[esp+256]
	fld	DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR tv4133[esp+256]
	fld	DWORD PTR [ecx]
	add	edi, 1
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(5), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(4), ST(0)
	fld	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fmul	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fld	DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR tv4138[esp+256]
	fst	QWORD PTR _V$130920[esp+256]
	fld	DWORD PTR [ecx+eax]
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	fld	QWORD PTR _W$130921[esp+256]
	fadd	QWORD PTR _SumPy$130915[esp+256]
	fstp	QWORD PTR _SumPy$130915[esp+256]
	fld	QWORD PTR _W$130921[esp+256]
	fmul	QWORD PTR _V$130920[esp+256]
	fadd	QWORD PTR _SumYPy$130918[esp+256]
	fstp	QWORD PTR _SumYPy$130918[esp+256]
$LN119@PutCluster:
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _CurrDispX$[esp+256]
	fstp	DWORD PTR tv4507[esp+256]
	fld	DWORD PTR tv4507[esp+256]
	fabs
	fstp	DWORD PTR tv4503[esp+256]
	fld	DWORD PTR tv4503[esp+256]
	fld	DWORD PTR [esi+1048]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN120@PutCluster
	fld	DWORD PTR [edx]
	fsub	DWORD PTR _CurrDispY$[esp+256]
	fstp	DWORD PTR tv4495[esp+256]
	fld	DWORD PTR tv4495[esp+256]
	fabs
	fstp	DWORD PTR tv4491[esp+256]
	fld	DWORD PTR tv4491[esp+256]
	fld	DWORD PTR [esi+1052]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN120@PutCluster
	mov	eax, DWORD PTR tv4159[esp+256]
	mov	ebx, DWORD PTR tv3197[esp+256]
	add	edi, 1
	add	eax, edx
	fld	DWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR _rsp$130908[esp+256]
	fld	DWORD PTR [ecx+4]
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(5), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(4), ST(0)
	fld	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fmul	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fld	DWORD PTR [eax]
	fst	QWORD PTR _V$130920[esp+256]
	fld	DWORD PTR [edx]
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	fld	QWORD PTR _W$130921[esp+256]
	fadd	QWORD PTR _SumPy$130915[esp+256]
	fstp	QWORD PTR _SumPy$130915[esp+256]
	fld	QWORD PTR _W$130921[esp+256]
	fmul	QWORD PTR _V$130920[esp+256]
	fadd	QWORD PTR _SumYPy$130918[esp+256]
	fstp	QWORD PTR _SumYPy$130918[esp+256]
$LN120@PutCluster:
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR _CurrDispX$[esp+256]
	fstp	DWORD PTR tv4475[esp+256]
	fld	DWORD PTR tv4475[esp+256]
	fabs
	fstp	DWORD PTR tv4471[esp+256]
	fld	DWORD PTR tv4471[esp+256]
	fld	DWORD PTR [esi+1048]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN121@PutCluster
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR _CurrDispY$[esp+256]
	fstp	DWORD PTR tv4463[esp+256]
	fld	DWORD PTR tv4463[esp+256]
	fabs
	fstp	DWORD PTR tv4459[esp+256]
	fld	DWORD PTR tv4459[esp+256]
	fld	DWORD PTR [esi+1052]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN121@PutCluster
	mov	eax, DWORD PTR tv3902[esp+256]
	mov	ebx, DWORD PTR tv3197[esp+256]
	fld	DWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR _rsp$130908[esp+256]
	fld	DWORD PTR [ecx+8]
	add	edi, 1
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(5), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(4), ST(0)
	fld	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fmul	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fld	DWORD PTR [eax]
	fst	QWORD PTR _V$130920[esp+256]
	fld	DWORD PTR [edx+4]
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	fld	QWORD PTR _W$130921[esp+256]
	fadd	QWORD PTR _SumPy$130915[esp+256]
	fstp	QWORD PTR _SumPy$130915[esp+256]
	fld	QWORD PTR _W$130921[esp+256]
	fmul	QWORD PTR _V$130920[esp+256]
	fadd	QWORD PTR _SumYPy$130918[esp+256]
	fstp	QWORD PTR _SumYPy$130918[esp+256]
$LN121@PutCluster:
	add	DWORD PTR tv3902[esp+256], 16		; 00000010H
	add	ebx, 4
	add	ecx, 16					; 00000010H
	add	edx, 16					; 00000010H
	cmp	ebx, DWORD PTR tv2527[esp+256]
	mov	DWORD PTR _rsp$130908[esp+256], ebx
	jl	$LN122@PutCluster

; 695  : 				{
; 696  : 					rv++;

	mov	DWORD PTR _rv$130909[esp+256], edi
$LC117@PutCluster:

; 687  : 
; 688  : 			int rsp, rv;
; 689  : 			double SumPx = 0.0, SumX = 0.0, SumX2 = 0.0, SumXPx = 0.0, DenX = 0.0;
; 690  : 			double SumPy = 0.0, SumY = 0.0, SumY2 = 0.0, SumYPy = 0.0, DenY = 0.0;
; 691  : 			double V, W;
; 692  : 			for (rsp = rv = 0; rsp < ReplicaCount; rsp++)

	cmp	ebx, DWORD PTR _ReplicaCount$[esp+256]
	jge	$LN116@PutCluster
	mov	eax, DWORD PTR _pDX$[esp+256]
	mov	edx, DWORD PTR _pX$[esp+256]
	sub	edx, eax
	mov	DWORD PTR tv4128[esp+256], edx
	mov	edx, DWORD PTR _pY$[esp+256]
	sub	edx, eax
	mov	DWORD PTR tv4133[esp+256], edx
	mov	edx, DWORD PTR _pDY$[esp+256]
	lea	ecx, DWORD PTR [eax+ebx*4]
	sub	edx, eax
	mov	eax, DWORD PTR _ReplicaCount$[esp+256]
	sub	eax, ebx
	mov	ebx, DWORD PTR tv4128[esp+256]
	mov	DWORD PTR tv1784[esp+256], eax
$LC44@PutCluster:

; 693  : 			{
; 694  : 				if (fabs(pDX[rsp] - CurrDispX) < T.DeltaDX && fabs(pDY[rsp] - CurrDispY) < T.DeltaDY)

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _CurrDispX$[esp+256]
	fstp	DWORD PTR tv4438[esp+256]
	fld	DWORD PTR tv4438[esp+256]
	fabs
	fstp	DWORD PTR tv4434[esp+256]
	fld	DWORD PTR tv4434[esp+256]
	fld	DWORD PTR [esi+1048]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN43@PutCluster
	fld	DWORD PTR [ecx+edx]
	fsub	DWORD PTR _CurrDispY$[esp+256]
	fstp	DWORD PTR tv4426[esp+256]
	fld	DWORD PTR tv4426[esp+256]
	fabs
	fstp	DWORD PTR tv4422[esp+256]
	fld	DWORD PTR tv4422[esp+256]
	fld	DWORD PTR [esi+1052]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN43@PutCluster

; 697  : 					V = pX[rsp];

	fld	DWORD PTR [ecx+ebx]

; 698  : 					W = pDX[rsp];
; 699  : 					SumX += V;
; 700  : 					SumX2 += V * V;
; 701  : 					SumPx += W;
; 702  : 					SumXPx += V * W;
; 703  : 					V = pY[rsp];

	mov	eax, DWORD PTR tv4133[esp+256]
	fld	DWORD PTR [ecx]
	add	edi, 1
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(5), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(4), ST(0)
	fld	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fmul	QWORD PTR _W$130921[esp+256]
	faddp	ST(6), ST(0)
	fld	DWORD PTR [ecx+eax]
	fst	QWORD PTR _V$130920[esp+256]

; 704  : 					W = pDY[rsp];

	fld	DWORD PTR [ecx+edx]
	fstp	QWORD PTR _W$130921[esp+256]

; 705  : 					SumY += V;

	fld	ST(0)
	faddp	ST(2), ST(0)

; 706  : 					SumY2 += V * V;

	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)

; 707  : 					SumPy += W;

	fld	QWORD PTR _W$130921[esp+256]
	fadd	QWORD PTR _SumPy$130915[esp+256]
	fstp	QWORD PTR _SumPy$130915[esp+256]

; 708  : 					SumYPy += V * W;

	fld	QWORD PTR _W$130921[esp+256]
	fmul	QWORD PTR _V$130920[esp+256]
	fadd	QWORD PTR _SumYPy$130918[esp+256]
	fstp	QWORD PTR _SumYPy$130918[esp+256]
$LN43@PutCluster:
	add	ecx, 4
	sub	DWORD PTR tv1784[esp+256], 1
	jne	$LC44@PutCluster

; 695  : 				{
; 696  : 					rv++;

	mov	DWORD PTR _rv$130909[esp+256], edi
$LN116@PutCluster:

; 709  : 					}
; 710  : 				}
; 711  : 			DenX = 1. / (rv * SumX2 - SumX * SumX);
; 712  : 			L0X = (SumPx * SumX2 - SumX * SumXPx) * DenX;
; 713  : 			L1X = (rv * SumXPx - SumX * SumPx) * DenX;
; 714  : 			DenY = 1. / (rv * SumY2 - SumY * SumY);
; 715  : 			L0Y = (SumPy * SumY2 - SumY * SumYPy) * DenY;
; 716  : 			L1Y = (rv * SumYPy - SumY * SumPy) * DenY;
; 717  : 
; 718  : 			SumPx = 0.0; SumX = 0.0; SumX2 = 0.0; SumXPx = 0.0; DenX = 0.0;
; 719  : 			SumPy = 0.0; SumY = 0.0; SumY2 = 0.0; SumYPy = 0.0; DenY = 0.0;
; 720  : 			for (rsp = rv = 0; rsp < ReplicaCount; rsp++)

	cmp	DWORD PTR _ReplicaCount$[esp+256], 0
	fild	DWORD PTR _rv$130909[esp+256]
	mov	DWORD PTR _rv$130909[esp+256], 0
	fst	QWORD PTR tv2540[esp+256]
	fmul	ST(0), ST(3)
	fld	ST(4)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fld1
	fdivrp	ST(1), ST(0)
	fxch	ST(3)
	fmul	ST(0), ST(5)
	fld	ST(6)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR _L0X$[esp+256]
	fld	QWORD PTR tv2540[esp+256]
	fld	ST(0)
	fmulp	ST(7), ST(0)
	fxch	ST(4)
	fmulp	ST(5), ST(0)
	fxch	ST(5)
	fsubrp	ST(4), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _L1X$[esp+256]
	fld	ST(0)
	fmul	ST(0), ST(2)
	fld	ST(3)
	fmul	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fld1
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	fld	QWORD PTR _SumPy$130915[esp+256]
	fmul	ST(4), ST(0)
	fld	QWORD PTR _SumYPy$130918[esp+256]
	fld	ST(0)
	fmul	ST(0), ST(7)
	fsubp	ST(6), ST(0)
	fxch	ST(5)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR _L0Y$[esp+256]
	fxch	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(4)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fsubrp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _L1Y$[esp+256]
	fldz
	fld	ST(0)
	fld	ST(1)
	fld	ST(2)
	fld	ST(3)
	fxch	ST(4)
	fst	QWORD PTR _SumPy$130915[esp+256]
	fld	ST(0)
	fxch	ST(1)
	fst	QWORD PTR _SumY2$130917[esp+256]
	fstp	QWORD PTR _SumYPy$130918[esp+256]
	jle	$LN38@PutCluster
	mov	ecx, DWORD PTR _pDX$[esp+256]
	fstp	ST(5)

; 721  : 			{
; 722  : 				if (fabs(pDX[rsp] - (pX[rsp] * L1X + L0X)) < T.DeltaDX && fabs(pDY[rsp] - (pY[rsp] * L1Y + L0Y)) < T.DeltaDY)
; 723  : 				{
; 724  : 					rv++;
; 725  : 					V = pX[rsp];
; 726  : 					W = pDX[rsp];
; 727  : 					SumX += V;
; 728  : 					SumX2 += V * V;
; 729  : 					SumPx += W;
; 730  : 					SumXPx += V * W;
; 731  : 					V = pY[rsp];
; 732  : 					W = pDY[rsp];
; 733  : 					SumY += V;
; 734  : 					SumY2 += V * V;
; 735  : 					SumPy += W;
; 736  : 					SumYPy += V * W;
; 737  : 					}
; 738  : 				else pReplicas[rsp] = 0;

	mov	ebx, DWORD PTR _pX$[esp+256]
	mov	edx, DWORD PTR _pY$[esp+256]
	mov	edi, DWORD PTR _pDY$[esp+256]
	mov	eax, DWORD PTR _pReplicas$[esp+256]
	sub	ebx, ecx
	sub	edx, ecx
	sub	edi, ecx
	sub	eax, ecx
	mov	DWORD PTR tv4707[esp+256], eax
	mov	eax, DWORD PTR _ReplicaCount$[esp+256]
	mov	DWORD PTR tv1309[esp+256], eax
$LN40@PutCluster:
	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+ebx]
	fmul	QWORD PTR _L1X$[esp+256]
	fadd	QWORD PTR _L0X$[esp+256]
	fsubp	ST(1), ST(0)
	fabs
	fld	DWORD PTR [esi+1048]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN37@PutCluster
	fld	DWORD PTR [ecx+edi]
	fld	DWORD PTR [ecx+edx]
	fmul	QWORD PTR _L1Y$[esp+256]
	fadd	QWORD PTR _L0Y$[esp+256]
	fsubp	ST(1), ST(0)
	fabs
	fld	DWORD PTR [esi+1052]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN37@PutCluster
	fld	DWORD PTR [ecx+ebx]
	add	DWORD PTR _rv$130909[esp+256], 1
	fld	DWORD PTR [ecx]
	fld	ST(1)
	faddp	ST(4), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(3), ST(0)
	fld	ST(0)
	faddp	ST(5), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(4), ST(0)
	fld	DWORD PTR [ecx+edx]
	fld	DWORD PTR [ecx+edi]
	fstp	QWORD PTR _W$130921[esp+256]
	fld	ST(0)
	faddp	ST(6), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _SumY2$130917[esp+256]
	fstp	QWORD PTR _SumY2$130917[esp+256]
	fld	QWORD PTR _W$130921[esp+256]
	fadd	QWORD PTR _SumPy$130915[esp+256]
	fstp	QWORD PTR _SumPy$130915[esp+256]
	fmul	QWORD PTR _W$130921[esp+256]
	fadd	QWORD PTR _SumYPy$130918[esp+256]
	fstp	QWORD PTR _SumYPy$130918[esp+256]
	jmp	SHORT $LN39@PutCluster
$LN37@PutCluster:
	mov	eax, DWORD PTR tv4707[esp+256]
	mov	DWORD PTR [eax+ecx], 0
$LN39@PutCluster:
	add	ecx, 4
	sub	DWORD PTR tv1309[esp+256], 1
	jne	$LN40@PutCluster
	fld1
	fxch	ST(5)
$LN38@PutCluster:

; 739  : 				}
; 740  : 			DenX = 1. / (rv * SumX2 - SumX * SumX);

	fild	DWORD PTR _rv$130909[esp+256]

; 741  : 			L0X = (SumPx * SumX2 - SumX * SumXPx) * DenX;
; 742  : 			L1X = (rv * SumXPx - SumX * SumPx) * DenX;
; 743  : 			DenY = 1. / (rv * SumY2 - SumY * SumY);
; 744  : 			L0Y = (SumPy * SumY2 - SumY * SumYPy) * DenY;
; 745  : 			L1Y = (rv * SumYPy - SumY * SumPy) * DenY;
; 746  : 			AvgLX = L0X + L1X * T.ViewCenterX;
; 747  : 			AvgLY = L0Y + L1Y * T.ViewCenterY;
; 748  : 			L1X += 1.0;
; 749  : 			L1Y += 1.0;
; 750  : 			T.TotalLX += AvgLX;
; 751  : 			T.TotalLY += AvgLY;
; 752  : 			for (rsp = 0; rsp < ReplicaCount; rsp++)

	mov	edi, DWORD PTR _ReplicaCount$[esp+256]
	xor	eax, eax
	test	edi, edi
	fst	QWORD PTR tv2540[esp+256]
	fmul	ST(0), ST(2)
	fld	ST(3)
	fmul	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fdivr	ST(0), ST(6)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fld	ST(5)
	fmul	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR _L0X$[esp+256]
	fld	QWORD PTR tv2540[esp+256]
	fld	ST(0)
	fmulp	ST(6), ST(0)
	fxch	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(4)
	fsubrp	ST(3), ST(0)
	fmulp	ST(2), ST(0)
	fld	ST(0)
	fld	QWORD PTR _SumY2$130917[esp+256]
	fmul	ST(1), ST(0)
	fld	ST(4)
	fmul	ST(0), ST(5)
	fsubp	ST(2), ST(0)
	fld	ST(5)
	fdivrp	ST(2), ST(0)
	fld	QWORD PTR _SumPy$130915[esp+256]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _SumYPy$130918[esp+256]
	fmul	ST(0), ST(6)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fst	QWORD PTR _L0Y$[esp+256]
	fxch	ST(3)
	fmul	QWORD PTR _SumYPy$130918[esp+256]
	fxch	ST(5)
	fmulp	ST(1), ST(0)
	fsubp	ST(4), ST(0)
	fmulp	ST(3), ST(0)
	fld	DWORD PTR [esi+1092]
	fmul	ST(0), ST(2)
	fadd	QWORD PTR _L0X$[esp+256]
	fld	DWORD PTR [esi+1096]
	fmul	ST(0), ST(4)
	faddp	ST(2), ST(0)
	fxch	ST(2)
	fadd	ST(0), ST(4)
	fstp	QWORD PTR _L1X$[esp+256]
	fxch	ST(2)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _L1Y$[esp+256]
	fld	DWORD PTR [esi+1104]
	fadd	ST(0), ST(2)
	fstp	DWORD PTR [esi+1104]
	fld	DWORD PTR [esi+1108]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR [esi+1108]
	jle	SHORT $LN33@PutCluster
	mov	edx, DWORD PTR _pReplicas$[esp+256]
$LN35@PutCluster:

; 753  : 				if (pReplicas[rsp]) 

	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN34@PutCluster

; 754  : 					pReplicas[rsp]->Area = -pReplicas[rsp]->Area;

	mov	ecx, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR [ecx+8]
	neg	ebx
	mov	DWORD PTR [ecx+8], ebx
$LN34@PutCluster:
	add	eax, 1
	cmp	eax, edi
	jl	SHORT $LN35@PutCluster
$LN33@PutCluster:

; 755  : /*
; 756  : 			T.DispX = (DispX += CurrDispX);
; 757  : 			T.DispY = (DispY += CurrDispY);
; 758  : */
; 759  : /*
; 760  : 			fprintf(fsmtd, "%d %d %f %f %d %d %f %f %f %f\n", run, Layer, CurrDispX, CurrDispY, MaxHisto, MaxBin, DX, DY, T.DeltaDX, T.DeltaDY);
; 761  : */				
; 762  : /*
; 763  : 			fprintf(fsmtd, "%d %d %f %f %f %d %d %f %f %f %f\n", run, Layer, Z - T.ZLayer[Layer - 1], CurrDispX, CurrDispY, MaxHisto, MaxBin, L0X, L1X, L0Y, L1Y);
; 764  : */				
; 765  : 
; 766  : 			CurrDispSigmaX = T.DeltaDX * 0.5f;
; 767  : 			CurrDispSigmaY = T.DeltaDY * 0.5f;
; 768  : 			T.ShadowSigmaMeasures++;
; 769  : 			T.ShadowSigmaXAccumulator += CurrDispSigmaX;

	fld	DWORD PTR [esi+1048]
	add	DWORD PTR [esi+1044], 1
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv4327[esp+256]
	fld	DWORD PTR tv4327[esp+256]
	fadd	DWORD PTR [esi+1028]
	fstp	DWORD PTR [esi+1028]

; 770  : 			T.ShadowSigmaYAccumulator += CurrDispSigmaY;

	fmul	DWORD PTR [esi+1052]
	fstp	DWORD PTR tv4323[esp+256]
	fld	DWORD PTR tv4323[esp+256]
	fadd	DWORD PTR [esi+1032]
	fstp	DWORD PTR [esi+1032]
$LN302@PutCluster:

; 771  : 			}
; 772  : 		}
; 773  : 	else
; 774  : 	{
; 775  : 		for (Nc = 0; (Nc < CountOfClusters) && (CurrentGCounter < MaxGrains); Nc++)

	fxch	ST(1)
$LN28@PutCluster:

; 788  : 					};
; 789  : 				};
; 790  : 			};
; 791  : 		};
; 792  : 
; 793  : /*	fclose(fsmtg);
; 794  : 	fclose(fsmtd);
; 795  : */
; 796  : 	T.LayerGrains[Layer] = PGrain = T.GrainSpace + T.NumGrains;

	mov	eax, DWORD PTR [esi+1012]

; 797  : 	PGrainEnd = T.GrainSpace + MaxGrains;
; 798  : 	IntCluster *NextFree;
; 799  : 
; 800  : 	float pcx, pcy;
; 801  : 	IntGrain *pig;
; 802  : 	if (T.ReplicaRadius > 0.0f && Layer > 0)

	fldz
	mov	ebx, DWORD PTR _Layer$[esp+256]
	lea	edx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [esi+960]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [esi+968]
	mov	eax, DWORD PTR _MaxGrains$[esp+256]
	mov	DWORD PTR [edx+ebx*4], ecx
	fcomp	DWORD PTR [esi+908]
	mov	edx, DWORD PTR [esi+960]
	lea	eax, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _PGrainEnd$[esp+256], eax
	fnstsw	ax
	xor	edx, edx
	test	ah, 5
	jp	$LN260@PutCluster
	cmp	ebx, edx
	jle	$LN260@PutCluster

; 803  : 	{
; 804  : 		for (Icell = 0; (Icell < CellsInLayer) && (PGrain < PGrainEnd); Icell ++)

	mov	edi, DWORD PTR _CellsInLayer$[esp+256]
	xor	eax, eax
	cmp	edi, edx
	mov	DWORD PTR _Icell$[esp+256], eax
	jle	$LN263@PutCluster
	fld	QWORD PTR _L0Y$[esp+256]
	fld	QWORD PTR _L0X$[esp+256]
	fld	QWORD PTR _L1Y$[esp+256]
	jmp	$LN24@PutCluster
$LN158@PutCluster:

; 771  : 			}
; 772  : 		}
; 773  : 	else
; 774  : 	{
; 775  : 		for (Nc = 0; (Nc < CountOfClusters) && (CurrentGCounter < MaxGrains); Nc++)

	cmp	DWORD PTR _CountOfClusters$[ebp], edi
	fstp	ST(2)
	mov	DWORD PTR _Nc$[esp+256], edi
	jle	$LN28@PutCluster
	mov	edi, DWORD PTR _pClusters$[ebp]
	add	edi, 4
	jmp	SHORT $LN30@PutCluster
	npad	10
$LL130@PutCluster:
	fld	QWORD PTR _AvgLY$[esp+256]
	fld	QWORD PTR _AvgLX$[esp+256]
$LN30@PutCluster:
	mov	ecx, DWORD PTR _MaxGrains$[esp+256]
	cmp	DWORD PTR _CurrentGCounter$[esp+256], ecx
	jge	$LN28@PutCluster

; 776  : 		{	
; 777  : 			PClus = (IntCluster *)(pClusters + Nc);
; 778  : 			if ((PClus->Area >= PixMin) && (PClus->Area <= PixMax))

	mov	eax, DWORD PTR [edi+4]
	fstp	ST(0)
	cmp	eax, DWORD PTR _PixMin$[esp+256]
	fstp	ST(0)
	jl	SHORT $LN29@PutCluster
	cmp	eax, DWORD PTR _PixMax$[esp+256]
	jg	SHORT $LN29@PutCluster

; 779  : 			{	
; 780  : 				Icell = GetCell(PClus->X *= PixelToMicronX, PClus->Y *= PixelToMicronY);

	fld	DWORD PTR [edi]
	lea	ebx, DWORD PTR [edi-4]
	fmul	DWORD PTR _PixelToMicronY$[esp+256]
	sub	esp, 8
	mov	ecx, esi
	fstp	DWORD PTR tv4858[esp+264]
	fld	DWORD PTR tv4858[esp+264]
	fst	DWORD PTR [edi]
	fld	DWORD PTR _PixelToMicronX$[esp+264]
	fmul	DWORD PTR [ebx]
	fstp	DWORD PTR tv4884[esp+264]
	fld	DWORD PTR tv4884[esp+264]
	fst	DWORD PTR [ebx]
	fxch	ST(1)
	fstp	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	call	?GetCell@CSmartTrackerClass@@IAEHMM@Z	; CSmartTrackerClass::GetCell

; 781  : 				if (Icell >= 0)

	test	eax, eax
	jl	SHORT $LN29@PutCluster

; 782  : 				{	
; 783  : 					PCell = (Cell *)(CellSpace+(Layer*CellsInLayer+Icell));

	mov	edx, DWORD PTR _Layer$[esp+256]
	imul	edx, DWORD PTR _CellsInLayer$[esp+256]
	add	edx, eax
	mov	eax, DWORD PTR _CellSpace$[esp+256]
	lea	eax, DWORD PTR [eax+edx*8]

; 784  : 					PCell->Free++;

	mov	ecx, 1
	add	DWORD PTR [eax+4], ecx

; 785  : 					CurrentGCounter++;

	add	DWORD PTR _CurrentGCounter$[esp+256], ecx

; 786  : 					PClus->NextFree = PCell->FirstC;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi+8], ecx

; 787  : 					PCell->FirstC = PClus;

	mov	DWORD PTR [eax], ebx
$LN29@PutCluster:
	mov	eax, DWORD PTR _Nc$[esp+256]
	add	eax, 1
	add	edi, 40					; 00000028H
	cmp	eax, DWORD PTR _CountOfClusters$[ebp]
	mov	DWORD PTR _Nc$[esp+256], eax
	jl	$LL130@PutCluster
	fld	QWORD PTR _AvgLX$[esp+256]
	fld	QWORD PTR _AvgLY$[esp+256]
	jmp	$LN302@PutCluster
$LN175@PutCluster:

; 771  : 			}
; 772  : 		}
; 773  : 	else
; 774  : 	{
; 775  : 		for (Nc = 0; (Nc < CountOfClusters) && (CurrentGCounter < MaxGrains); Nc++)

	fstp	ST(2)

; 660  : 							}
; 661  : 						}
; 662  : 					};
; 663  : 				};
; 664  : 			};
; 665  : 		MaxBin = DeltaBins / 2 + T.DeltaBinsX / 2;
; 666  : 		for (Nc = MaxHisto = MaxBin = 0; Nc < DeltaBins; Nc++)

	jmp	$LN28@PutCluster
$LN140@PutCluster:

; 803  : 	{
; 804  : 		for (Icell = 0; (Icell < CellsInLayer) && (PGrain < PGrainEnd); Icell ++)

	mov	ebx, DWORD PTR _Layer$[esp+256]
$LN24@PutCluster:
	cmp	ecx, DWORD PTR _PGrainEnd$[esp+256]
	jae	$LN267@PutCluster

; 805  : 		{	
; 806  : 			PCell = (Cell *)(CellSpace+(Layer*CellsInLayer+Icell));

	imul	ebx, edi
	add	ebx, eax
	mov	eax, DWORD PTR _CellSpace$[esp+256]
	lea	ebx, DWORD PTR [eax+ebx*8]

; 807  : 			if (PCell->Free)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, edx
	je	$LN13@PutCluster

; 808  : 			{	
; 809  : 				if (PCell->Free < CellOverflow)

	cmp	eax, DWORD PTR _CellOverflow$[esp+256]
	jge	$LN20@PutCluster

; 810  : 				{	
; 811  : 					PClus = PCell->FirstC;

	mov	eax, DWORD PTR [ebx]

; 812  : 					PCell->FirstG = PGrain;

	mov	DWORD PTR [ebx], ecx
$LN19@PutCluster:

; 813  : 					do
; 814  : 					{	
; 815  : //						PGrain->Xcm = PClus->X + DispX;
; 816  : //						PGrain->Ycm = PClus->Y + DispY;
; 817  : 						NextFree = PClus->NextFree;
; 818  : 						if (PClus->Area < 0)

	cmp	DWORD PTR [eax+8], edx
	mov	edi, DWORD PTR [eax+12]
	jge	SHORT $LN16@PutCluster

; 819  : 						{							
; 820  : 							PGrain->Xcm = (pcx = PClus->X) * L1X + L0X;

	fld	DWORD PTR [eax]
	fstp	DWORD PTR _pcx$[esp+256]
	fld	DWORD PTR _pcx$[esp+256]
	fld	QWORD PTR _L1X$[esp+256]
	fmul	ST(0), ST(1)
	fadd	ST(0), ST(3)
	fstp	DWORD PTR [ecx]

; 821  : 							PGrain->Ycm = (pcy = PClus->Y) * L1Y + L0Y;

	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR _pcy$[esp+256]
	fld	DWORD PTR _pcy$[esp+256]
	fld	ST(0)
	fmul	ST(0), ST(3)
	fadd	ST(0), ST(5)
	fstp	DWORD PTR [ecx+4]

; 822  : 							pig = *((IntGrain **)(void *)(&PClus->Inertia.IYY));

	mov	edx, DWORD PTR [eax+28]

; 823  : 							PGrain->Area = -PClus->Area;

	mov	eax, DWORD PTR [eax+8]

; 824  : 							PGrain->Xunc = pcx + AvgLX; 

	fxch	ST(1)
	fadd	ST(0), ST(5)
	neg	eax

; 825  : 							PGrain->Yunc = pcy + AvgLY;
; 826  : 							PGrain->ChainLinkNumber = 1 + (PGrain->pChainHead = pig)->ChainLinkNumber;

	mov	DWORD PTR [ecx+32], edx
	mov	DWORD PTR [ecx+8], eax
	fstp	DWORD PTR [ecx+20]
	fadd	ST(0), ST(5)
	fstp	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx+28]
	add	edx, 1

; 827  : 							}
; 828  : 						else

	jmp	SHORT $LN303@PutCluster
$LN16@PutCluster:

; 829  : 						{
; 830  : 							PGrain->Xcm = PClus->X + AvgLX;

	fld	DWORD PTR [eax]
	fadd	ST(0), ST(4)
	fstp	DWORD PTR [ecx]

; 831  : 							PGrain->Ycm = PClus->Y + AvgLY;

	fld	DWORD PTR [eax+4]
	fadd	ST(0), ST(5)
	fstp	DWORD PTR [ecx+4]

; 832  : 							PGrain->Area = PClus->Area;							

	mov	eax, DWORD PTR [eax+8]

; 833  : 							PGrain->ChainLinkNumber = 0;
; 834  : 							PGrain->pChainHead = 0;
; 835  : 							PGrain->Xunc = PGrain->Xcm;

	fld	DWORD PTR [ecx]
	mov	DWORD PTR [ecx+8], eax
	fstp	DWORD PTR [ecx+20]
	mov	DWORD PTR [ecx+32], edx

; 836  : 							PGrain->Yunc = PGrain->Ycm;

	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+24]
$LN303@PutCluster:
	mov	DWORD PTR [ecx+28], edx

; 837  : 							}
; 838  : 						//PClus = PClus->NextFree;
; 839  : 						PClus = NextFree;
; 840  : 						}
; 841  : 					while (((++PGrain) < PGrainEnd) && (PClus));

	add	ecx, 36					; 00000024H
	xor	edx, edx
	cmp	ecx, DWORD PTR _PGrainEnd$[esp+256]
	mov	eax, edi
	jae	SHORT $LN13@PutCluster
	cmp	edi, edx
	jne	$LN19@PutCluster

; 842  : 					}
; 843  : 				else

	jmp	SHORT $LN13@PutCluster
$LN20@PutCluster:

; 844  : 				{	
; 845  : 					PCell->Free = 0;

	mov	DWORD PTR [ebx+4], edx

; 846  : 					PCell->FirstG = 0;

	mov	DWORD PTR [ebx], edx
$LN13@PutCluster:

; 847  : 					};
; 848  : 				};
; 849  : 			T.NumGrains += PCell->Free;

	mov	eax, DWORD PTR [ebx+4]
	add	DWORD PTR [esi+1012], eax
	mov	eax, DWORD PTR _Icell$[esp+256]
	mov	edi, DWORD PTR _CellsInLayer$[esp+256]
	add	eax, 1
	cmp	eax, edi
	mov	DWORD PTR _Icell$[esp+256], eax
	jl	$LN140@PutCluster
	fstp	ST(3)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(1)

; 850  : 			};		
; 851  : 		}
; 852  : 	else

	jmp	$LN304@PutCluster
$LN260@PutCluster:

; 853  : 	{
; 854  : 		for (Icell = 0; (Icell < CellsInLayer) && (PGrain < PGrainEnd); Icell ++)

	mov	eax, DWORD PTR _CellsInLayer$[esp+256]
	fstp	ST(0)
	xor	edi, edi
	fstp	ST(0)
	cmp	eax, edx
	jle	$LN9@PutCluster
$LN11@PutCluster:
	cmp	ecx, DWORD PTR _PGrainEnd$[esp+256]
	jae	$LN123@PutCluster

; 855  : 		{	
; 856  : 			PCell = (Cell *)(CellSpace+(Layer*CellsInLayer+Icell));

	mov	edx, DWORD PTR _Layer$[esp+256]
	imul	edx, eax
	mov	eax, DWORD PTR _CellSpace$[esp+256]
	add	edx, edi
	lea	edx, DWORD PTR [eax+edx*8]

; 857  : 			if (PCell->Free)

	mov	eax, DWORD PTR [edx+4]
	test	eax, eax
	je	SHORT $LN2@PutCluster

; 858  : 			{	
; 859  : 				if (PCell->Free < CellOverflow)

	cmp	eax, DWORD PTR _CellOverflow$[esp+256]
	jge	SHORT $LN7@PutCluster

; 860  : 				{	
; 861  : 					PClus = PCell->FirstC;

	mov	eax, DWORD PTR [edx]

; 862  : 					PCell->FirstG = PGrain;

	mov	DWORD PTR [edx], ecx
	npad	1
$LL6@PutCluster:

; 863  : 					do
; 864  : 					{	
; 865  : 						PGrain->Xcm = PClus->X;

	fld	DWORD PTR [eax]

; 866  : 						PGrain->Ycm = PClus->Y;
; 867  : 						PGrain->Area = PClus->Area;
; 868  : 						NextFree = PClus->NextFree;
; 869  : /*						if (PGrain->Area <= 0)
; 870  : 						{
; 871  : 							::MessageBox(0, "Here - Invalid grain area!", "Debug Info", MB_OK);
; 872  : 							volatile int uy = 0;
; 873  : 							uy = 1;
; 874  : 							}*/
; 875  : 						//PClus = PClus->NextFree;
; 876  : 						PClus = NextFree;
; 877  : 						}
; 878  : 					while (((++PGrain) < PGrainEnd) && (PClus));

	add	ecx, 36					; 00000024H
	cmp	ecx, DWORD PTR _PGrainEnd$[esp+256]
	fstp	DWORD PTR [ecx-36]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx-32]
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx-28], ebx
	mov	eax, DWORD PTR [eax+12]
	jae	SHORT $LN2@PutCluster
	test	eax, eax
	jne	SHORT $LL6@PutCluster

; 879  : 					}
; 880  : 				else

	jmp	SHORT $LN2@PutCluster
$LN7@PutCluster:

; 881  : 				{	
; 882  : 					PCell->Free = 0;

	mov	DWORD PTR [edx+4], 0

; 883  : 					PCell->FirstG = 0;

	mov	DWORD PTR [edx], 0
$LN2@PutCluster:

; 884  : 					};
; 885  : 				};
; 886  : 			T.NumGrains += PCell->Free;

	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _CellsInLayer$[esp+256]
	add	DWORD PTR [esi+1012], edx
	add	edi, 1
	cmp	edi, eax
	jl	SHORT $LN11@PutCluster

; 853  : 	{
; 854  : 		for (Icell = 0; (Icell < CellsInLayer) && (PGrain < PGrainEnd); Icell ++)

	jmp	SHORT $LN9@PutCluster
$LN263@PutCluster:

; 803  : 	{
; 804  : 		for (Icell = 0; (Icell < CellsInLayer) && (PGrain < PGrainEnd); Icell ++)

	fstp	ST(0)
$LN304@PutCluster:
	fstp	ST(0)
$LN9@PutCluster:

; 887  : 			};
; 888  : 		}
; 889  : /*
; 890  : 	{
; 891  : 		FILE *f = fopen("c:\\acq\\tk.txt", "at");
; 892  : 		fprintf(f, "%d %f %f %d %f %f\n", T.Layer, T.DispX, T.DispY, ReplicaCount, CurrDispSigmaX, CurrDispSigmaY);
; 893  : 		fclose(f);
; 894  : 		}
; 895  : */
; 896  : 	if (PGrain >= PGrainEnd) return S_FALSE;

	cmp	ecx, DWORD PTR _PGrainEnd$[esp+256]
	jae	SHORT $LN123@PutCluster

; 897  : 	T.Layer++;

	add	DWORD PTR [esi+1016], 1

; 898  : 	return S_OK;

	xor	eax, eax

; 899  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN267@PutCluster:

; 887  : 			};
; 888  : 		}
; 889  : /*
; 890  : 	{
; 891  : 		FILE *f = fopen("c:\\acq\\tk.txt", "at");
; 892  : 		fprintf(f, "%d %f %f %d %f %f\n", T.Layer, T.DispX, T.DispY, ReplicaCount, CurrDispSigmaX, CurrDispSigmaY);
; 893  : 		fclose(f);
; 894  : 		}
; 895  : */
; 896  : 	if (PGrain >= PGrainEnd) return S_FALSE;

	fstp	ST(3)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)
$LN123@PutCluster:

; 899  : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z ENDP ; CSmartTrackerClass::PutClusters
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?InitTrackerData@CSmartTrackerClass@@IAEXXZ	; CSmartTrackerClass::InitTrackerData
; Function compile flags: /Ogtpy
;	COMDAT ?InitTrackerData@CSmartTrackerClass@@IAEXXZ
_TEXT	SEGMENT
_Temp$ = -76						; size = 72
__$ArrayPad$ = -4					; size = 4
?InitTrackerData@CSmartTrackerClass@@IAEXXZ PROC	; CSmartTrackerClass::InitTrackerData, COMDAT
; _this$ = ecx

; 1951 : {

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	push	esi

; 1952 : 	SySalConfig Temp = {0, 0, 0};

	xor	ebx, ebx
	push	61					; 0000003dH
	lea	eax, DWORD PTR _Temp$[esp+91]
	push	ebx
	push	eax
	mov	esi, ecx
	mov	BYTE PTR _Temp$[esp+96], bl
	mov	BYTE PTR _Temp$[esp+97], bl
	mov	BYTE PTR _Temp$[esp+98], bl
	call	_memset

; 1953 : 	GetData(Temp, ConfigDataN, ConfigDataQDI, &T, true);

	push	1
	lea	ecx, DWORD PTR [esi+140]
	push	ecx
	push	OFFSET ?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	xor	eax, eax
	lea	edx, DWORD PTR _Temp$[esp+108]
	push	200					; 000000c8H
	push	edx
	mov	DWORD PTR _Temp$[esp+180], eax
	mov	DWORD PTR _Temp$[esp+184], eax
	call	?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ; GetData

; 1954 : 
; 1955 : 	T.PresetSlope = false;
; 1956 : 	T.PresetSlopeAccX = T.PresetSlopeAccY = T.PresetSlopeX = T.PresetSlopeY = 0.0f;

	fldz

; 1957 : 	T.GrainSpace = 0;
; 1958 : 	T.ZLayer = 0;
; 1959 : 	T.LayerGrains = 0;
; 1960 : 	T.CellSpace = 0;
; 1961 : 	T.pDeltaHisto2d = 0;
; 1962 : 	T.pDeltaData = 0;
; 1963 : 	T.pX = T.pY = T.pDX = T.pDY = 0;
; 1964 : 	T.pReplicas = 0;
; 1965 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	fst	DWORD PTR [esi+948]
	fst	DWORD PTR [esi+944]
	add	esp, 32					; 00000020H
	fst	DWORD PTR [esi+956]
	mov	BYTE PTR [esi+940], bl
	mov	DWORD PTR [esi+960], ebx
	fstp	DWORD PTR [esi+952]
	mov	DWORD PTR [esi+964], ebx
	mov	DWORD PTR [esi+968], ebx
	mov	DWORD PTR [esi+972], ebx
	mov	DWORD PTR [esi+1064], ebx
	mov	DWORD PTR [esi+1068], ebx
	mov	DWORD PTR [esi+1084], ebx
	mov	DWORD PTR [esi+1080], ebx
	mov	DWORD PTR [esi+1076], ebx
	mov	DWORD PTR [esi+1072], ebx
	mov	DWORD PTR [esi+1088], ebx
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	0
?InitTrackerData@CSmartTrackerClass@@IAEXXZ ENDP	; CSmartTrackerClass::InitTrackerData
_TEXT	ENDS
PUBLIC	__real@3ff8000000000000
PUBLIC	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains
;	COMDAT __real@3ff8000000000000
; File f:\program files\microsoft visual studio 8\vc\include\math.h
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
; Function compile flags: /Ogtpy
; File d:\sysal2\smarttracker8.5\smarttrackerclass.cpp
CONST	ENDS
;	COMDAT ?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z
_TEXT	SEGMENT
_pScan$131666 = -12					; size = 4
_reddirtol$ = -8					; size = 4
_pEnd$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_dirx$ = 16						; size = 4
_diry$ = 20						; size = 4
_dirtol$ = 24						; size = 4
tv1716 = 28						; size = 4
tv1706 = 28						; size = 4
tv1699 = 28						; size = 4
tv1696 = 28						; size = 4
tv1690 = 28						; size = 4
tv1687 = 28						; size = 4
_normdist$ = 28						; size = 4
_dy$ = 28						; size = 4
_dx$ = 28						; size = 4
_normtol$ = 28						; size = 4
_pDest$ = 32						; size = 4
_pDist$ = 36						; size = 4
_maxmult$ = 40						; size = 4
?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z PROC	; Cell::FindGrains, COMDAT
; _this$ = ecx

; 1979 : {

	sub	esp, 12					; 0000000cH

; 1980 : 	int i, j;
; 1981 : 	float normdist;
; 1982 : 	float dx, dy;
; 1983 : 	IntGrain *pStart = FirstG;
; 1984 : 	IntGrain *pEnd = FirstG + Free;

	mov	eax, DWORD PTR [ecx]

; 1985 : 	float reddirtol = dirtol * 1.5f;

	fld	DWORD PTR _dirtol$[esp+8]
	mov	ecx, DWORD PTR [ecx+4]
	fmul	QWORD PTR __real@3ff8000000000000
	lea	ecx, DWORD PTR [ecx+ecx*8]
	lea	ecx, DWORD PTR [eax+ecx*4]

; 1986 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	mov	edx, eax
	fstp	DWORD PTR _reddirtol$[esp+12]
	cmp	edx, ecx
	mov	DWORD PTR _pEnd$[esp+12], ecx
	mov	DWORD PTR _pScan$131666[esp+12], eax
	jae	$LN12@FindGrains
	fld	DWORD PTR _normtol$[esp+8]
	push	ebx
	fld	DWORD PTR _diry$[esp+12]
	mov	ebx, DWORD PTR _pDist$[esp+12]
	fld	DWORD PTR _dirx$[esp+12]
	push	ebp
	mov	ebp, DWORD PTR _pDest$[esp+16]
	push	esi
	mov	esi, DWORD PTR _maxmult$[esp+20]
	push	edi
$LN48@FindGrains:
	fld	DWORD PTR _reddirtol$[esp+28]

; 1987 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [edx]
	fsub	DWORD PTR _x$[esp+24]
	fstp	DWORD PTR _dx$[esp+24]
	fld	DWORD PTR _dx$[esp+24]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv1716[esp+24]
	fld	DWORD PTR tv1716[esp+24]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN52@FindGrains

; 1988 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR _y$[esp+24]
	fstp	DWORD PTR _dy$[esp+24]
	fld	DWORD PTR _dy$[esp+24]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv1706[esp+24]
	fld	DWORD PTR tv1706[esp+24]
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 65					; 00000041H
	jp	$LN52@FindGrains

; 1989 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fld	ST(1)
	fmul	ST(0), ST(3)
	fld	ST(1)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv1699[esp+24]
	fld	DWORD PTR tv1699[esp+24]
	fabs
	fstp	DWORD PTR tv1696[esp+24]
	fld	DWORD PTR tv1696[esp+24]
	fstp	DWORD PTR _normdist$[esp+24]
	fld	DWORD PTR _normdist$[esp+24]
	fcom	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	$LN58@FindGrains

; 1990 : 					if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	ST(3)
	fmulp	ST(2), ST(0)
	fld	ST(4)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv1690[esp+24]
	fld	DWORD PTR tv1690[esp+24]
	fabs
	fstp	DWORD PTR tv1687[esp+24]
	fld	DWORD PTR tv1687[esp+24]
	fld	DWORD PTR _dirtol$[esp+24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN80@FindGrains

; 1991 : 					{
; 1992 : 						for (i = 0; i < maxmult && pDist[i] <= normdist; i++);

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC39@FindGrains
	lea	ecx, DWORD PTR [ebx+8]
$LN43@FindGrains:
	fld	DWORD PTR [ecx-8]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN49@FindGrains
	fld	DWORD PTR [ecx-4]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN40@FindGrains
	fld	DWORD PTR [ecx]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN41@FindGrains
	fld	DWORD PTR [ecx+4]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN42@FindGrains
	add	edi, 4
	lea	eax, DWORD PTR [esi-3]
	add	ecx, 16					; 00000010H
	cmp	edi, eax
	jl	SHORT $LN43@FindGrains
$LC39@FindGrains:
	cmp	edi, esi
	jge	SHORT $LN102@FindGrains
$LC7@FindGrains:
	fld	DWORD PTR [ebx+edi*4]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN49@FindGrains
	add	edi, 1
	cmp	edi, esi
	jl	SHORT $LC7@FindGrains
	jmp	SHORT $LN49@FindGrains
$LN40@FindGrains:
	add	edi, 1
	jmp	SHORT $LN49@FindGrains
$LN41@FindGrains:
	add	edi, 2
	jmp	SHORT $LN49@FindGrains
$LN42@FindGrains:
	add	edi, 3
$LN49@FindGrains:

; 1993 : 						if (i == maxmult) continue;

	cmp	edi, esi
$LN102@FindGrains:
	je	$LN80@FindGrains

; 1994 : 						for (j = maxmult - 1; j > i; j--)

	lea	ecx, DWORD PTR [esi-1]
	mov	eax, ecx
	sub	eax, edi
	cmp	eax, 4
	jl	SHORT $LC45@FindGrains
	mov	esi, ecx
	sub	esi, edi
	sub	esi, 4
	shr	esi, 2
	lea	edx, DWORD PTR [ebx+ecx*4-8]
	lea	eax, DWORD PTR [ebp+ecx*4-4]
	add	esi, 1

; 1995 : 						{
; 1996 : 							pDist[j] = pDist[j - 1];

	sub	ebx, ebp
	mov	ebp, esi
	neg	ebp
	lea	ecx, DWORD PTR [ecx+ebp*4]
$LN46@FindGrains:

; 1997 : 							pDest[j] = pDest[j - 1];

	mov	ebp, DWORD PTR [eax]
	fld	DWORD PTR [ebx+eax]
	fstp	DWORD PTR [edx+8]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [eax-4]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [ebx+eax]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [eax-8]
	fld	DWORD PTR [edx-4]
	fstp	DWORD PTR [edx]
	mov	DWORD PTR [eax-4], ebp
	fld	DWORD PTR [edx-8]
	mov	ebp, DWORD PTR [eax-12]
	fstp	DWORD PTR [edx-4]
	mov	DWORD PTR [eax-8], ebp
	sub	eax, 16					; 00000010H
	sub	edx, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LN46@FindGrains
	mov	esi, DWORD PTR _maxmult$[esp+24]
	mov	edx, DWORD PTR _pScan$131666[esp+28]
	mov	ebx, DWORD PTR _pDist$[esp+24]
	mov	ebp, DWORD PTR _pDest$[esp+24]
$LC45@FindGrains:

; 1994 : 						for (j = maxmult - 1; j > i; j--)

	cmp	ecx, edi
	jle	SHORT $LN44@FindGrains

; 1995 : 						{
; 1996 : 							pDist[j] = pDist[j - 1];

	mov	edx, ebx
	lea	eax, DWORD PTR [ebp+ecx*4-4]
	sub	edx, ebp
$LC3@FindGrains:
	fld	DWORD PTR [eax+edx]

; 1997 : 							pDest[j] = pDest[j - 1];

	mov	ebp, DWORD PTR [eax]
	fstp	DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [eax+4], ebp
	sub	ecx, 1
	sub	eax, 4
	cmp	ecx, edi
	jg	SHORT $LC3@FindGrains
	mov	ebp, DWORD PTR _pDest$[esp+24]
	mov	edx, DWORD PTR _pScan$131666[esp+28]
$LN44@FindGrains:

; 1998 : 							}
; 1999 : 						pDest[i] = pScan;
; 2000 : 						pDist[i] = normdist;

	fstp	DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [ebp+edi*4], edx
	jmp	SHORT $LN13@FindGrains
$LN58@FindGrains:

; 1989 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fstp	ST(0)
$LN52@FindGrains:
	fstp	ST(1)
$LN80@FindGrains:

; 1993 : 						if (i == maxmult) continue;

	fstp	ST(0)
$LN13@FindGrains:

; 1986 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	add	edx, 36					; 00000024H
	cmp	edx, DWORD PTR _pEnd$[esp+28]
	mov	DWORD PTR _pScan$131666[esp+28], edx
	jb	$LN48@FindGrains
	pop	edi
	fstp	ST(1)
	pop	esi
	fstp	ST(0)
	pop	ebp
	fstp	ST(0)
	pop	ebx
$LN12@FindGrains:

; 2001 : 						};
; 2002 : 	}

	add	esp, 12					; 0000000cH
	ret	36					; 00000024H
?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ENDP	; Cell::FindGrains
_TEXT	ENDS
PUBLIC	?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z	; Cell::FindGrain
; Function compile flags: /Ogtpy
;	COMDAT ?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z
_TEXT	SEGMENT
_reddirtol$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_dirx$ = 16						; size = 4
_bestnormdist$ = 20					; size = 4
_diry$ = 20						; size = 4
_dirtol$ = 24						; size = 4
tv908 = 28						; size = 4
tv898 = 28						; size = 4
tv891 = 28						; size = 4
tv888 = 28						; size = 4
tv879 = 28						; size = 4
tv876 = 28						; size = 4
tv865 = 28						; size = 4
tv855 = 28						; size = 4
tv848 = 28						; size = 4
tv845 = 28						; size = 4
tv836 = 28						; size = 4
tv833 = 28						; size = 4
tv822 = 28						; size = 4
tv812 = 28						; size = 4
tv805 = 28						; size = 4
tv802 = 28						; size = 4
tv793 = 28						; size = 4
tv790 = 28						; size = 4
tv778 = 28						; size = 4
tv767 = 28						; size = 4
tv760 = 28						; size = 4
tv756 = 28						; size = 4
tv747 = 28						; size = 4
tv743 = 28						; size = 4
tv732 = 28						; size = 4
tv722 = 28						; size = 4
tv715 = 28						; size = 4
tv712 = 28						; size = 4
tv703 = 28						; size = 4
tv700 = 28						; size = 4
_normdist$ = 28						; size = 4
_dy$ = 28						; size = 4
_dx$ = 28						; size = 4
_normtol$ = 28						; size = 4
?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z PROC		; Cell::FindGrain, COMDAT
; _this$ = ecx

; 2005 : {	

	push	ecx

; 2006 : 	IntGrain *pBest = 0;
; 2007 : 	int i;
; 2008 : 	float bestnormdist, normdist;
; 2009 : 	float dx, dy;
; 2010 : 	IntGrain *pStart = FirstG;
; 2011 : 	IntGrain *pEnd = FirstG + Free;

	mov	eax, DWORD PTR [ecx]

; 2012 : 	float reddirtol = dirtol * 1.5f;

	fld	DWORD PTR _dirtol$[esp]
	mov	ecx, DWORD PTR [ecx+4]
	fmul	QWORD PTR __real@3ff8000000000000
	push	esi
	lea	ecx, DWORD PTR [ecx+ecx*8]
	push	edi
	fstp	DWORD PTR _reddirtol$[esp+12]

; 2013 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	fld	DWORD PTR _normtol$[esp+8]
	lea	edi, DWORD PTR [eax+ecx*4]
	fld	DWORD PTR _diry$[esp+8]
	mov	ecx, eax
	fld	DWORD PTR _dirx$[esp+8]
	mov	edx, edi
	fld	DWORD PTR _reddirtol$[esp+12]
	sub	edx, eax
	add	edx, 35					; 00000023H
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	esi, esi
	cmp	eax, 4
	jl	$LN42@FindGrain
	push	ebx
	lea	ebx, DWORD PTR [edi-108]
$LN40@FindGrain:

; 2014 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _x$[esp+12]
	fstp	DWORD PTR _dx$[esp+12]
	fld	DWORD PTR _dx$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv908[esp+12]
	fld	DWORD PTR tv908[esp+12]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN55@FindGrain

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _y$[esp+12]
	fstp	DWORD PTR _dy$[esp+12]
	fld	DWORD PTR _dy$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv898[esp+12]
	fld	DWORD PTR tv898[esp+12]
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 65					; 00000041H
	jp	SHORT $LN58@FindGrain

; 2016 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fld	ST(1)
	fmul	ST(0), ST(3)
	fld	ST(1)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv891[esp+12]
	fld	DWORD PTR tv891[esp+12]
	fabs
	fstp	DWORD PTR tv888[esp+12]
	fld	DWORD PTR tv888[esp+12]
	fstp	DWORD PTR _normdist$[esp+12]
	fld	DWORD PTR _normdist$[esp+12]
	fcom	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN66@FindGrain

; 2017 : 					if (!pBest || normdist < bestnormdist)

	test	esi, esi
	je	SHORT $LN32@FindGrain
	fld	DWORD PTR _bestnormdist$[esp+12]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN66@FindGrain
$LN32@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	ST(3)
	fmulp	ST(2), ST(0)
	fld	ST(4)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv879[esp+12]
	fld	DWORD PTR tv879[esp+12]
	fabs
	fstp	DWORD PTR tv876[esp+12]
	fld	DWORD PTR tv876[esp+12]
	fld	DWORD PTR _dirtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN68@FindGrain

; 2019 : 						{
; 2020 : 							bestnormdist = normdist;

	fstp	DWORD PTR _bestnormdist$[esp+12]

; 2021 : 							pBest = pScan;

	mov	esi, ecx
	jmp	SHORT $LN43@FindGrain
$LN58@FindGrain:

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fstp	ST(1)
	jmp	SHORT $LN68@FindGrain
$LN66@FindGrain:

; 2017 : 					if (!pBest || normdist < bestnormdist)

	fstp	ST(2)
$LN55@FindGrain:
	fstp	ST(0)
$LN68@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fstp	ST(0)
$LN43@FindGrain:

; 2014 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [ecx+36]
	lea	edx, DWORD PTR [ecx+36]
	fsub	DWORD PTR _x$[esp+12]
	fstp	DWORD PTR _dx$[esp+12]
	fld	DWORD PTR _dx$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv865[esp+12]
	fld	DWORD PTR tv865[esp+12]
	fld	DWORD PTR _reddirtol$[esp+16]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	$LN71@FindGrain

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [ecx+40]
	fsub	DWORD PTR _y$[esp+12]
	fstp	DWORD PTR _dy$[esp+12]
	fld	DWORD PTR _dy$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv855[esp+12]
	fld	DWORD PTR tv855[esp+12]
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jp	SHORT $LN74@FindGrain

; 2016 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fld	ST(0)
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv848[esp+12]
	fld	DWORD PTR tv848[esp+12]
	fabs
	fstp	DWORD PTR tv845[esp+12]
	fld	DWORD PTR tv845[esp+12]
	fstp	DWORD PTR _normdist$[esp+12]
	fld	DWORD PTR _normdist$[esp+12]
	fcom	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN82@FindGrain

; 2017 : 					if (!pBest || normdist < bestnormdist)

	test	esi, esi
	je	SHORT $LN34@FindGrain
	fld	DWORD PTR _bestnormdist$[esp+12]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN82@FindGrain
$LN34@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	ST(3)
	fmulp	ST(3), ST(0)
	fld	ST(4)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv836[esp+12]
	fld	DWORD PTR tv836[esp+12]
	fabs
	fstp	DWORD PTR tv833[esp+12]
	fld	DWORD PTR tv833[esp+12]
	fld	DWORD PTR _dirtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN84@FindGrain

; 2019 : 						{
; 2020 : 							bestnormdist = normdist;

	fstp	DWORD PTR _bestnormdist$[esp+12]

; 2021 : 							pBest = pScan;

	mov	esi, edx
	jmp	SHORT $LN44@FindGrain
$LN74@FindGrain:

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fstp	ST(0)
	jmp	SHORT $LN84@FindGrain
$LN82@FindGrain:

; 2017 : 					if (!pBest || normdist < bestnormdist)

	fstp	ST(1)
$LN71@FindGrain:
	fstp	ST(1)
$LN84@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fstp	ST(0)
$LN44@FindGrain:

; 2014 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [ecx+72]
	lea	edx, DWORD PTR [ecx+72]
	fsub	DWORD PTR _x$[esp+12]
	fstp	DWORD PTR _dx$[esp+12]
	fld	DWORD PTR _dx$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv822[esp+12]
	fld	DWORD PTR tv822[esp+12]
	fld	DWORD PTR _reddirtol$[esp+16]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	$LN87@FindGrain

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [ecx+76]
	fsub	DWORD PTR _y$[esp+12]
	fstp	DWORD PTR _dy$[esp+12]
	fld	DWORD PTR _dy$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv812[esp+12]
	fld	DWORD PTR tv812[esp+12]
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jp	SHORT $LN90@FindGrain

; 2016 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fld	ST(0)
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv805[esp+12]
	fld	DWORD PTR tv805[esp+12]
	fabs
	fstp	DWORD PTR tv802[esp+12]
	fld	DWORD PTR tv802[esp+12]
	fstp	DWORD PTR _normdist$[esp+12]
	fld	DWORD PTR _normdist$[esp+12]
	fcom	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN98@FindGrain

; 2017 : 					if (!pBest || normdist < bestnormdist)

	test	esi, esi
	je	SHORT $LN36@FindGrain
	fld	DWORD PTR _bestnormdist$[esp+12]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN98@FindGrain
$LN36@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	ST(3)
	fmulp	ST(3), ST(0)
	fld	ST(4)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv793[esp+12]
	fld	DWORD PTR tv793[esp+12]
	fabs
	fstp	DWORD PTR tv790[esp+12]
	fld	DWORD PTR tv790[esp+12]
	fld	DWORD PTR _dirtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN100@FindGrain

; 2019 : 						{
; 2020 : 							bestnormdist = normdist;

	fstp	DWORD PTR _bestnormdist$[esp+12]

; 2021 : 							pBest = pScan;

	mov	esi, edx
	jmp	SHORT $LN45@FindGrain
$LN90@FindGrain:

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fstp	ST(0)
	jmp	SHORT $LN100@FindGrain
$LN98@FindGrain:

; 2017 : 					if (!pBest || normdist < bestnormdist)

	fstp	ST(1)
$LN87@FindGrain:
	fstp	ST(1)
$LN100@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fstp	ST(0)
$LN45@FindGrain:

; 2014 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [ecx+108]
	lea	edx, DWORD PTR [ecx+108]
	fsub	DWORD PTR _x$[esp+12]
	fstp	DWORD PTR _dx$[esp+12]
	fld	DWORD PTR _dx$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv778[esp+12]
	fld	DWORD PTR tv778[esp+12]
	fld	DWORD PTR _reddirtol$[esp+16]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	$LN103@FindGrain

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [ecx+112]
	fsub	DWORD PTR _y$[esp+12]
	fstp	DWORD PTR _dy$[esp+12]
	fld	DWORD PTR _dy$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv767[esp+12]
	fld	DWORD PTR tv767[esp+12]
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jp	SHORT $LN106@FindGrain

; 2016 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fld	ST(0)
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv760[esp+12]
	fld	DWORD PTR tv760[esp+12]
	fabs
	fstp	DWORD PTR tv756[esp+12]
	fld	DWORD PTR tv756[esp+12]
	fstp	DWORD PTR _normdist$[esp+12]
	fld	DWORD PTR _normdist$[esp+12]
	fcom	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN114@FindGrain

; 2017 : 					if (!pBest || normdist < bestnormdist)

	test	esi, esi
	je	SHORT $LN38@FindGrain
	fld	DWORD PTR _bestnormdist$[esp+12]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN114@FindGrain
$LN38@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	ST(3)
	fmulp	ST(3), ST(0)
	fld	ST(4)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv747[esp+12]
	fld	DWORD PTR tv747[esp+12]
	fabs
	fstp	DWORD PTR tv743[esp+12]
	fld	DWORD PTR tv743[esp+12]
	fld	DWORD PTR _dirtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN116@FindGrain

; 2019 : 						{
; 2020 : 							bestnormdist = normdist;

	fstp	DWORD PTR _bestnormdist$[esp+12]

; 2021 : 							pBest = pScan;

	mov	esi, edx
	jmp	SHORT $LN46@FindGrain
$LN106@FindGrain:

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fstp	ST(0)
	jmp	SHORT $LN116@FindGrain
$LN114@FindGrain:

; 2017 : 					if (!pBest || normdist < bestnormdist)

	fstp	ST(1)
$LN103@FindGrain:
	fstp	ST(1)
$LN116@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fstp	ST(0)
$LN46@FindGrain:

; 2021 : 							pBest = pScan;

	fld	DWORD PTR _reddirtol$[esp+16]
	add	ecx, 144				; 00000090H
	cmp	ecx, ebx
	jl	$LN40@FindGrain
	pop	ebx
$LN42@FindGrain:

; 2013 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	cmp	ecx, edi
	jb	SHORT $LC9@FindGrain
	fstp	ST(2)
	pop	edi
	fstp	ST(0)

; 2022 : 							};
; 2023 : 	return pBest;

	mov	eax, esi
	fstp	ST(0)
	pop	esi
	fstp	ST(0)

; 2024 : 	};

	pop	ecx
	ret	24					; 00000018H
$LN49@FindGrain:

; 2013 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	fld	DWORD PTR _reddirtol$[esp+12]
$LC9@FindGrain:

; 2014 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _x$[esp+8]
	fstp	DWORD PTR _dx$[esp+8]
	fld	DWORD PTR _dx$[esp+8]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv732[esp+8]
	fld	DWORD PTR tv732[esp+8]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN126@FindGrain

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _y$[esp+8]
	fstp	DWORD PTR _dy$[esp+8]
	fld	DWORD PTR _dy$[esp+8]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv722[esp+8]
	fld	DWORD PTR tv722[esp+8]
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 65					; 00000041H
	jp	SHORT $LN129@FindGrain

; 2016 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fld	ST(1)
	fmul	ST(0), ST(3)
	fld	ST(1)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv715[esp+8]
	fld	DWORD PTR tv715[esp+8]
	fabs
	fstp	DWORD PTR tv712[esp+8]
	fld	DWORD PTR tv712[esp+8]
	fstp	DWORD PTR _normdist$[esp+8]
	fld	DWORD PTR _normdist$[esp+8]
	fcom	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN137@FindGrain

; 2017 : 					if (!pBest || normdist < bestnormdist)

	test	esi, esi
	je	SHORT $LN2@FindGrain
	fld	DWORD PTR _bestnormdist$[esp+8]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN137@FindGrain
$LN2@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	ST(3)
	fmulp	ST(2), ST(0)
	fld	ST(4)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv703[esp+8]
	fld	DWORD PTR tv703[esp+8]
	fabs
	fstp	DWORD PTR tv700[esp+8]
	fld	DWORD PTR tv700[esp+8]
	fld	DWORD PTR _dirtol$[esp+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN139@FindGrain

; 2019 : 						{
; 2020 : 							bestnormdist = normdist;

	fstp	DWORD PTR _bestnormdist$[esp+8]

; 2021 : 							pBest = pScan;

	mov	esi, ecx
	jmp	SHORT $LN8@FindGrain
$LN129@FindGrain:

; 2015 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fstp	ST(1)
	jmp	SHORT $LN139@FindGrain
$LN137@FindGrain:

; 2017 : 					if (!pBest || normdist < bestnormdist)

	fstp	ST(2)
$LN126@FindGrain:
	fstp	ST(0)
$LN139@FindGrain:

; 2018 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fstp	ST(0)
$LN8@FindGrain:

; 2013 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	add	ecx, 36					; 00000024H
	cmp	ecx, edi
	jb	$LN49@FindGrain
	fstp	ST(1)
	pop	edi
	fstp	ST(0)

; 2022 : 							};
; 2023 : 	return pBest;

	mov	eax, esi
	fstp	ST(0)
	pop	esi

; 2024 : 	};

	pop	ecx
	ret	24					; 00000018H
?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z ENDP		; Cell::FindGrain
_TEXT	ENDS
PUBLIC	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
; Function compile flags: /Ogtpy
;	COMDAT ?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z
_TEXT	SEGMENT
_reddirtol$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_dirx$ = 16						; size = 4
_diry$ = 20						; size = 4
_dirtol$ = 24						; size = 4
tv478 = 28						; size = 4
tv468 = 28						; size = 4
tv461 = 28						; size = 4
tv458 = 28						; size = 4
tv452 = 28						; size = 4
tv448 = 28						; size = 4
tv441 = 28						; size = 4
tv437 = 28						; size = 4
tv430 = 28						; size = 4
tv426 = 28						; size = 4
tv419 = 28						; size = 4
tv415 = 28						; size = 4
tv405 = 28						; size = 4
tv402 = 28						; size = 4
_normdist$ = 28						; size = 4
_dy$ = 28						; size = 4
_dx$ = 28						; size = 4
_bestnormdist$ = 28					; size = 4
_normtol$ = 28						; size = 4
_pTopShadow$ = 32					; size = 4
_pBottomShadow$ = 36					; size = 4
_xshadowtol$ = 40					; size = 4
_yshadowtol$ = 44					; size = 4
?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z PROC ; Cell::FindGrainNoShadow, COMDAT
; _this$ = ecx

; 2027 : {

	push	ecx

; 2028 : 	IntGrain *pBest = 0;
; 2029 : 	int i;
; 2030 : 	float bestnormdist = normtol, normdist;

	fld	DWORD PTR _normtol$[esp]
	mov	eax, ecx

; 2031 : 	float dx, dy;
; 2032 : 	IntGrain *pStart = FirstG;
; 2033 : 	IntGrain *pEnd = FirstG + Free;

	mov	ecx, DWORD PTR [eax]
	fstp	DWORD PTR _bestnormdist$[esp]
	mov	eax, DWORD PTR [eax+4]

; 2034 : 	float reddirtol = dirtol * 1.5f;

	fld	DWORD PTR _dirtol$[esp]
	fmul	QWORD PTR __real@3ff8000000000000
	lea	eax, DWORD PTR [eax+eax*8]
	push	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	xor	ebx, ebx
	fstp	DWORD PTR _reddirtol$[esp+8]

; 2035 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	cmp	ecx, edx
	jae	$LN47@FindGrainN
	fld	DWORD PTR _diry$[esp+4]
	push	esi
	fld	DWORD PTR _dirx$[esp+8]
	mov	esi, DWORD PTR _pBottomShadow$[esp+8]
	fld	DWORD PTR _reddirtol$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pTopShadow$[esp+12]
	fld	DWORD PTR _bestnormdist$[esp+12]
	jmp	SHORT $LN10@FindGrainN
$LN49@FindGrainN:
	fld	DWORD PTR _reddirtol$[esp+16]
	fxch	ST(1)
$LN10@FindGrainN:

; 2036 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _x$[esp+12]
	fstp	DWORD PTR _dx$[esp+12]
	fld	DWORD PTR _dx$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv478[esp+12]
	fld	DWORD PTR tv478[esp+12]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN52@FindGrainN

; 2037 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _y$[esp+12]
	fstp	DWORD PTR _dy$[esp+12]
	fld	DWORD PTR _dy$[esp+12]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv468[esp+12]
	fld	DWORD PTR tv468[esp+12]
	fcomp	ST(4)
	fnstsw	ax
	fstp	ST(3)
	test	ah, 65					; 00000041H
	jp	$LN55@FindGrainN

; 2038 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < bestnormdist)

	fld	ST(2)
	fmul	ST(0), ST(4)
	fld	ST(1)
	fmul	ST(0), ST(6)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv461[esp+12]
	fld	DWORD PTR tv461[esp+12]
	fabs
	fstp	DWORD PTR tv458[esp+12]
	fld	DWORD PTR tv458[esp+12]
	fstp	DWORD PTR _normdist$[esp+12]
	fld	DWORD PTR _normdist$[esp+12]
	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	$LN73@FindGrainN

; 2039 : 				{
; 2040 : 					if (pTopShadow && fabs(pTopShadow->Xcm - pScan->Xcm) < xshadowtol && fabs(pTopShadow->Ycm - pScan->Ycm) < yshadowtol) continue;

	test	edi, edi
	je	SHORT $LN4@FindGrainN
	fld	DWORD PTR [edi]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR tv452[esp+12]
	fld	DWORD PTR tv452[esp+12]
	fabs
	fstp	DWORD PTR tv448[esp+12]
	fld	DWORD PTR tv448[esp+12]
	fld	DWORD PTR _xshadowtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@FindGrainN
	fld	DWORD PTR [edi+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR tv441[esp+12]
	fld	DWORD PTR tv441[esp+12]
	fabs
	fstp	DWORD PTR tv437[esp+12]
	fld	DWORD PTR tv437[esp+12]
	fld	DWORD PTR _yshadowtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN73@FindGrainN
$LN4@FindGrainN:

; 2041 : 					if (pBottomShadow && fabs(pBottomShadow->Xcm - pScan->Xcm) < xshadowtol && fabs(pBottomShadow->Ycm - pScan->Ycm) < yshadowtol) continue;

	test	esi, esi
	je	SHORT $LN3@FindGrainN
	fld	DWORD PTR [esi]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR tv430[esp+12]
	fld	DWORD PTR tv430[esp+12]
	fabs
	fstp	DWORD PTR tv426[esp+12]
	fld	DWORD PTR tv426[esp+12]
	fld	DWORD PTR _xshadowtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@FindGrainN
	fld	DWORD PTR [esi+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR tv419[esp+12]
	fld	DWORD PTR tv419[esp+12]
	fabs
	fstp	DWORD PTR tv415[esp+12]
	fld	DWORD PTR tv415[esp+12]
	fld	DWORD PTR _yshadowtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN73@FindGrainN
$LN3@FindGrainN:

; 2042 : 					if (normdist < bestnormdist)

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN73@FindGrainN

; 2043 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	ST(4)
	fmulp	ST(2), ST(0)
	fld	ST(5)
	fmulp	ST(4), ST(0)
	fxch	ST(1)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR tv405[esp+12]
	fld	DWORD PTR tv405[esp+12]
	fabs
	fstp	DWORD PTR tv402[esp+12]
	fld	DWORD PTR tv402[esp+12]
	fld	DWORD PTR _dirtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN76@FindGrainN
	fstp	ST(0)

; 2044 : 						{
; 2045 : 							bestnormdist = normdist;
; 2046 : 							pBest = pScan;

	mov	ebx, ecx
	fstp	DWORD PTR _bestnormdist$[esp+12]
	fld	DWORD PTR _bestnormdist$[esp+12]
	jmp	SHORT $LN9@FindGrainN
$LN55@FindGrainN:

; 2037 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fstp	ST(2)
	jmp	SHORT $LN76@FindGrainN
$LN73@FindGrainN:

; 2042 : 					if (normdist < bestnormdist)

	fstp	ST(3)
$LN52@FindGrainN:
	fstp	ST(0)
$LN76@FindGrainN:

; 2043 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fstp	ST(1)
$LN9@FindGrainN:

; 2035 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	add	ecx, 36					; 00000024H
	cmp	ecx, edx
	jb	$LN49@FindGrainN
	fstp	ST(2)
	pop	edi
	fstp	ST(0)
	pop	esi
	fstp	ST(0)
$LN47@FindGrainN:

; 2047 : 							};
; 2048 : 					}
; 2049 : 	return pBest;

	mov	eax, ebx
	pop	ebx

; 2050 : 	};

	pop	ecx
	ret	40					; 00000028H
?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ENDP ; Cell::FindGrainNoShadow
_TEXT	ENDS
PUBLIC	?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ	; CSmartTrackerClass::ResetDeltaHisto
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalFree@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ
_TEXT	SEGMENT
tv341 = -8						; size = 4
tv334 = -8						; size = 4
tv247 = -8						; size = 4
tv236 = -8						; size = 4
tv331 = -4						; size = 4
tv324 = -4						; size = 4
tv319 = -4						; size = 4
tv311 = -4						; size = 4
?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ PROC	; CSmartTrackerClass::ResetDeltaHisto, COMDAT
; _this$ = ecx

; 2184 : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 2185 : 	if (T.pDeltaHisto2d) GlobalFree(T.pDeltaHisto2d);

	mov	eax, DWORD PTR [esi+1064]
	test	eax, eax
	push	edi
	je	SHORT $LN1@ResetDelta
	push	eax
	call	DWORD PTR __imp__GlobalFree@4
$LN1@ResetDelta:
	fld	DWORD PTR [esi+1004]

; 2186 : 	T.pDeltaHisto2d = 0;
; 2187 : 	T.DeltaDX = fabs(T.PixelToMicronX);
; 2188 : 	T.DeltaDY = fabs(T.PixelToMicronY);
; 2189 : 	T.DeltaBinsX = (int)floor(T.ReplicaRadius / T.DeltaDX + 1) * 2 + 5;

	sub	esp, 8
	fabs
	mov	DWORD PTR [esi+1064], 0
	fstp	DWORD PTR tv341[esp+24]
	fld	DWORD PTR tv341[esp+24]
	fstp	DWORD PTR tv236[esp+24]
	fld	DWORD PTR tv236[esp+24]
	fst	DWORD PTR [esi+1048]
	fld	DWORD PTR [esi+1008]
	fabs
	fstp	DWORD PTR tv334[esp+24]
	fld	DWORD PTR tv334[esp+24]
	fstp	DWORD PTR tv247[esp+24]
	fld	DWORD PTR tv247[esp+24]
	fstp	DWORD PTR [esi+1052]
	fdivr	DWORD PTR [esi+908]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	DWORD PTR tv331[esp+24]
	fld	DWORD PTR tv331[esp+24]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	DWORD PTR tv324[esp+24]
	fld	DWORD PTR tv324[esp+24]
	call	__ftol2_sse

; 2190 : 	T.DeltaBinsY = (int)floor(T.ReplicaRadius / T.DeltaDY + 1) * 2 + 5;

	fld	DWORD PTR [esi+908]
	fdiv	DWORD PTR tv247[esp+24]
	lea	edi, DWORD PTR [eax+eax+5]
	mov	DWORD PTR [esi+1056], edi
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	DWORD PTR tv319[esp+24]
	fld	DWORD PTR tv319[esp+24]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	DWORD PTR tv311[esp+24]
	add	esp, 8
	fld	DWORD PTR tv311[esp+16]
	call	__ftol2_sse
	lea	eax, DWORD PTR [eax+eax+5]
	mov	DWORD PTR [esi+1060], eax

; 2191 : 	return T.pDeltaHisto2d = (int *)GlobalAlloc(GMEM_FIXED, sizeof(int) * T.DeltaBinsX * T.DeltaBinsY);

	imul	eax, edi
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	call	DWORD PTR __imp__GlobalAlloc@8
	mov	DWORD PTR [esi+1064], eax
	test	eax, eax
	pop	edi
	setne	al
	pop	esi

; 2192 : }

	add	esp, 8
	ret	0
?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ ENDP	; CSmartTrackerClass::ResetDeltaHisto
_TEXT	ENDS
PUBLIC	?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z ; CSmartTrackerClass::PutData
; Function compile flags: /Ogtpy
;	COMDAT ?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z
_TEXT	SEGMENT
_pConfig$ = 8						; size = 4
_pC$ = 12						; size = 4
?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z PROC ; CSmartTrackerClass::PutData, COMDAT

; 2200 : 	::PutData(*pConfig, ConfigDataN, ConfigDataQDI, pC);

	mov	eax, DWORD PTR _pC$[esp-4]
	mov	ecx, DWORD PTR _pConfig$[esp-4]
	push	eax
	push	OFFSET ?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	ecx
	call	?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutData
	add	esp, 16					; 00000010H

; 2201 : }

	ret	0
?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z ENDP ; CSmartTrackerClass::PutData
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z ; CSmartTrackerClass::SetCameraSpec
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z
_TEXT	SEGMENT
tv464 = 8						; size = 4
tv459 = 8						; size = 4
tv453 = 8						; size = 4
tv448 = 8						; size = 4
tv439 = 8						; size = 4
tv438 = 8						; size = 4
tv436 = 8						; size = 4
tv435 = 8						; size = 4
tv429 = 8						; size = 4
tv428 = 8						; size = 4
tv426 = 8						; size = 4
tv425 = 8						; size = 4
tv411 = 8						; size = 4
tv407 = 8						; size = 4
_this$ = 8						; size = 4
_Spec$ = 12						; size = 32
?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z PROC ; CSmartTrackerClass::SetCameraSpec, COMDAT

; 502  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 503  : 
; 504  : 	// TODO: Add your implementation code here
; 505  : 	if (Spec.PixelToMicronX != 0.f && Spec.PixelToMicronY != 0.f &&
; 506  : 		Spec.Height > 0 && Spec.Width > 0 && Spec.WinHeight > 0 && Spec.WinWidth > 0)

	fldz
	push	ebx
	fld	ST(0)
	push	ebp
	fld	DWORD PTR _Spec$[esp+28]
	fucom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN10@SetCameraS
	fld	ST(1)
	fld	DWORD PTR _Spec$[esp+32]
	fucom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN25@SetCameraS
	cmp	DWORD PTR _Spec$[esp+8], 0
	jbe	$LN25@SetCameraS
	cmp	DWORD PTR _Spec$[esp+4], 0
	jbe	$LN25@SetCameraS
	mov	ebp, DWORD PTR _Spec$[esp+24]
	test	ebp, ebp
	jbe	$LN25@SetCameraS
	mov	ebx, DWORD PTR _Spec$[esp+20]
	test	ebx, ebx
	jbe	$LN25@SetCameraS

; 507  : 	{
; 508  : 		CamSpec = Spec;

	mov	edx, DWORD PTR _this$[esp+4]

; 509  : 		T.PixelToMicronX = Spec.PixelToMicronX;

	fxch	ST(1)
	fst	DWORD PTR [edx+1004]
	push	esi

; 510  : 		T.PixelToMicronY = Spec.PixelToMicronY;

	fxch	ST(1)
	push	edi
	fst	DWORD PTR [edx+1008]
	lea	edi, DWORD PTR [edx+108]

; 511  : 		if (T.PixelToMicronX > 0)

	fxch	ST(1)
	mov	ecx, 8
	fcom	ST(2)
	lea	esi, DWORD PTR _Spec$[esp+12]
	rep movsd
	fnstsw	ax
	test	ah, 65					; 00000041H

; 512  : 		{	T.Win.Xmin = Spec.OffX;

	mov	eax, DWORD PTR _Spec$[esp+20]
	pop	edi
	pop	esi
	mov	ecx, eax
	jne	SHORT $LN5@SetCameraS
	test	ecx, ecx
	mov	DWORD PTR tv439[esp+4], ecx
	fild	DWORD PTR tv439[esp+4]
	jge	SHORT $LN35@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN35@SetCameraS:

; 513  : 			T.Win.Xmax = Spec.OffX + Spec.WinWidth;

	add	eax, ebx
	fstp	DWORD PTR [edx+980]
	test	eax, eax
	mov	DWORD PTR tv438[esp+4], eax
	fild	DWORD PTR tv438[esp+4]
	jge	SHORT $LN36@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN36@SetCameraS:
	fstp	DWORD PTR [edx+984]

; 514  : 			}
; 515  : 		else

	jmp	SHORT $LN4@SetCameraS
$LN5@SetCameraS:

; 516  : 		{	T.Win.Xmax = Spec.OffX;

	test	ecx, ecx
	mov	DWORD PTR tv436[esp+4], ecx
	fild	DWORD PTR tv436[esp+4]
	jge	SHORT $LN37@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN37@SetCameraS:

; 517  : 			T.Win.Xmin = Spec.OffX + Spec.WinWidth;

	add	eax, ebx
	fstp	DWORD PTR [edx+984]
	test	eax, eax
	mov	DWORD PTR tv435[esp+4], eax
	fild	DWORD PTR tv435[esp+4]
	jge	SHORT $LN38@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN38@SetCameraS:
	fstp	DWORD PTR [edx+980]
$LN4@SetCameraS:

; 518  : 			};
; 519  : 		if (T.PixelToMicronY > 0)

	fxch	ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5

; 520  : 		{  T.Win.Ymin = Spec.OffY;

	mov	eax, DWORD PTR _Spec$[esp+16]
	mov	ecx, eax
	jp	SHORT $LN3@SetCameraS
	test	ecx, ecx
	mov	DWORD PTR tv429[esp+4], ecx
	fild	DWORD PTR tv429[esp+4]
	jge	SHORT $LN39@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN39@SetCameraS:

; 521  : 			T.Win.Ymax = Spec.OffY + Spec.WinHeight;

	add	eax, ebp
	fstp	DWORD PTR [edx+988]
	test	eax, eax
	mov	DWORD PTR tv428[esp+4], eax
	fild	DWORD PTR tv428[esp+4]
	jge	SHORT $LN40@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN40@SetCameraS:
	fstp	DWORD PTR [edx+992]

; 522  : 			}
; 523  : 		else

	jmp	SHORT $LN2@SetCameraS
$LN3@SetCameraS:

; 524  : 		{	T.Win.Ymax = Spec.OffY;

	test	ecx, ecx
	mov	DWORD PTR tv426[esp+4], ecx
	fild	DWORD PTR tv426[esp+4]
	jge	SHORT $LN41@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN41@SetCameraS:

; 525  : 			T.Win.Ymin = Spec.OffY + Spec.WinHeight;

	add	eax, ebp
	fstp	DWORD PTR [edx+992]
	test	eax, eax
	mov	DWORD PTR tv425[esp+4], eax
	fild	DWORD PTR tv425[esp+4]
	jge	SHORT $LN42@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN42@SetCameraS:
	fstp	DWORD PTR [edx+988]
$LN2@SetCameraS:

; 526  : 			};
; 527  : 		T.Win.Xmin *= T.PixelToMicronX;

	fld	DWORD PTR [edx+980]

; 528  : 		T.Win.Xmax *= T.PixelToMicronX;
; 529  : 		T.Win.Ymin *= T.PixelToMicronY;
; 530  : 		T.Win.Ymax *= T.PixelToMicronY;
; 531  : 		T.DxCell = ((T.Win.Xmax - T.Win.Xmin)/(float)(T.CellNumX));
; 532  : 		T.DyCell = ((T.Win.Ymax - T.Win.Ymin)/(float)(T.CellNumY));
; 533  : 		T.ViewCenterX = Spec.Width * Spec.PixelToMicronX * 0.5;

	mov	eax, DWORD PTR _Spec$[esp+4]
	test	eax, eax
	fmul	ST(0), ST(2)
	fstp	DWORD PTR tv448[esp+4]
	fld	DWORD PTR tv448[esp+4]
	fst	DWORD PTR [edx+980]
	fld	DWORD PTR [edx+984]
	fmul	ST(0), ST(3)
	fstp	DWORD PTR tv453[esp+4]
	fld	DWORD PTR tv453[esp+4]
	fst	DWORD PTR [edx+984]
	fld	ST(2)
	fmul	DWORD PTR [edx+988]
	fstp	DWORD PTR tv459[esp+4]
	fld	DWORD PTR tv459[esp+4]
	fst	DWORD PTR [edx+988]
	fld	ST(3)
	fmul	DWORD PTR [edx+992]
	fstp	DWORD PTR tv464[esp+4]
	fld	DWORD PTR tv464[esp+4]
	fst	DWORD PTR [edx+992]
	fxch	ST(2)
	fsubrp	ST(3), ST(0)
	fild	DWORD PTR [edx+152]
	fdivp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR [edx+996]
	fsubrp	ST(1), ST(0)
	fidiv	DWORD PTR [edx+156]
	fstp	DWORD PTR [edx+1000]
	fild	DWORD PTR _Spec$[esp+4]
	jge	SHORT $LN43@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN43@SetCameraS:

; 534  : 		T.ViewCenterY = Spec.Height * Spec.PixelToMicronY * 0.5;

	mov	ecx, DWORD PTR _Spec$[esp+8]
	fmulp	ST(2), ST(0)
	test	ecx, ecx
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR [edx+1092]
	fild	DWORD PTR _Spec$[esp+8]
	jge	SHORT $LN44@SetCameraS
	fadd	DWORD PTR __real@4f800000
$LN44@SetCameraS:
	fmulp	ST(1), ST(0)

; 535  : 		if (!ResetDeltaHisto()) return S_FALSE;

	mov	ecx, edx
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR [edx+1096]
	call	?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ ; CSmartTrackerClass::ResetDeltaHisto
	neg	al
	pop	ebp
	pop	ebx
	sbb	eax, eax
	add	eax, 1

; 539  : }

	ret	36					; 00000024H
$LN25@SetCameraS:

; 502  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 503  : 
; 504  : 	// TODO: Add your implementation code here
; 505  : 	if (Spec.PixelToMicronX != 0.f && Spec.PixelToMicronY != 0.f &&
; 506  : 		Spec.Height > 0 && Spec.Width > 0 && Spec.WinHeight > 0 && Spec.WinWidth > 0)

	fstp	ST(0)
$LN10@SetCameraS:
	fstp	ST(0)
	pop	ebp
	fstp	ST(0)

; 536  : 		return S_OK;
; 537  : 		};
; 538  : 	return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	pop	ebx

; 539  : }

	ret	36					; 00000024H
?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z ENDP ; CSmartTrackerClass::SetCameraSpec
_TEXT	ENDS
PUBLIC	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
; Function compile flags: /Ogtpy
;	COMDAT ?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z
_TEXT	SEGMENT
_fix$ = -20						; size = 4
_fiy$ = -16						; size = 4
tv398 = -12						; size = 4
_eix$ = -8						; size = 4
tv394 = -4						; size = 4
tv387 = -4						; size = 4
_eiy$ = -4						; size = 4
_expx$ = 8						; size = 4
_expy$ = 12						; size = 4
_pCellLayer$ = 16					; size = 4
_dirx$ = 20						; size = 4
_diry$ = 24						; size = 4
_dirtol$ = 28						; size = 4
_pTopShadow$ = 32					; size = 4
_pBottomShadow$ = 36					; size = 4
_xshadowtol$ = 40					; size = 4
_yshadowtol$ = 44					; size = 4
?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z PROC ; CSmartTrackerClass::FindGrain, COMDAT
; _this$ = ecx

; 1239 : {

	sub	esp, 20					; 00000014H

; 1240 : 	float fix, fiy;
; 1241 : 	int eix = (int)(fix = ((expx - T.Win.Xmin) / T.DxCell));

	fld	DWORD PTR _expx$[esp+16]
	push	ebx
	fld	ST(0)
	push	ebp
	push	esi
	mov	esi, ecx
	fsub	DWORD PTR [esi+980]
	fdiv	DWORD PTR [esi+996]
	fstp	DWORD PTR _fix$[esp+32]
	fld	DWORD PTR _fix$[esp+32]
	call	__ftol2_sse
	mov	ebx, eax

; 1242 : 	if (eix < 0 || eix >= T.CellNumX) return 0;

	test	ebx, ebx
	mov	DWORD PTR _eix$[esp+32], ebx
	jl	$LN28@FindGrain@2
	mov	ebp, DWORD PTR [esi+152]
	cmp	ebx, ebp
	jge	$LN28@FindGrain@2

; 1243 : 	int eiy = (int)(fiy = ((expy - T.Win.Ymin) / T.DyCell));

	fld	DWORD PTR _expy$[esp+28]
	push	edi
	fld	ST(0)
	fsub	DWORD PTR [esi+988]
	fdiv	DWORD PTR [esi+1000]
	fstp	DWORD PTR _fiy$[esp+36]
	fld	DWORD PTR _fiy$[esp+36]
	call	__ftol2_sse
	mov	edi, eax

; 1244 : 	if (eiy >= 0 && eiy < T.CellNumY)

	test	edi, edi
	mov	DWORD PTR _eiy$[esp+36], edi
	jl	$LN34@FindGrain@2
	cmp	edi, DWORD PTR [esi+156]
	jge	$LN34@FindGrain@2

; 1245 : 	{
; 1246 : 		IntGrain *pNew = pCellLayer[eiy * T.CellNumX + eix].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	fld	DWORD PTR _yshadowtol$[esp+32]
	mov	ecx, DWORD PTR _pCellLayer$[esp+32]
	mov	edx, DWORD PTR _pBottomShadow$[esp+32]
	mov	eax, ebp
	imul	eax, edi
	sub	esp, 8
	add	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _pTopShadow$[esp+40]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _xshadowtol$[esp+40]
	mov	DWORD PTR tv398[esp+44], ecx
	fstp	DWORD PTR [esp]
	push	edx
	fld	DWORD PTR [esi+168]
	push	eax
	sub	esp, 24					; 00000018H
	fstp	DWORD PTR [esp+20]
	fld	DWORD PTR _dirtol$[esp+72]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+72]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+72]
	fstp	DWORD PTR [esp+8]
	fstp	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow

; 1247 : 		if (pNew) return pNew;

	test	eax, eax
	jne	$LN23@FindGrain@2

; 1248 : 		fix -= (0.5f + eix);

	fild	DWORD PTR _eix$[esp+36]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fsubr	DWORD PTR _fix$[esp+36]
	fstp	DWORD PTR _fix$[esp+36]

; 1249 : 		fiy -= (0.5f + eiy);

	fild	DWORD PTR _eiy$[esp+36]
	faddp	ST(1), ST(0)
	fsubr	DWORD PTR _fiy$[esp+36]
	fstp	DWORD PTR _fiy$[esp+36]

; 1250 : 		if (fabs(fix) >= fabs(fiy))

	fld	DWORD PTR _fix$[esp+36]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv394[esp+36]
	fld	DWORD PTR tv394[esp+36]
	fld	DWORD PTR _fiy$[esp+36]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv387[esp+36]
	fld	DWORD PTR tv387[esp+36]
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jp	$LN37@FindGrain@2
	fstp	ST(0)

; 1251 : 		{
; 1252 : 			if (fix < 0.0f && eix > 0)

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@FindGrain@2
	test	ebx, ebx
	jle	SHORT $LN7@FindGrain@2

; 1253 : 				return pCellLayer[eiy * T.CellNumX + eix - 1].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	mov	ecx, DWORD PTR _pBottomShadow$[esp+32]
	fstp	ST(0)
	mov	edx, DWORD PTR _pTopShadow$[esp+32]
	fstp	ST(0)
	fld	DWORD PTR _yshadowtol$[esp+32]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _xshadowtol$[esp+40]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR [esi+168]
	mov	ecx, DWORD PTR tv398[esp+48]
	push	edx
	sub	esp, 24					; 00000018H
	fstp	DWORD PTR [esp+20]
	add	ecx, -8					; fffffff8H
	fld	DWORD PTR _dirtol$[esp+72]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+72]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+72]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _expy$[esp+72]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _expx$[esp+72]
	fstp	DWORD PTR [esp]

; 1260 : 				return pCellLayer[(eiy - 1) * T.CellNumX + eix].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
$LN23@FindGrain@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1266 : 	}

	add	esp, 20					; 00000014H
	ret	40					; 00000028H
$LN7@FindGrain@2:

; 1254 : 			else if (fix > 0.0f && eix < (T.CellNumX - 1))

	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN1@FindGrain@2
	add	ebp, -1
	cmp	ebx, ebp
	jge	$LN1@FindGrain@2

; 1255 : 				return pCellLayer[eiy * T.CellNumX + eix + 1].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	fld	DWORD PTR _yshadowtol$[esp+32]
	mov	eax, DWORD PTR _pBottomShadow$[esp+32]
	mov	ecx, DWORD PTR _pTopShadow$[esp+32]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _xshadowtol$[esp+40]
	fstp	DWORD PTR [esp]
	push	eax
	fld	DWORD PTR [esi+168]
	push	ecx
	mov	ecx, DWORD PTR tv398[esp+52]
	sub	esp, 24					; 00000018H
	fstp	DWORD PTR [esp+20]
	add	ecx, 8
	fld	DWORD PTR _dirtol$[esp+72]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+72]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+72]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _expy$[esp+72]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _expx$[esp+72]
	fstp	DWORD PTR [esp]

; 1260 : 				return pCellLayer[(eiy - 1) * T.CellNumX + eix].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1266 : 	}

	add	esp, 20					; 00000014H
	ret	40					; 00000028H
$LN37@FindGrain@2:

; 1250 : 		if (fabs(fix) >= fabs(fiy))

	fstp	ST(1)

; 1256 : 			}
; 1257 : 		else
; 1258 : 		{
; 1259 : 			if (fiy < 0.0f && eiy > 0)

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@FindGrain@2
	test	edi, edi
	jle	SHORT $LN3@FindGrain@2

; 1260 : 				return pCellLayer[(eiy - 1) * T.CellNumX + eix].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	mov	edx, DWORD PTR _pBottomShadow$[esp+32]
	fstp	ST(0)
	mov	eax, DWORD PTR _pTopShadow$[esp+32]
	fstp	ST(0)
	fld	DWORD PTR _yshadowtol$[esp+32]
	mov	ecx, DWORD PTR _pCellLayer$[esp+32]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	add	edi, -1
	fld	DWORD PTR _xshadowtol$[esp+40]
	imul	edi, ebp
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [esi+168]
	push	edx
	push	eax
	sub	esp, 24					; 00000018H
	add	edi, ebx
	lea	ecx, DWORD PTR [ecx+edi*8]
	fstp	DWORD PTR [esp+20]
	fld	DWORD PTR _dirtol$[esp+72]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+72]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+72]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _expy$[esp+72]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _expx$[esp+72]
	fstp	DWORD PTR [esp]
	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1266 : 	}

	add	esp, 20					; 00000014H
	ret	40					; 00000028H
$LN3@FindGrain@2:

; 1261 : 			else if (fiy > 0.0f && eiy < (T.CellNumX - 1))

	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@FindGrain@2
	lea	edx, DWORD PTR [ebp-1]
	cmp	edi, edx
	jge	SHORT $LN1@FindGrain@2

; 1262 : 				return pCellLayer[(eiy + 1) * T.CellNumX + eix].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	fld	DWORD PTR _yshadowtol$[esp+32]
	mov	eax, DWORD PTR _pBottomShadow$[esp+32]
	mov	ecx, DWORD PTR _pTopShadow$[esp+32]
	mov	edx, DWORD PTR _pCellLayer$[esp+32]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	add	edi, 1
	fld	DWORD PTR _xshadowtol$[esp+40]
	imul	edi, ebp
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [esi+168]
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	add	edi, ebx
	lea	ecx, DWORD PTR [edx+edi*8]
	fstp	DWORD PTR [esp+20]
	fld	DWORD PTR _dirtol$[esp+72]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+72]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+72]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _expy$[esp+72]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _expx$[esp+72]
	fstp	DWORD PTR [esp]
	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1266 : 	}

	add	esp, 20					; 00000014H
	ret	40					; 00000028H
$LN34@FindGrain@2:

; 1244 : 	if (eiy >= 0 && eiy < T.CellNumY)

	fstp	ST(0)
	fstp	ST(0)
$LN1@FindGrain@2:
	pop	edi
	pop	esi
	pop	ebp

; 1263 : 			}
; 1264 : 		}
; 1265 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1266 : 	}

	add	esp, 20					; 00000014H
	ret	40					; 00000028H
$LN28@FindGrain@2:
	pop	esi

; 1242 : 	if (eix < 0 || eix >= T.CellNumX) return 0;

	fstp	ST(0)
	pop	ebp
	xor	eax, eax
	pop	ebx

; 1266 : 	}

	add	esp, 20					; 00000014H
	ret	40					; 00000028H
?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ENDP ; CSmartTrackerClass::FindGrain
_TEXT	ENDS
PUBLIC	?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z ; CSmartTrackerClass::FindGrains
; Function compile flags: /Ogtpy
;	COMDAT ?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z
_TEXT	SEGMENT
tv656 = -148						; size = 4
tv650 = -148						; size = 4
_eiy$ = -148						; size = 4
_fiy$ = -144						; size = 4
tv800 = -140						; size = 4
tv512 = -140						; size = 4
_fix$ = -136						; size = 4
_eix$ = -132						; size = 4
_Dist$ = -128						; size = 64
_pOut$ = -64						; size = 64
_expx$ = 8						; size = 4
_expy$ = 12						; size = 4
_pCellLayer$ = 16					; size = 4
_dirx$ = 20						; size = 4
_diry$ = 24						; size = 4
_dirtol$ = 28						; size = 4
_pGrainDest$ = 32					; size = 4
_maxmult$ = 36						; size = 4
?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z PROC ; CSmartTrackerClass::FindGrains, COMDAT
; _this$ = ecx

; 1269 : {

	sub	esp, 148				; 00000094H
	push	ebx

; 1270 : 
; 1271 : #define MAXMULT 16
; 1272 : 
; 1273 : 	IntGrain *pOut[MAXMULT];
; 1274 : 	float Dist[MAXMULT];
; 1275 : 	if (maxmult > MAXMULT) maxmult = MAXMULT;

	mov	ebx, DWORD PTR _maxmult$[esp+148]
	cmp	ebx, 16					; 00000010H
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	jle	SHORT $LN18@FindGrains@2
	mov	ebx, 16					; 00000010H
$LN18@FindGrains@2:

; 1276 : 	int i;
; 1277 : 	for (i = 0; i < maxmult; Dist[i++] = T.AlignTol);

	xor	eax, eax
	cmp	ebx, 4
	jl	SHORT $LC34@FindGrains@2
	lea	ecx, DWORD PTR [ebx-3]
	npad	9
$LL35@FindGrains@2:
	fld	DWORD PTR [esi+168]
	add	eax, 4
	cmp	eax, ecx
	fstp	DWORD PTR _Dist$[esp+eax*4+148]
	fld	DWORD PTR [esi+168]
	fstp	DWORD PTR _Dist$[esp+eax*4+152]
	fld	DWORD PTR [esi+168]
	fstp	DWORD PTR _Dist$[esp+eax*4+156]
	fld	DWORD PTR [esi+168]
	fstp	DWORD PTR _Dist$[esp+eax*4+160]
	jl	SHORT $LL35@FindGrains@2
$LC34@FindGrains@2:
	cmp	eax, ebx
	jge	SHORT $LC17@FindGrains@2
	fld	DWORD PTR [esi+168]
	mov	ecx, ebx
	fstp	DWORD PTR tv800[esp+164]
	lea	edi, DWORD PTR _Dist$[esp+eax*4+164]
	sub	ecx, eax
	mov	eax, DWORD PTR tv800[esp+164]
	rep stosd
$LC17@FindGrains@2:

; 1278 : 	float fix, fiy;
; 1279 : 	int eix = (int)(fix = ((expx - T.Win.Xmin) / T.DxCell));

	fld	DWORD PTR _expx$[esp+160]
	fld	ST(0)
	fsub	DWORD PTR [esi+980]
	fdiv	DWORD PTR [esi+996]
	fstp	DWORD PTR _fix$[esp+164]
	fld	DWORD PTR _fix$[esp+164]
	call	__ftol2_sse
	mov	ebp, eax

; 1280 : 	if (eix < 0 || eix >= T.CellNumX) return 0;

	test	ebp, ebp
	mov	DWORD PTR _eix$[esp+164], ebp
	jl	$LN41@FindGrains@2
	cmp	ebp, DWORD PTR [esi+152]
	jge	$LN41@FindGrains@2

; 1281 : 	int eiy = (int)(fiy = ((expy - T.Win.Ymin) / T.DyCell));

	fld	DWORD PTR _expy$[esp+160]
	fld	ST(0)
	fsub	DWORD PTR [esi+988]
	fdiv	DWORD PTR [esi+1000]
	fstp	DWORD PTR _fiy$[esp+164]
	fld	DWORD PTR _fiy$[esp+164]
	call	__ftol2_sse
	mov	edi, eax

; 1282 : 	if (eiy >= 0 && eiy < T.CellNumY)

	test	edi, edi
	mov	DWORD PTR _eiy$[esp+164], edi
	jl	$LN47@FindGrains@2
	cmp	edi, DWORD PTR [esi+156]
	jge	$LN47@FindGrains@2

; 1283 : 	{
; 1284 : 		pCellLayer[eiy * T.CellNumX + eix].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	mov	eax, DWORD PTR [esi+152]
	fld	DWORD PTR [esi+168]
	mov	ecx, DWORD PTR _pCellLayer$[esp+160]
	imul	eax, edi
	add	eax, ebp
	push	ebx
	lea	ecx, DWORD PTR [ecx+eax*8]
	lea	edx, DWORD PTR _Dist$[esp+168]
	push	edx
	lea	eax, DWORD PTR _pOut$[esp+172]
	push	eax
	sub	esp, 24					; 00000018H
	mov	DWORD PTR tv512[esp+200], ecx
	fstp	DWORD PTR [esp+20]
	fld	DWORD PTR _dirtol$[esp+196]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+196]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+196]
	fstp	DWORD PTR [esp+8]
	fstp	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	call	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains

; 1285 : 		fix -= (0.5f + eix);

	fild	DWORD PTR _eix$[esp+164]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fsubr	DWORD PTR _fix$[esp+164]
	fstp	DWORD PTR _fix$[esp+164]

; 1286 : 		fiy -= (0.5f + eiy);

	fild	DWORD PTR _eiy$[esp+164]
	faddp	ST(1), ST(0)
	fsubr	DWORD PTR _fiy$[esp+164]
	fstp	DWORD PTR _fiy$[esp+164]

; 1287 : 		if (fabs(fix) >= fabs(fiy))

	fld	DWORD PTR _fix$[esp+164]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv656[esp+164]
	fld	DWORD PTR tv656[esp+164]
	fld	DWORD PTR _fiy$[esp+164]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv650[esp+164]
	fld	DWORD PTR tv650[esp+164]
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jp	$LN50@FindGrains@2
	fstp	ST(0)

; 1288 : 		{
; 1289 : 			if (fix < 0.0f && eix > 0)

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@FindGrains@2
	test	ebp, ebp
	jle	SHORT $LN10@FindGrains@2
	fstp	ST(0)

; 1290 : 				pCellLayer[eiy * T.CellNumX + eix - 1].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	push	ebx
	fstp	ST(0)
	lea	ecx, DWORD PTR _Dist$[esp+168]
	fld	DWORD PTR [esi+168]
	push	ecx
	mov	ecx, DWORD PTR tv512[esp+172]
	lea	edx, DWORD PTR _pOut$[esp+172]
	push	edx
	sub	esp, 24					; 00000018H
	fstp	DWORD PTR [esp+20]
	add	ecx, -8					; fffffff8H
	fld	DWORD PTR _dirtol$[esp+196]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+196]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+196]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _expy$[esp+196]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _expx$[esp+196]
	fstp	DWORD PTR [esp]
	call	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains
	jmp	$LN36@FindGrains@2
$LN10@FindGrains@2:

; 1291 : 			else if (fix > 0.0f && eix < (T.CellNumX - 1))

	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN36@FindGrains@2
	mov	eax, DWORD PTR [esi+152]
	add	eax, -1
	cmp	ebp, eax
	jge	$LN36@FindGrains@2

; 1292 : 				pCellLayer[eiy * T.CellNumX + eix + 1].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	fld	DWORD PTR [esi+168]
	push	ebx
	lea	eax, DWORD PTR _Dist$[esp+168]
	push	eax
	lea	ecx, DWORD PTR _pOut$[esp+172]
	push	ecx
	mov	ecx, DWORD PTR tv512[esp+176]
	sub	esp, 24					; 00000018H
	fstp	DWORD PTR [esp+20]
	add	ecx, 8
	fld	DWORD PTR _dirtol$[esp+196]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+196]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+196]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _expy$[esp+196]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _expx$[esp+196]
	fstp	DWORD PTR [esp]
	call	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains

; 1293 : 			}
; 1294 : 		else

	jmp	$LN36@FindGrains@2
$LN50@FindGrains@2:

; 1287 : 		if (fabs(fix) >= fabs(fiy))

	fstp	ST(1)

; 1295 : 		{
; 1296 : 			if (fiy < 0.0f && eiy > 0)

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@FindGrains@2
	test	edi, edi
	jle	SHORT $LN6@FindGrains@2

; 1297 : 				pCellLayer[(eiy - 1) * T.CellNumX + eix].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	mov	ecx, DWORD PTR _pCellLayer$[esp+160]
	fstp	ST(0)
	fstp	ST(0)
	push	ebx
	fld	DWORD PTR [esi+168]
	lea	edx, DWORD PTR _Dist$[esp+168]
	push	edx
	lea	eax, DWORD PTR _pOut$[esp+172]
	push	eax
	sub	esp, 24					; 00000018H
	fstp	DWORD PTR [esp+20]
	add	edi, -1
	imul	edi, DWORD PTR [esi+152]
	fld	DWORD PTR _dirtol$[esp+196]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+196]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+196]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _expy$[esp+196]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _expx$[esp+196]
	add	edi, ebp
	lea	ecx, DWORD PTR [ecx+edi*8]
	fstp	DWORD PTR [esp]
	call	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains
	jmp	$LN36@FindGrains@2
$LN6@FindGrains@2:

; 1298 : 			else if (fiy > 0.0f && eiy < (T.CellNumY - 1))

	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN36@FindGrains@2
	mov	eax, DWORD PTR [esi+156]
	add	eax, -1
	cmp	edi, eax
	jge	SHORT $LN36@FindGrains@2

; 1299 : 				pCellLayer[(eiy + 1) * T.CellNumX + eix].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	fld	DWORD PTR [esi+168]
	mov	ecx, DWORD PTR _pCellLayer$[esp+160]
	push	ebx
	lea	edx, DWORD PTR _Dist$[esp+168]
	push	edx
	lea	eax, DWORD PTR _pOut$[esp+172]
	push	eax
	sub	esp, 24					; 00000018H
	fstp	DWORD PTR [esp+20]
	add	edi, 1
	imul	edi, DWORD PTR [esi+152]
	fld	DWORD PTR _dirtol$[esp+196]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _diry$[esp+196]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _dirx$[esp+196]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _expy$[esp+196]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _expx$[esp+196]
	add	edi, ebp
	lea	ecx, DWORD PTR [ecx+edi*8]
	fstp	DWORD PTR [esp]
	call	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains
	jmp	SHORT $LN36@FindGrains@2
$LN47@FindGrains@2:

; 1282 : 	if (eiy >= 0 && eiy < T.CellNumY)

	fstp	ST(0)
	fstp	ST(0)
$LN36@FindGrains@2:

; 1300 : 			}
; 1301 : 		}
; 1302 : 	for (i = 0; i < maxmult && Dist[i] < T.AlignTol; i++) pGrainDest[i] = pOut[i];

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN1@FindGrains@2
	mov	edx, DWORD PTR _pGrainDest$[esp+160]
	npad	6
$LL3@FindGrains@2:
	fld	DWORD PTR _Dist$[esp+ecx*4+164]
	fld	DWORD PTR [esi+168]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@FindGrains@2
	mov	eax, DWORD PTR _pOut$[esp+ecx*4+164]
	mov	DWORD PTR [edx+ecx*4], eax
	add	ecx, 1
	cmp	ecx, ebx
	jl	SHORT $LL3@FindGrains@2
$LN1@FindGrains@2:
	pop	edi
	pop	esi
	pop	ebp

; 1303 : 	return i;	

	mov	eax, ecx
	pop	ebx

; 1304 : 	}

	add	esp, 148				; 00000094H
	ret	32					; 00000020H
$LN41@FindGrains@2:
	pop	edi

; 1280 : 	if (eix < 0 || eix >= T.CellNumX) return 0;

	fstp	ST(0)
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 1304 : 	}

	add	esp, 148				; 00000094H
	ret	32					; 00000020H
?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z ENDP ; CSmartTrackerClass::FindGrains
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z ; CSmartTrackerClass::PartialGetTracks2
EXTRN	__imp__free:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__malloc:PROC
;	COMDAT __real@4024000000000000
; File f:\program files\microsoft visual studio 8\vc\include\math.h
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
; Function compile flags: /Ogtpy
; File d:\sysal2\smarttracker8.5\smarttrackerclass.cpp
CONST	ENDS
;	COMDAT ?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z
_TEXT	SEGMENT
tv2580 = -352						; size = 4
tv2573 = -352						; size = 4
tv2569 = -352						; size = 4
tv2558 = -352						; size = 4
tv2551 = -352						; size = 4
tv2547 = -352						; size = 4
tv2524 = -352						; size = 4
tv2473 = -352						; size = 4
tv2472 = -352						; size = 4
tv2254 = -352						; size = 4
_j$131529 = -352					; size = 4
_seqlength$131519 = -352				; size = 4
_dz$131441 = -352					; size = 4
_ExpX$ = -352						; size = 4
_cdz$131435 = -352					; size = 4
_ldz$131434 = -352					; size = 4
tv2423 = -348						; size = 4
tv2412 = -348						; size = 4
tv2393 = -348						; size = 4
tv2340 = -348						; size = 4
tv2339 = -348						; size = 4
tv2252 = -348						; size = 4
_dz$131518 = -348					; size = 4
_cdz$131512 = -348					; size = 4
_ldz$131511 = -348					; size = 4
_pBE$131414 = -348					; size = 4
_j$131452 = -344					; size = 4
_seqlength$131442 = -344				; size = 4
_ExpY$ = -344						; size = 4
_Slope2$ = -344						; size = 4
_EndLayer$ = -340					; size = 4
tv1493 = -336						; size = 4
_ny$ = -332						; size = 4
_CellSpace$ = -328					; size = 4
tv2351 = -324						; size = 4
_pTempGrains$ = -324					; size = 4
_wx$ = -320						; size = 4
_dirtol$ = -316						; size = 4
_SlopeY$ = -312						; size = 4
_DirY$ = -308						; size = 4
_ZLayer$ = -304						; size = 4
_DirX$ = -300						; size = 4
_SlopeX$ = -296						; size = 4
tv2895 = -292						; size = 4
tv2465 = -292						; size = 4
_ir$ = -288						; size = 4
tv2883 = -284						; size = 4
tv2541 = -284						; size = 4
_tz$ = -280						; size = 4
tv2829 = -276						; size = 4
tv2638 = -276						; size = 4
_maxix$ = -272						; size = 4
tv2609 = -268						; size = 4
_pT$131479 = -268					; size = 4
_maxiy$ = -264						; size = 4
_minix$ = -260						; size = 4
tv1539 = -256						; size = 4
_lay$ = -256						; size = 4
_miniy$ = -252						; size = 4
_bx$ = -248						; size = 4
_StartLayer$ = -244					; size = 4
_idz$ = -240						; size = 4
_SlopeS$ = -236						; size = 4
_ifound$ = -232						; size = 4
_iix$ = -228						; size = 4
_iiy$ = -224						; size = 4
_itr$ = -220						; size = 4
tv2923 = -216						; size = 4
_pT$131400 = -216					; size = 4
_ix$ = -212						; size = 4
tv2756 = -208						; size = 4
tv1541 = -208						; size = 4
_pTE$131480 = -204					; size = 4
_pB$131413 = -204					; size = 4
tv2597 = -200						; size = 4
_pB$131492 = -200					; size = 4
_countTrials$ = -196					; size = 4
_countSlopeY$ = -192					; size = 4
_countIterations$ = -188				; size = 4
_countAccepted$ = -184					; size = 4
_countFindGrains$ = -180				; size = 4
_countSlopeX$ = -176					; size = 4
_countPossible$ = -172					; size = 4
_bp$131467 = -168					; size = 4
_pTE$131401 = -168					; size = 4
tv1543 = -164						; size = 4
_CellsInLayer$ = -160					; size = 4
tv1579 = -156						; size = 4
_pBE$131493 = -152					; size = 4
_bp$131388 = -152					; size = 4
_ISlopeS$ = -148					; size = 4
_MaxSlope$ = -144					; size = 4
_TimeLimit$ = -140					; size = 4
_avgdz$ = -136						; size = 4
_td$ = -132						; size = 4
_tinf$ = -128						; size = 4
_tsl$ = -124						; size = 4
_MaxSlope2$ = -120					; size = 4
_gt$131484 = -116					; size = 36
_gt$131405 = -116					; size = 36
_gb$131499 = -80					; size = 36
_gb$131420 = -80					; size = 36
_tr$131463 = -44					; size = 44
_tr$131384 = -44					; size = 44
_AR$ = 8						; size = 4
?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z PROC ; CSmartTrackerClass::PartialGetTracks2, COMDAT
; _this$ = ecx

; 1307 : {

	sub	esp, 352				; 00000160H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 1308 : 	int countIterations = 0, countSlopeX = 0, countSlopeY = 0, countTrials = 0, countFindGrains = 0, countPossible = 0, countAccepted = 0;
; 1309 : 	int nx, ny, bx, wx;
; 1310 : 	int lay;
; 1311 : 	int itr, ibr;
; 1312 : 	int NTracks = 0;
; 1313 : 	float *ZLayer = T.ZLayer;
; 1314 : 	float tz;
; 1315 : 	int CellsInLayer = T.CellsInLayer;

	mov	ecx, DWORD PTR [ebp+976]

; 1316 : 	Cell *CellSpace = T.CellSpace;
; 1317 : 	float MaxSlope = T.MaxSlope;

	fld	DWORD PTR [ebp+896]
	mov	eax, DWORD PTR [ebp+964]
	fstp	DWORD PTR _MaxSlope$[esp+360]
	mov	edx, DWORD PTR [ebp+972]

; 1318 : 	float MinSlope = T.MinSlope;
; 1319 : 	float MaxSlope2 = MaxSlope * MaxSlope;

	fld	DWORD PTR _MaxSlope$[esp+360]
	mov	DWORD PTR _ZLayer$[esp+360], eax
	fmul	ST(0), ST(0)
	mov	DWORD PTR _CellsInLayer$[esp+360], ecx

; 1320 : 	float aligntol2 = T.AlignTol * T.AlignTol;
; 1321 : 	int TimeLimit = AR.TimeLimit;

	mov	ecx, DWORD PTR _AR$[esp+356]
	mov	eax, DWORD PTR [ecx+36]
	fstp	DWORD PTR _MaxSlope2$[esp+360]
	mov	DWORD PTR _TimeLimit$[esp+360], eax

; 1322 : 
; 1323 : 	int ix, iy, iix, iiy, eix, eiy;
; 1324 : 	int minix, maxix, miniy, maxiy;
; 1325 : 	float Slope2, SlopeS, ISlopeS;
; 1326 : 	float SlopeX, SlopeY, ExpX, ExpY, DirX, DirY;
; 1327 : 	float ShadowXTol, ShadowYTol;
; 1328 : 	float CurrDeltaX, CurrDeltaY;
; 1329 : 	float avgds2;
; 1330 : 	float dirtol;
; 1331 : 	int it, ib, ir, ifound;
; 1332 : 	float idz;
; 1333 : 
; 1334 : 	ShadowXTol = T.DiscardShadowSigma * T.ShadowSigmaX;
; 1335 : 	ShadowYTol = T.DiscardShadowSigma * T.ShadowSigmaY;
; 1336 : 
; 1337 : 	bx = T.CellNumX / T.Processors * AR.ThreadIndex;

	mov	eax, DWORD PTR [ebp+152]
	mov	DWORD PTR tv1493[esp+360], eax
	push	esi
	mov	esi, DWORD PTR [ebp+900]
	mov	DWORD PTR _CellSpace$[esp+364], edx
	cdq
	idiv	esi
	mov	ecx, DWORD PTR [ecx+4]
	push	edi
	xor	edi, edi

; 1338 : 	nx = T.CellNumX;
; 1339 : 	wx = (AR.ThreadIndex == T.Processors - 1) ? T.CellNumX : (T.CellNumX / T.Processors * (AR.ThreadIndex + 1));

	add	esi, -1
	mov	DWORD PTR _countIterations$[esp+368], edi
	mov	DWORD PTR _countSlopeX$[esp+368], edi
	mov	DWORD PTR _countSlopeY$[esp+368], edi
	mov	DWORD PTR _countTrials$[esp+368], edi
	mov	DWORD PTR _countFindGrains$[esp+368], edi
	mov	DWORD PTR _countPossible$[esp+368], edi
	mov	DWORD PTR _countAccepted$[esp+368], edi
	imul	eax, ecx
	cmp	ecx, esi
	mov	DWORD PTR _bx$[esp+368], eax
	jne	SHORT $LN116@PartialGet
	mov	ecx, DWORD PTR [ebp+152]
	mov	DWORD PTR _wx$[esp+368], ecx
	jmp	SHORT $LN117@PartialGet
$LN116@PartialGet:
	mov	eax, DWORD PTR [ebp+152]
	cdq
	idiv	DWORD PTR [ebp+900]
	add	ecx, 1
	imul	eax, ecx
	mov	DWORD PTR _wx$[esp+368], eax
$LN117@PartialGet:

; 1340 : 	ny = T.CellNumY;
; 1341 : 
; 1342 : 	for (lay = 0; lay < T.Layer; lay++)

	cmp	DWORD PTR [ebp+1016], edi
	mov	edx, DWORD PTR [ebp+156]
	mov	DWORD PTR _ny$[esp+368], edx
	mov	DWORD PTR _lay$[esp+368], edi
	jle	$LN111@PartialGet
	mov	eax, DWORD PTR _CellSpace$[esp+368]
	mov	DWORD PTR tv2351[esp+368], eax
	npad	9
$LL113@PartialGet:

; 1345 : 		for (iy = 0; iy < ny; iy++)

	cmp	DWORD PTR _ny$[esp+368], 0
	mov	edi, DWORD PTR tv2351[esp+368]
	jle	SHORT $LN112@PartialGet

; 1343 : 	{		
; 1344 : 		Cell *pCellsL = CellSpace + lay * CellsInLayer;

	mov	ebx, DWORD PTR _ny$[esp+368]
	npad	1
$LL110@PartialGet:

; 1346 : 		{
; 1347 : 			Cell *pCellsR = pCellsL + bx;

	mov	eax, DWORD PTR _bx$[esp+368]

; 1348 : 			for (ix = bx; ix < wx; ix++)

	cmp	eax, DWORD PTR _wx$[esp+368]
	lea	edx, DWORD PTR [edi+eax*8]
	jge	SHORT $LN105@PartialGet
	mov	esi, DWORD PTR _wx$[esp+368]
	sub	esi, eax
$LL107@PartialGet:

; 1349 : 			{
; 1350 : 				IntGrain *pG = pCellsR->FirstG;
; 1351 : 				IntGrain *pGEnd = pG + pCellsR->Free;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	lea	ecx, DWORD PTR [eax+ecx*4]

; 1352 : 				while (pG < pGEnd)

	cmp	eax, ecx
	jae	SHORT $LN103@PartialGet
$LL104@PartialGet:

; 1353 : 				{
; 1354 : 					pG->pTrack2 = 0;

	mov	DWORD PTR [eax+16], 0

; 1355 : 					pG->TrackLength = 0;

	mov	DWORD PTR [eax+12], 0

; 1356 : 					pG++;

	add	eax, 36					; 00000024H
	cmp	eax, ecx
	jb	SHORT $LL104@PartialGet
$LN103@PartialGet:

; 1357 : 					}
; 1358 : 				pCellsR++;

	add	edx, 8
	sub	esi, 1
	jne	SHORT $LL107@PartialGet
$LN105@PartialGet:

; 1359 : 				}
; 1360 : 			pCellsL += nx;

	mov	eax, DWORD PTR tv1493[esp+368]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	add	edi, eax
	sub	ebx, 1
	jne	SHORT $LL110@PartialGet
$LN112@PartialGet:

; 1340 : 	ny = T.CellNumY;
; 1341 : 
; 1342 : 	for (lay = 0; lay < T.Layer; lay++)

	mov	ecx, DWORD PTR _CellsInLayer$[esp+368]
	mov	eax, DWORD PTR _lay$[esp+368]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR tv2351[esp+368], ecx
	add	eax, 1
	cmp	eax, DWORD PTR [ebp+1016]
	mov	DWORD PTR _lay$[esp+368], eax
	jl	$LL113@PartialGet
$LN111@PartialGet:

; 1361 : 			}
; 1362 : 		}
; 1363 : 
; 1364 : 	AR.Found = 0;

	mov	eax, DWORD PTR _AR$[esp+364]

; 1365 : 	if (AR.MaxTracks <= 0) return S_OK;

	cmp	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	jle	$LN278@PartialGet

; 1366 : 
; 1367 : 	int EndLayer = AR.EndLayer;

	mov	esi, DWORD PTR [eax+32]

; 1368 : 	int StartLayer = AR.StartLayer;

	mov	edi, DWORD PTR [eax+28]

; 1369 : 	if (EndLayer >= T.Layer) EndLayer = T.Layer - 1;

	mov	eax, DWORD PTR [ebp+1016]
	cmp	esi, eax
	mov	DWORD PTR _EndLayer$[esp+368], esi
	mov	DWORD PTR _StartLayer$[esp+368], edi
	jl	SHORT $LN101@PartialGet
	lea	esi, DWORD PTR [eax-1]
	mov	DWORD PTR _EndLayer$[esp+368], esi
$LN101@PartialGet:

; 1370 : 
; 1371 : 	IntGrain **pTempGrains = (IntGrain **)malloc(sizeof(IntGrain *) * (EndLayer + 1) * T.InitialMultiplicity);

	lea	edx, DWORD PTR [esi+1]
	imul	edx, DWORD PTR [ebp+932]
	add	edx, edx
	add	edx, edx
	push	edx
	call	DWORD PTR __imp__malloc
	mov	DWORD PTR _pTempGrains$[esp+372], eax

; 1372 : 
; 1373 : 	float avgdz = (ZLayer[StartLayer] - ZLayer[EndLayer]) / (EndLayer - StartLayer);

	mov	eax, esi
	sub	eax, edi
	mov	DWORD PTR tv1579[esp+372], eax
	mov	eax, DWORD PTR _ZLayer$[esp+372]
	add	esp, 4
	fld	DWORD PTR [eax+edi*4]
	fsub	DWORD PTR [eax+esi*4]
	fidiv	DWORD PTR tv1579[esp+368]
	fstp	DWORD PTR _avgdz$[esp+368]

; 1374 : 	float avgdz2 = avgdz * avgdz;
; 1375 : 			
; 1376 : 	float tsl = (T.NptMin01 == T.NptMinH) ? 0.0 : (10.0f * (T.NptMinV - T.NptMin01) / (T.NptMin01 - T.NptMinH));

	fld	DWORD PTR [ebp+888]
	fld	DWORD PTR [ebp+884]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN118@PartialGet
	fldz
	jmp	SHORT $LN119@PartialGet
$LN118@PartialGet:
	fld	DWORD PTR [ebp+880]
	fsub	DWORD PTR [ebp+888]
	fmul	QWORD PTR __real@4024000000000000
	fld	DWORD PTR [ebp+888]
	fsub	DWORD PTR [ebp+884]
	fdivp	ST(1), ST(0)
$LN119@PartialGet:
	fstp	DWORD PTR _tsl$[esp+368]

; 1377 : 	float tinf = (float)(T.NptMinH);
; 1378 : 	float td = (float)(T.NptMinV - T.NptMinH);
; 1379 : 
; 1380 : 	if (T.PresetSlope)
; 1381 : 	{
; 1382 : 
; 1383 : 		for (itr = 0; itr < T.TrialCount; itr++)

	xor	eax, eax
	cmp	BYTE PTR [ebp+940], al
	fld	DWORD PTR [ebp+884]
	fstp	DWORD PTR _tinf$[esp+368]
	mov	DWORD PTR _itr$[esp+368], eax
	fld	DWORD PTR [ebp+880]
	fsub	DWORD PTR [ebp+884]
	fstp	DWORD PTR _td$[esp+368]
	je	$LN100@PartialGet
	cmp	DWORD PTR [ebp+172], eax
	jle	$LN46@PartialGet
	mov	ebx, DWORD PTR _bx$[esp+368]
	mov	DWORD PTR tv2609[esp+368], eax
	lea	eax, DWORD PTR [ebp+176]
	mov	DWORD PTR tv2638[esp+368], eax
	npad	15
$LL99@PartialGet:

; 1384 : 		{
; 1385 : 			Trial tr = T.Trials[itr];

	mov	esi, DWORD PTR tv2638[esp+368]
	mov	ecx, 11					; 0000000bH
	lea	edi, DWORD PTR _tr$131384[esp+368]
	rep movsd

; 1386 : 			if (tr.TopLayer < StartLayer || tr.BottomLayer > EndLayer) continue;

	mov	eax, DWORD PTR _tr$131384[esp+368]
	cmp	eax, DWORD PTR _StartLayer$[esp+368]
	jl	$LN98@PartialGet
	mov	ecx, DWORD PTR _tr$131384[esp+372]
	cmp	ecx, DWORD PTR _EndLayer$[esp+368]
	jg	$LN98@PartialGet

; 1387 : 			Cell *tp = CellsInLayer * tr.TopLayer + CellSpace;

	mov	esi, DWORD PTR _CellsInLayer$[esp+368]
	mov	edi, DWORD PTR _CellSpace$[esp+368]
	mov	edx, eax
	imul	edx, esi
	lea	edx, DWORD PTR [edi+edx*8]

; 1388 : 			Cell *bp = CellsInLayer * tr.BottomLayer + CellSpace;

	mov	edi, ecx
	imul	edi, esi

; 1389 : 			tz = ZLayer[tr.TopLayer];
; 1390 : 			idz = 1.0f / (tz - ZLayer[tr.BottomLayer]);
; 1391 : 	
; 1392 : 			for (ix = bx; ix < wx; ix++)

	cmp	ebx, DWORD PTR _wx$[esp+368]
	mov	esi, DWORD PTR _CellSpace$[esp+368]
	lea	esi, DWORD PTR [esi+edi*8]
	mov	DWORD PTR _bp$131388[esp+368], esi
	mov	esi, DWORD PTR _ZLayer$[esp+368]
	fld	DWORD PTR [esi+eax*4]
	mov	eax, ebx
	fstp	DWORD PTR _tz$[esp+368]
	mov	DWORD PTR _ix$[esp+368], eax
	fld	DWORD PTR _tz$[esp+368]
	fsub	DWORD PTR [esi+ecx*4]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _idz$[esp+368]
	jge	$LN98@PartialGet
	lea	ebx, DWORD PTR [edx+ebx*8]
	mov	DWORD PTR tv2597[esp+368], ebx
$LL236@PartialGet:
	xor	esi, esi
	lea	ecx, DWORD PTR [eax-1]

; 1393 : 			{
; 1394 : 				ifound = 0;
; 1395 : 				minix = ix - 1; if (minix < 0) minix = 0;

	cmp	ecx, esi
	mov	DWORD PTR _ifound$[esp+368], esi
	mov	DWORD PTR _minix$[esp+368], ecx
	jge	SHORT $LN91@PartialGet
	mov	DWORD PTR _minix$[esp+368], esi
$LN91@PartialGet:

; 1396 : 				maxix = ix + 1; if (maxix >= nx) maxix = nx - 1;

	mov	edx, DWORD PTR tv1493[esp+368]
	lea	ecx, DWORD PTR [eax+1]
	mov	eax, ecx
	cmp	eax, edx
	mov	DWORD PTR tv1539[esp+368], ecx
	mov	DWORD PTR _maxix$[esp+368], eax
	jl	SHORT $LN90@PartialGet
	add	edx, -1
	mov	DWORD PTR _maxix$[esp+368], edx
$LN90@PartialGet:

; 1397 : 				for (iy = 0; iy < ny; iy++)

	xor	eax, eax
	cmp	DWORD PTR _ny$[esp+368], esi
	jle	$LN93@PartialGet
	mov	ecx, DWORD PTR tv1493[esp+368]
	lea	edx, DWORD PTR [ecx*8]
	mov	DWORD PTR tv1541[esp+368], edx
	mov	DWORD PTR tv2541[esp+368], ebx
	npad	6
$LL235@PartialGet:
	mov	ecx, DWORD PTR _ny$[esp+368]
	lea	edx, DWORD PTR [eax-1]

; 1398 : 				{
; 1399 : 					miniy = iy - 1; if (miniy < 0) miniy = 0;

	test	edx, edx
	mov	DWORD PTR _miniy$[esp+368], edx
	jge	SHORT $LN86@PartialGet
	xor	edx, edx
	mov	DWORD PTR _miniy$[esp+368], edx
$LN86@PartialGet:
	add	eax, 1

; 1400 : 					maxiy = iy + 1; if (maxiy >= ny) maxiy = ny - 1;

	cmp	eax, ecx
	mov	DWORD PTR tv1543[esp+368], eax
	mov	DWORD PTR _maxiy$[esp+368], eax
	jl	SHORT $LN85@PartialGet
	add	ecx, -1
	mov	DWORD PTR _maxiy$[esp+368], ecx
$LN85@PartialGet:

; 1401 : 					Cell &ct = tp[iy * nx + ix];
; 1402 : 					IntGrain *pT = ct.FirstG;

	mov	ecx, DWORD PTR tv2541[esp+368]
	mov	ebx, DWORD PTR [ecx]

; 1403 : 					IntGrain *pTE = ct.FirstG + ct.Free;

	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR [ebx+eax*4]

; 1404 : 					for (;pT < pTE; pT++)

	cmp	ebx, eax
	mov	DWORD PTR _pT$131400[esp+368], ebx
	mov	DWORD PTR _pTE$131401[esp+368], eax
	jae	$LN88@PartialGet
$LL84@PartialGet:

; 1405 : 					{
; 1406 : 						IntGrain gt = *pT;
; 1407 : 						for (iix = minix; iix <= maxix; iix++)

	mov	eax, DWORD PTR _minix$[esp+368]
	mov	ecx, 9
	mov	esi, ebx
	lea	edi, DWORD PTR _gt$131405[esp+368]
	rep movsd
	mov	ecx, DWORD PTR _maxix$[esp+368]
	cmp	eax, ecx
	mov	DWORD PTR _iix$[esp+368], eax
	jg	$LN83@PartialGet
	npad	6
$LL81@PartialGet:

; 1408 : 							for (iiy = miniy; iiy <= maxiy; iiy++)

	cmp	edx, DWORD PTR _maxiy$[esp+368]
	mov	DWORD PTR _iiy$[esp+368], edx
	jg	$LN80@PartialGet
	imul	edx, DWORD PTR tv1493[esp+368]
	add	edx, eax
	mov	eax, DWORD PTR _bp$131388[esp+368]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR tv2465[esp+368], ecx
	jmp	SHORT $LN78@PartialGet
	npad	8
$LL231@PartialGet:
	mov	ecx, DWORD PTR tv2465[esp+368]
$LN78@PartialGet:

; 1409 : 							{
; 1410 : 								Cell &cb = bp[iiy * nx + iix];
; 1411 : 								IntGrain *pB = cb.FirstG;

	mov	eax, DWORD PTR [ecx]

; 1412 : 								IntGrain *pBE = cb.FirstG + cb.Free;

	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	lea	ecx, DWORD PTR [eax+ecx*4]

; 1413 : 								for (;pB < pBE; pB++)

	cmp	eax, ecx
	mov	DWORD PTR _pB$131413[esp+368], eax
	mov	DWORD PTR _pBE$131414[esp+368], ecx
	jae	$LN77@PartialGet
	mov	esi, eax
$LL228@PartialGet:
	mov	ebx, 1

; 1414 : 								{
; 1415 : 									countIterations++;

	add	DWORD PTR _countIterations$[esp+368], ebx

; 1416 : 									if (GetTickCount() > TimeLimit)

	call	DWORD PTR __imp__GetTickCount@0
	cmp	eax, DWORD PTR _TimeLimit$[esp+368]
	ja	$LN193@PartialGet

; 1420 : 										}
; 1421 : 									IntGrain gb = *pB;
; 1422 : 									SlopeX = idz * (gt.Xcm - gb.Xcm);

	fld	DWORD PTR _gt$131405[esp+368]
	mov	ecx, 9
	lea	edi, DWORD PTR _gb$131420[esp+368]
	rep movsd
	fsub	DWORD PTR _gb$131420[esp+368]
	fld	DWORD PTR _idz$[esp+368]
	fld	ST(0)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _SlopeX$[esp+368]

; 1423 : 									if (fabs(SlopeX) >= MaxSlope || fabs(SlopeX - T.PresetSlopeX) > T.PresetSlopeAccX) continue;									

	fld	DWORD PTR _SlopeX$[esp+368]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv2580[esp+368]
	fld	DWORD PTR tv2580[esp+368]
	fld	DWORD PTR _MaxSlope$[esp+368]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jnp	$LN243@PartialGet
	fld	ST(1)
	fsub	DWORD PTR [ebp+944]
	fstp	DWORD PTR tv2573[esp+368]
	fld	DWORD PTR tv2573[esp+368]
	fabs
	fstp	DWORD PTR tv2569[esp+368]
	fld	DWORD PTR tv2569[esp+368]
	fld	DWORD PTR [ebp+952]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	$LN243@PartialGet

; 1424 : 									countSlopeX++;
; 1425 : 									SlopeY = idz * (gt.Ycm - gb.Ycm);

	fld	DWORD PTR _gt$131405[esp+372]
	add	DWORD PTR _countSlopeX$[esp+368], ebx
	fsub	DWORD PTR _gb$131420[esp+372]
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR _SlopeY$[esp+368]

; 1426 : 									if (fabs(SlopeY) >= MaxSlope || fabs(SlopeY - T.PresetSlopeY) > T.PresetSlopeAccY) continue;

	fld	DWORD PTR _SlopeY$[esp+368]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv2558[esp+368]
	fld	DWORD PTR tv2558[esp+368]
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, bl
	je	$LN252@PartialGet
	fld	ST(1)
	fsub	DWORD PTR [ebp+948]
	fstp	DWORD PTR tv2551[esp+368]
	fld	DWORD PTR tv2551[esp+368]
	fabs
	fstp	DWORD PTR tv2547[esp+368]
	fld	DWORD PTR tv2547[esp+368]
	fld	DWORD PTR [ebp+956]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	$LN252@PartialGet

; 1427 : 									Slope2 = SlopeX * SlopeX + SlopeY * SlopeY;
; 1428 : 									countSlopeY++;

	add	DWORD PTR _countSlopeY$[esp+368], ebx
	fmul	ST(0), ST(0)
	fld	ST(1)
$restart$131425:
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _Slope2$[esp+368]

; 1429 : restart:	
; 1430 : 									if (Slope2 < MaxSlope2)

	fld	DWORD PTR _Slope2$[esp+368]
	fld	DWORD PTR _MaxSlope2$[esp+368]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN255@PartialGet

; 1431 : 									{
; 1432 : 										countTrials++;

	add	DWORD PTR _countTrials$[esp+368], ebx

; 1433 : 										SlopeS = sqrt(Slope2);

	call	__CIsqrt
	fstp	DWORD PTR tv2524[esp+368]
	fld	DWORD PTR tv2524[esp+368]
	fstp	DWORD PTR _SlopeS$[esp+368]

; 1434 : 										if (SlopeS > 0.0f) ISlopeS = 1.0f / SlopeS;

	fldz
	fld	DWORD PTR _SlopeS$[esp+368]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN220@PartialGet
	fld	ST(0)
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _ISlopeS$[esp+368]
$LN220@PartialGet:

; 1435 : 										avgds2 = avgdz2 * Slope2;
; 1436 : 										fastGetDirAndTol(SlopeS, ISlopeS, DirX, DirY, dirtol/*, aligntol2, avgds2*/);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN261@PartialGet
	fstp	ST(0)
	fld1
	fstp	DWORD PTR _DirX$[esp+368]
	fstp	DWORD PTR _DirY$[esp+368]
	fld	DWORD PTR [ebp+168]
	jmp	SHORT $LN279@PartialGet
$LN261@PartialGet:
	fstp	ST(1)
	fld	DWORD PTR _ISlopeS$[esp+368]
	fld	ST(0)
	fmul	DWORD PTR _SlopeX$[esp+368]
	fstp	DWORD PTR _DirX$[esp+368]
	fmul	DWORD PTR _SlopeY$[esp+368]
	fstp	DWORD PTR _DirY$[esp+368]
	fmul	DWORD PTR _avgdz$[esp+368]
	fadd	DWORD PTR [ebp+168]
$LN279@PartialGet:

; 1437 : 										//GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);
; 1438 : 	
; 1439 : 										for (ir = 0; ir < tr.TriggerCount; ir++)

	cmp	DWORD PTR _tr$131384[esp+376], 0
	fstp	DWORD PTR _dirtol$[esp+368]
	mov	DWORD PTR _ir$[esp+368], 0
	jle	$LN74@PartialGet
	mov	edi, DWORD PTR _pTempGrains$[esp+368]
	mov	ebx, DWORD PTR _ZLayer$[esp+368]
	npad	9
$LL221@PartialGet:

; 1440 : 										{
; 1441 : 											int TriggerLayer = tr.Triggers[ir];

	mov	edx, DWORD PTR _ir$[esp+368]

; 1442 : 											float ldz = (tz - ZLayer[TriggerLayer]) * idz;

	fld	DWORD PTR _tz$[esp+368]
	mov	esi, DWORD PTR _tr$131384[esp+edx*4+380]
	fsub	DWORD PTR [ebx+esi*4]

; 1443 : 											float cdz = 1.0f - ldz;
; 1444 : 											ExpX = ldz * gb.Xcm + cdz * gt.Xcm;
; 1445 : 											ExpY = ldz * gb.Ycm + cdz * gt.Ycm;
; 1446 : 											eix = (int)((ExpX - T.Win.Xmin) / T.DxCell);
; 1447 : 											eiy = (int)((ExpY - T.Win.Ymin) / T.DyCell);
; 1448 : 											IntGrain *pTrg = CellSpace[(TriggerLayer * ny + eiy) * nx + eix].FindGrain(ExpX, ExpY, DirX, DirY, dirtol, T.AlignTol);

	sub	esp, 24					; 00000018H
	fmul	DWORD PTR _idz$[esp+392]
	fstp	DWORD PTR _ldz$131434[esp+392]
	fld	DWORD PTR _ldz$131434[esp+392]
	fld	ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	fstp	DWORD PTR _cdz$131435[esp+392]
	fld	ST(0)
	fmul	DWORD PTR _gb$131420[esp+392]
	fld	DWORD PTR _cdz$131435[esp+392]
	fld	ST(0)
	fmul	DWORD PTR _gt$131405[esp+392]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _ExpX$[esp+392]
	fld	DWORD PTR _gb$131420[esp+396]
	fmulp	ST(2), ST(0)
	fmul	DWORD PTR _gt$131405[esp+396]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ExpY$[esp+392]
	fld	DWORD PTR [ebp+168]
	fstp	DWORD PTR [esp+20]
	fld	DWORD PTR _dirtol$[esp+392]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _DirY$[esp+392]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _DirX$[esp+392]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _ExpY$[esp+392]
	fst	DWORD PTR [esp+4]
	fld	DWORD PTR _ExpX$[esp+392]
	fst	DWORD PTR [esp]

; 1449 : 											if (pTrg)

	fld	DWORD PTR [ebp+988]
	fsubp	ST(2), ST(0)
	fld	DWORD PTR [ebp+1000]
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fsub	DWORD PTR [ebp+980]
	imul	esi, DWORD PTR _ny$[esp+392]
	fdiv	DWORD PTR [ebp+996]
	add	eax, esi
	imul	eax, DWORD PTR tv1493[esp+392]
	mov	DWORD PTR tv2254[esp+392], eax
	call	__ftol2_sse
	mov	ecx, DWORD PTR tv2254[esp+392]
	add	ecx, eax
	mov	eax, DWORD PTR _CellSpace$[esp+392]
	lea	ecx, DWORD PTR [eax+ecx*8]
	call	?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z ; Cell::FindGrain
	test	eax, eax
	je	$LN62@PartialGet

; 1450 : 											{
; 1451 : 												memset(pTempGrains, 0, T.Layer * sizeof(Grain *) * T.InitialMultiplicity);

	mov	ecx, DWORD PTR [ebp+932]
	imul	ecx, DWORD PTR [ebp+1016]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	edi
	call	_memset

; 1452 : 												float dz;
; 1453 : 												int seqlength = 0;
; 1454 : 												//int seqlength = 3;
; 1455 : /*	
; 1456 : 												pTempGrains[tr.TopLayer] = pT;
; 1457 : 												pTempGrains[tr.BottomLayer] = pB;
; 1458 : 												pTempGrains[TriggerLayer] = pTrg;
; 1459 : */	
; 1460 : 												CurrDeltaX = fabs(avgdz * SlopeX);
; 1461 : 												CurrDeltaY = fabs(avgdz * SlopeY);
; 1462 : /*	
; 1463 : 												for (lay = tr.TopLayer; lay <= tr.BottomLayer; lay++)
; 1464 : 												{
; 1465 : 													dz = ZLayer[lay] - tz;
; 1466 : 													ExpX = dz * SlopeX + gt.Xcm;
; 1467 : 													ExpY = dz * SlopeY + gt.Ycm;
; 1468 : 													if (FindGrains(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, pTempGrains + lay * T.InitialMultiplicity, T.InitialMultiplicity)) seqlength++;												
; 1469 : 													};
; 1470 : 	
; 1471 : 												Vector topv, bottomv;
; 1472 : 												topv.X = pT->Xcm;
; 1473 : 												topv.Y = pT->Ycm;
; 1474 : 												topv.Z = tz;
; 1475 : 												bottomv.X = pB->Xcm;
; 1476 : 												bottomv.Y = pB->Ycm;
; 1477 : 												bottomv.Z = ZLayer[tr.BottomLayer];
; 1478 : 												for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)
; 1479 : 												{
; 1480 : 													dz = (bottomv.Z - topv.Z);
; 1481 : 													float diz = 1.0f / dz;
; 1482 : 													dz = ZLayer[lay] - topv.Z;
; 1483 : 													ExpX = dz * SlopeX + topv.X;
; 1484 : 													ExpY = dz * SlopeY + topv.Y;
; 1485 : 													if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, 0, DiscardShadows ? pTempGrains[lay + 1] : 0, ShadowXTol, ShadowYTol))
; 1486 : 													{
; 1487 : 														seqlength++;
; 1488 : 														}
; 1489 : 													else if (--availablevoids <= 0) break;
; 1490 : 													};
; 1491 : 												if (availablevoids <= 0) continue;
; 1492 : 												for (lay = (int)tr.BottomLayer + 1; lay <= EndLayer; lay++)
; 1493 : 												{
; 1494 : 													dz = (bottomv.Z - topv.Z);
; 1495 : 													float diz = 1.0f / dz;
; 1496 : 													dz = ZLayer[lay] - topv.Z;
; 1497 : 													ExpX = dz * SlopeX + topv.X;
; 1498 : 													ExpY = dz * SlopeY + topv.Y;
; 1499 : 													if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, DiscardShadows ? pTempGrains[lay - 1] : 0, 0, ShadowXTol, ShadowYTol))
; 1500 : 													{
; 1501 : 														seqlength++;
; 1502 : 														}
; 1503 : 													else if (--availablevoids <= 0) break;
; 1504 : 													};
; 1505 : */	
; 1506 : 												for (lay = StartLayer; lay <= EndLayer; lay++)

	mov	esi, DWORD PTR _StartLayer$[esp+380]
	mov	edx, DWORD PTR _EndLayer$[esp+380]
	add	esp, 12					; 0000000cH
	cmp	esi, edx
	mov	DWORD PTR _seqlength$131442[esp+368], 0
	jg	$LN57@PartialGet
	mov	eax, DWORD PTR _countFindGrains$[esp+368]
	mov	ecx, DWORD PTR tv1579[esp+368]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	DWORD PTR _countFindGrains$[esp+368], edx
	npad	10
$LL59@PartialGet:

; 1507 : 												{
; 1508 : 													dz = ZLayer[lay] - tz;
; 1509 : 													ExpX = dz * SlopeX + gt.Xcm;
; 1510 : 													ExpY = dz * SlopeY + gt.Ycm;
; 1511 : 													countFindGrains++;
; 1512 : 													if (FindGrains(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, pTempGrains + lay * T.InitialMultiplicity, T.InitialMultiplicity)) seqlength++;

	mov	eax, DWORD PTR [ebp+932]
	fld	DWORD PTR [ebx+esi*4]
	fsub	DWORD PTR _tz$[esp+368]
	mov	ecx, DWORD PTR [ebp+976]
	push	eax
	imul	eax, esi
	imul	ecx, esi
	fstp	DWORD PTR _dz$131441[esp+372]
	fld	DWORD PTR _dirtol$[esp+372]
	mov	edx, DWORD PTR _CellSpace$[esp+372]
	lea	eax, DWORD PTR [edi+eax*4]
	push	eax
	sub	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, ebp
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _DirY$[esp+388]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _DirX$[esp+388]
	fstp	DWORD PTR [esp]
	push	eax
	fld	DWORD PTR _dz$131441[esp+392]
	sub	esp, 8
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+400]
	fadd	DWORD PTR _gt$131405[esp+404]
	fstp	DWORD PTR tv2473[esp+400]
	fld	DWORD PTR tv2473[esp+400]
	fstp	DWORD PTR [esp+4]
	fmul	DWORD PTR _SlopeX$[esp+400]
	fadd	DWORD PTR _gt$131405[esp+400]
	fstp	DWORD PTR tv2472[esp+400]
	fld	DWORD PTR tv2472[esp+400]
	fstp	DWORD PTR [esp]
	call	?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z ; CSmartTrackerClass::FindGrains
	test	eax, eax
	je	SHORT $LN58@PartialGet
	add	DWORD PTR _seqlength$131442[esp+368], 1
$LN58@PartialGet:

; 1452 : 												float dz;
; 1453 : 												int seqlength = 0;
; 1454 : 												//int seqlength = 3;
; 1455 : /*	
; 1456 : 												pTempGrains[tr.TopLayer] = pT;
; 1457 : 												pTempGrains[tr.BottomLayer] = pB;
; 1458 : 												pTempGrains[TriggerLayer] = pTrg;
; 1459 : */	
; 1460 : 												CurrDeltaX = fabs(avgdz * SlopeX);
; 1461 : 												CurrDeltaY = fabs(avgdz * SlopeY);
; 1462 : /*	
; 1463 : 												for (lay = tr.TopLayer; lay <= tr.BottomLayer; lay++)
; 1464 : 												{
; 1465 : 													dz = ZLayer[lay] - tz;
; 1466 : 													ExpX = dz * SlopeX + gt.Xcm;
; 1467 : 													ExpY = dz * SlopeY + gt.Ycm;
; 1468 : 													if (FindGrains(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, pTempGrains + lay * T.InitialMultiplicity, T.InitialMultiplicity)) seqlength++;												
; 1469 : 													};
; 1470 : 	
; 1471 : 												Vector topv, bottomv;
; 1472 : 												topv.X = pT->Xcm;
; 1473 : 												topv.Y = pT->Ycm;
; 1474 : 												topv.Z = tz;
; 1475 : 												bottomv.X = pB->Xcm;
; 1476 : 												bottomv.Y = pB->Ycm;
; 1477 : 												bottomv.Z = ZLayer[tr.BottomLayer];
; 1478 : 												for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)
; 1479 : 												{
; 1480 : 													dz = (bottomv.Z - topv.Z);
; 1481 : 													float diz = 1.0f / dz;
; 1482 : 													dz = ZLayer[lay] - topv.Z;
; 1483 : 													ExpX = dz * SlopeX + topv.X;
; 1484 : 													ExpY = dz * SlopeY + topv.Y;
; 1485 : 													if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, 0, DiscardShadows ? pTempGrains[lay + 1] : 0, ShadowXTol, ShadowYTol))
; 1486 : 													{
; 1487 : 														seqlength++;
; 1488 : 														}
; 1489 : 													else if (--availablevoids <= 0) break;
; 1490 : 													};
; 1491 : 												if (availablevoids <= 0) continue;
; 1492 : 												for (lay = (int)tr.BottomLayer + 1; lay <= EndLayer; lay++)
; 1493 : 												{
; 1494 : 													dz = (bottomv.Z - topv.Z);
; 1495 : 													float diz = 1.0f / dz;
; 1496 : 													dz = ZLayer[lay] - topv.Z;
; 1497 : 													ExpX = dz * SlopeX + topv.X;
; 1498 : 													ExpY = dz * SlopeY + topv.Y;
; 1499 : 													if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, DiscardShadows ? pTempGrains[lay - 1] : 0, 0, ShadowXTol, ShadowYTol))
; 1500 : 													{
; 1501 : 														seqlength++;
; 1502 : 														}
; 1503 : 													else if (--availablevoids <= 0) break;
; 1504 : 													};
; 1505 : */	
; 1506 : 												for (lay = StartLayer; lay <= EndLayer; lay++)

	add	esi, 1
	cmp	esi, DWORD PTR _EndLayer$[esp+368]
	jle	$LL59@PartialGet
$LN57@PartialGet:

; 1513 : 													};											
; 1514 : 												
; 1515 : 												if ((float)seqlength > (tinf + td / (1.0f + tsl * SlopeS)))

	fild	DWORD PTR _seqlength$131442[esp+368]
	fld	DWORD PTR _td$[esp+368]
	fld	DWORD PTR _SlopeS$[esp+368]
	fmul	DWORD PTR _tsl$[esp+368]
	fadd	QWORD PTR __real@3ff0000000000000
	fdivp	ST(1), ST(0)
	fadd	DWORD PTR _tinf$[esp+368]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN192@PartialGet
$LN62@PartialGet:

; 1437 : 										//GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);
; 1438 : 	
; 1439 : 										for (ir = 0; ir < tr.TriggerCount; ir++)

	mov	eax, DWORD PTR _ir$[esp+368]
	add	eax, 1
	cmp	eax, DWORD PTR _tr$131384[esp+376]
	mov	DWORD PTR _ir$[esp+368], eax
	jl	$LL221@PartialGet

; 1585 : 									if (GetTickCount() > TimeLimit)

	jmp	$LN74@PartialGet
$LN192@PartialGet:

; 1516 : 												{					
; 1517 : 													countPossible++;
; 1518 : 													if (AR.Found < AR.MaxTracks)

	mov	ecx, DWORD PTR _AR$[esp+364]
	mov	eax, DWORD PTR [ecx+16]
	add	DWORD PTR _countPossible$[esp+368], 1
	cmp	eax, DWORD PTR [ecx+12]
	jge	$LN74@PartialGet

; 1521 : 														Track2 &N = AR.pSpace[AR.Found++];

	mov	esi, DWORD PTR [ecx+8]
	add	DWORD PTR _countAccepted$[esp+368], 1
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax
	add	eax, 1
	mov	DWORD PTR [ecx+16], eax

; 1522 : 														int i, j;
; 1523 : 														for (i = j = 0; i <= EndLayer * T.InitialMultiplicity; i++)

	mov	eax, DWORD PTR [ebp+932]
	imul	eax, DWORD PTR _EndLayer$[esp+368]
	lea	edi, DWORD PTR [esi+edx*4]
	xor	esi, esi
	test	eax, eax
	mov	DWORD PTR _j$131452[esp+368], esi
	jl	SHORT $LN232@PartialGet

; 1519 : 													{
; 1520 : 														countAccepted++;

	xor	ebx, ebx
$LL239@PartialGet:

; 1524 : 															if (pTempGrains[i])

	mov	ecx, DWORD PTR _pTempGrains$[esp+368]
	mov	eax, DWORD PTR [ecx+esi*4]
	test	eax, eax
	je	SHORT $LN52@PartialGet
	mov	ecx, DWORD PTR [edi+12]

; 1525 : 															{
; 1526 : 																IntTrackGrain *pIG = ((IntTrackGrain *)N.pGrains) + j++;

	add	DWORD PTR _j$131452[esp+368], 1
	add	ecx, ebx

; 1527 : 																pIG->T.pG = pTempGrains[i];

	mov	DWORD PTR [ecx], eax

; 1528 : 																pIG->T.Z = ZLayer[i / T.InitialMultiplicity];

	mov	eax, esi
	cdq
	add	ebx, 16					; 00000010H
	idiv	DWORD PTR [ebp+932]
	mov	edx, DWORD PTR _ZLayer$[esp+368]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR [ecx+4]
$LN52@PartialGet:
	mov	eax, DWORD PTR [ebp+932]
	imul	eax, DWORD PTR _EndLayer$[esp+368]
	add	esi, 1
	cmp	esi, eax
	jle	SHORT $LL239@PartialGet
$LN232@PartialGet:

; 1529 : 																}														
; 1530 : 														N.Field = (itr << 24) + (ix << 16) + ifound;

	mov	ecx, DWORD PTR tv2609[esp+368]
	mov	edx, DWORD PTR _ix$[esp+368]
	mov	eax, DWORD PTR _ifound$[esp+368]
	add	ecx, edx
	shl	ecx, 16					; 00000010H
	add	ecx, eax
	mov	DWORD PTR [edi], ecx

; 1531 : 														N.Valid = true;
; 1532 : 														N.Grains = j;//seqlength;

	mov	ecx, DWORD PTR _j$131452[esp+368]

; 1533 : 														ifound++;

	add	eax, 1
	mov	BYTE PTR [edi+56], 1
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR _ifound$[esp+368], eax
	jmp	SHORT $LN74@PartialGet
$LN243@PartialGet:
	fstp	ST(2)
$LN252@PartialGet:

; 1426 : 									if (fabs(SlopeY) >= MaxSlope || fabs(SlopeY - T.PresetSlopeY) > T.PresetSlopeAccY) continue;

	fstp	ST(1)
$LN255@PartialGet:

; 1429 : restart:	
; 1430 : 									if (Slope2 < MaxSlope2)

	fstp	ST(0)
$LN74@PartialGet:

; 1413 : 								for (;pB < pBE; pB++)

	mov	esi, DWORD PTR _pB$131413[esp+368]
	add	esi, 36					; 00000024H
	cmp	esi, DWORD PTR _pBE$131414[esp+368]
	mov	DWORD PTR _pB$131413[esp+368], esi
	jb	$LL228@PartialGet
$LN77@PartialGet:

; 1408 : 							for (iiy = miniy; iiy <= maxiy; iiy++)

	mov	eax, DWORD PTR _iiy$[esp+368]
	mov	edx, DWORD PTR tv1541[esp+368]
	add	DWORD PTR tv2465[esp+368], edx
	add	eax, 1
	cmp	eax, DWORD PTR _maxiy$[esp+368]
	mov	DWORD PTR _iiy$[esp+368], eax
	jle	$LL231@PartialGet
	mov	eax, DWORD PTR _iix$[esp+368]
	mov	ebx, DWORD PTR _pT$131400[esp+368]
	mov	edx, DWORD PTR _miniy$[esp+368]
$LN80@PartialGet:
	add	eax, 1
	cmp	eax, DWORD PTR _maxix$[esp+368]
	mov	DWORD PTR _iix$[esp+368], eax
	jle	$LL81@PartialGet
$LN83@PartialGet:

; 1404 : 					for (;pT < pTE; pT++)

	add	ebx, 36					; 00000024H
	cmp	ebx, DWORD PTR _pTE$131401[esp+368]
	mov	DWORD PTR _pT$131400[esp+368], ebx
	jb	$LL84@PartialGet
	mov	ecx, DWORD PTR tv2541[esp+368]
$LN88@PartialGet:

; 1397 : 				for (iy = 0; iy < ny; iy++)

	add	ecx, DWORD PTR tv1541[esp+368]
	mov	eax, DWORD PTR tv1543[esp+368]
	cmp	eax, DWORD PTR _ny$[esp+368]
	mov	DWORD PTR tv2541[esp+368], ecx
	jl	$LL235@PartialGet
	mov	ecx, DWORD PTR tv1539[esp+368]
$LN93@PartialGet:

; 1389 : 			tz = ZLayer[tr.TopLayer];
; 1390 : 			idz = 1.0f / (tz - ZLayer[tr.BottomLayer]);
; 1391 : 	
; 1392 : 			for (ix = bx; ix < wx; ix++)

	mov	ebx, DWORD PTR tv2597[esp+368]
	mov	eax, ecx
	add	ebx, 8
	cmp	eax, DWORD PTR _wx$[esp+368]
	mov	DWORD PTR _ix$[esp+368], eax
	mov	DWORD PTR tv2597[esp+368], ebx
	jl	$LL236@PartialGet
	mov	ebx, DWORD PTR _bx$[esp+368]
$LN98@PartialGet:

; 1377 : 	float tinf = (float)(T.NptMinH);
; 1378 : 	float td = (float)(T.NptMinV - T.NptMinH);
; 1379 : 
; 1380 : 	if (T.PresetSlope)
; 1381 : 	{
; 1382 : 
; 1383 : 		for (itr = 0; itr < T.TrialCount; itr++)

	mov	eax, DWORD PTR _itr$[esp+368]
	add	DWORD PTR tv2638[esp+368], 44		; 0000002cH
	add	DWORD PTR tv2609[esp+368], 256		; 00000100H
	add	eax, 1
	cmp	eax, DWORD PTR [ebp+172]
	mov	DWORD PTR _itr$[esp+368], eax
	jl	$LL99@PartialGet
$LN46@PartialGet:

; 1703 : 														}
; 1704 : 													break;
; 1705 : 													}
; 1706 : 												}
; 1707 : 											}
; 1708 : 										}
; 1709 : 									}
; 1710 : 								}
; 1711 : 						}
; 1712 : 					}
; 1713 : 				}
; 1714 : 			}
; 1715 : 
; 1716 : 
; 1717 : 		}
; 1718 : 
; 1719 : 	free(pTempGrains);

	mov	eax, DWORD PTR _pTempGrains$[esp+368]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN278@PartialGet:
	pop	edi
	pop	esi
	pop	ebp

; 1720 : /*
; 1721 : 	char fname[256];
; 1722 : 	sprintf(fname, "c:\\acq\\smt8c_%d.txt", AR.ThreadIndex);
; 1723 : 	FILE *f;
; 1724 : 	if (!(f = fopen(fname, "r+t")))
; 1725 : 	{
; 1726 : 		f = fopen(fname, "w+t");
; 1727 : 		fprintf(f, "Iters\tSlopeX\tSlopeY\tTrials\tFindGrn\tPoss\tAcc");
; 1728 : 		}
; 1729 : 	else
; 1730 : 	{
; 1731 : 		fclose(f);
; 1732 : 		f = fopen(fname, "a+t");
; 1733 : 		}
; 1734 : 	fprintf(f, "\n%d\t%d\t%d\t%d\t%d\t%d\t%d", countIterations, countSlopeX, countSlopeY, countTrials, countFindGrains, countPossible, countAccepted);
; 1735 : 	fclose(f);	
; 1736 : */
; 1737 : 	return S_OK;

	xor	eax, eax
	pop	ebx

; 1738 : 	};

	add	esp, 352				; 00000160H
	ret	4
$LN193@PartialGet:

; 1417 : 									{
; 1418 : 										AR.Found = 0;

	mov	eax, DWORD PTR _AR$[esp+364]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+16], 0
	pop	ebp

; 1419 : 										return S_FALSE;

	mov	eax, ebx
	pop	ebx

; 1738 : 	};

	add	esp, 352				; 00000160H
	ret	4
$LN100@PartialGet:

; 1534 : 														}
; 1535 : 													break;
; 1536 : 													}
; 1537 : 												}
; 1538 : 											}
; 1539 : 										}
; 1540 : 									}
; 1541 : 								}
; 1542 : 						}
; 1543 : 					}
; 1544 : 				}
; 1545 : 			}
; 1546 : 
; 1547 : 
; 1548 : 		}
; 1549 : 	else
; 1550 : 	{
; 1551 : 
; 1552 : 		for (itr = 0; itr < T.TrialCount; itr++)

	cmp	DWORD PTR [ebp+172], eax
	jle	SHORT $LN46@PartialGet
	mov	ebx, DWORD PTR _ny$[esp+368]
	lea	esi, DWORD PTR [ebp+176]
	mov	DWORD PTR tv2895[esp+368], eax
	mov	DWORD PTR tv2923[esp+368], esi
	npad	12
$LL48@PartialGet:

; 1553 : 		{
; 1554 : 			Trial tr = T.Trials[itr];

	mov	ecx, 11					; 0000000bH
	lea	edi, DWORD PTR _tr$131463[esp+368]
	rep movsd

; 1555 : 			if (tr.TopLayer < StartLayer || tr.BottomLayer > EndLayer) continue;

	mov	eax, DWORD PTR _tr$131463[esp+368]
	cmp	eax, DWORD PTR _StartLayer$[esp+368]
	jl	$LN47@PartialGet
	mov	ecx, DWORD PTR _tr$131463[esp+372]
	cmp	ecx, DWORD PTR _EndLayer$[esp+368]
	jg	$LN47@PartialGet

; 1556 : 			Cell *tp = CellsInLayer * tr.TopLayer + CellSpace;

	mov	esi, DWORD PTR _CellsInLayer$[esp+368]
	mov	edi, DWORD PTR _CellSpace$[esp+368]
	mov	edx, eax
	imul	edx, esi
	lea	edx, DWORD PTR [edi+edx*8]

; 1557 : 			Cell *bp = CellsInLayer * tr.BottomLayer + CellSpace;

	mov	edi, ecx
	imul	edi, esi
	mov	esi, DWORD PTR _CellSpace$[esp+368]
	lea	esi, DWORD PTR [esi+edi*8]
	mov	DWORD PTR _bp$131467[esp+368], esi

; 1558 : 			tz = ZLayer[tr.TopLayer];

	mov	esi, DWORD PTR _ZLayer$[esp+368]
	fld	DWORD PTR [esi+eax*4]

; 1559 : 			idz = 1.0f / (tz - ZLayer[tr.BottomLayer]);
; 1560 : 	
; 1561 : 			for (ix = bx; ix < wx; ix++)

	mov	eax, DWORD PTR _bx$[esp+368]
	cmp	eax, DWORD PTR _wx$[esp+368]
	fstp	DWORD PTR _tz$[esp+368]
	fld	DWORD PTR _tz$[esp+368]
	mov	DWORD PTR _ix$[esp+368], eax
	fsub	DWORD PTR [esi+ecx*4]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _idz$[esp+368]
	jge	$LN47@PartialGet
	mov	ecx, eax
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR tv2883[esp+368], edx
$LL237@PartialGet:

; 1562 : 			{
; 1563 : 				ifound = 0;

	xor	edi, edi
	lea	ecx, DWORD PTR [eax-1]

; 1564 : 				minix = ix - 1; if (minix < 0) minix = 0;

	cmp	ecx, edi
	mov	DWORD PTR _ifound$[esp+368], edi
	mov	DWORD PTR _minix$[esp+368], ecx
	jge	SHORT $LN40@PartialGet
	mov	DWORD PTR _minix$[esp+368], edi
$LN40@PartialGet:

; 1565 : 				maxix = ix + 1; if (maxix >= nx) maxix = nx - 1;

	mov	edx, DWORD PTR tv1493[esp+368]
	lea	ecx, DWORD PTR [eax+1]
	mov	eax, ecx
	cmp	eax, edx
	mov	DWORD PTR tv1539[esp+368], ecx
	mov	DWORD PTR _maxix$[esp+368], eax
	jl	SHORT $LN39@PartialGet
	add	edx, -1
	mov	DWORD PTR _maxix$[esp+368], edx
$LN39@PartialGet:

; 1566 : 				for (iy = 0; iy < ny; iy++)

	xor	eax, eax
	cmp	ebx, edi
	jle	$LN42@PartialGet
	mov	esi, DWORD PTR tv2883[esp+368]
	mov	DWORD PTR tv2829[esp+368], esi
	jmp	SHORT $LN38@PartialGet
	npad	7
$LL238@PartialGet:
	mov	esi, DWORD PTR tv2829[esp+368]
	xor	edi, edi
$LN38@PartialGet:
	lea	ecx, DWORD PTR [eax-1]

; 1567 : 				{
; 1568 : 					miniy = iy - 1; if (miniy < 0) miniy = 0;

	cmp	ecx, edi
	mov	DWORD PTR _miniy$[esp+368], ecx
	jge	SHORT $LN35@PartialGet
	mov	DWORD PTR _miniy$[esp+368], edi
$LN35@PartialGet:

; 1566 : 				for (iy = 0; iy < ny; iy++)

	add	eax, 1

; 1569 : 					maxiy = iy + 1; if (maxiy >= ny) maxiy = ny - 1;

	mov	edx, eax
	cmp	edx, ebx
	mov	DWORD PTR tv1543[esp+368], eax
	mov	DWORD PTR _maxiy$[esp+368], eax
	jl	SHORT $LN34@PartialGet
	lea	edx, DWORD PTR [ebx-1]
	mov	DWORD PTR _maxiy$[esp+368], edx
$LN34@PartialGet:

; 1570 : 					Cell &ct = tp[iy * nx + ix];
; 1571 : 					IntGrain *pT = ct.FirstG;

	mov	ecx, DWORD PTR [esi]

; 1572 : 					IntGrain *pTE = ct.FirstG + ct.Free;

	mov	eax, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1573 : 					for (;pT < pTE; pT++)

	cmp	ecx, eax
	mov	DWORD PTR _pT$131479[esp+368], ecx
	mov	DWORD PTR _pTE$131480[esp+368], eax
	jae	$LN37@PartialGet
	npad	2
$LL33@PartialGet:

; 1574 : 					{
; 1575 : 						IntGrain gt = *pT;
; 1576 : 						for (iix = minix; iix <= maxix; iix++)

	mov	eax, DWORD PTR _minix$[esp+368]
	cmp	eax, DWORD PTR _maxix$[esp+368]
	mov	esi, DWORD PTR _pT$131479[esp+368]
	mov	ecx, 9
	lea	edi, DWORD PTR _gt$131484[esp+368]
	rep movsd
	mov	ecx, eax
	mov	DWORD PTR _iix$[esp+368], eax
	jg	$LN32@PartialGet
	npad	7
$LL30@PartialGet:

; 1577 : 							for (iiy = miniy; iiy <= maxiy; iiy++)

	mov	eax, DWORD PTR _miniy$[esp+368]
	cmp	eax, edx
	mov	DWORD PTR _iiy$[esp+368], eax
	jg	$LN29@PartialGet
	imul	eax, DWORD PTR tv1493[esp+368]
	add	eax, ecx
	mov	ecx, DWORD PTR _bp$131467[esp+368]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv2756[esp+368], eax
	npad	5
$LL27@PartialGet:

; 1578 : 							{
; 1579 : 								Cell &cb = bp[iiy * nx + iix];
; 1580 : 								IntGrain *pB = cb.FirstG;

	mov	esi, DWORD PTR [eax]

; 1581 : 								IntGrain *pBE = cb.FirstG + cb.Free;

	mov	ecx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	lea	ecx, DWORD PTR [esi+ecx*4]

; 1582 : 								for (;pB < pBE; pB++)

	cmp	esi, ecx
	mov	DWORD PTR _pB$131492[esp+368], esi
	mov	DWORD PTR _pBE$131493[esp+368], ecx
	jae	$LN26@PartialGet
$LL229@PartialGet:
	mov	ebx, 1

; 1583 : 								{
; 1584 : 									countIterations++;

	add	DWORD PTR _countIterations$[esp+368], ebx

; 1585 : 									if (GetTickCount() > TimeLimit)

	call	DWORD PTR __imp__GetTickCount@0
	cmp	eax, DWORD PTR _TimeLimit$[esp+368]
	ja	$LN195@PartialGet

; 1589 : 										}
; 1590 : 									IntGrain gb = *pB;
; 1591 : 									SlopeX = idz * (gt.Xcm - gb.Xcm);

	fld	DWORD PTR _gt$131484[esp+368]
	mov	ecx, 9
	lea	edi, DWORD PTR _gb$131499[esp+368]
	rep movsd
	fsub	DWORD PTR _gb$131499[esp+368]
	fld	DWORD PTR _idz$[esp+368]
	fld	ST(0)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _SlopeX$[esp+368]

; 1592 : 									if (fabs(SlopeX) >= MaxSlope) continue;

	fld	DWORD PTR _SlopeX$[esp+368]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv2423[esp+368]
	fld	DWORD PTR tv2423[esp+368]
	fld	DWORD PTR _MaxSlope$[esp+368]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jnp	$LN264@PartialGet

; 1593 : 									countSlopeX++;
; 1594 : 									SlopeY = idz * (gt.Ycm - gb.Ycm);

	fld	DWORD PTR _gt$131484[esp+372]
	add	DWORD PTR _countSlopeX$[esp+368], ebx
	fsub	DWORD PTR _gb$131499[esp+372]
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR _SlopeY$[esp+368]

; 1595 : 									if (fabs(SlopeY) >= MaxSlope) continue;

	fld	DWORD PTR _SlopeY$[esp+368]
	fld	ST(0)
	fabs
	fstp	DWORD PTR tv2412[esp+368]
	fld	DWORD PTR tv2412[esp+368]
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, bl
	je	$LN267@PartialGet

; 1596 : 									Slope2 = SlopeX * SlopeX + SlopeY * SlopeY;
; 1597 : 									countSlopeY++;

	add	DWORD PTR _countSlopeY$[esp+368], ebx
	fmul	ST(0), ST(0)
	fld	ST(1)
$restartpreset$131502:
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _Slope2$[esp+368]

; 1598 : restartpreset:	
; 1599 : 									if (Slope2 < MaxSlope2)

	fld	DWORD PTR _Slope2$[esp+368]
	fld	DWORD PTR _MaxSlope2$[esp+368]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN270@PartialGet

; 1600 : 									{
; 1601 : 										countTrials++;

	add	DWORD PTR _countTrials$[esp+368], ebx

; 1602 : 										SlopeS = sqrt(Slope2);

	call	__CIsqrt
	fstp	DWORD PTR tv2393[esp+368]
	fld	DWORD PTR tv2393[esp+368]
	fstp	DWORD PTR _SlopeS$[esp+368]

; 1603 : 										if (SlopeS > 0.0f) ISlopeS = 1.0f / SlopeS;

	fldz
	fld	DWORD PTR _SlopeS$[esp+368]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN224@PartialGet
	fld	ST(0)
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _ISlopeS$[esp+368]
$LN224@PartialGet:

; 1604 : 										avgds2 = avgdz2 * Slope2;
; 1605 : 										fastGetDirAndTol(SlopeS, ISlopeS, DirX, DirY, dirtol/*, aligntol2, avgds2*/);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN276@PartialGet
	fstp	ST(0)
	fld1
	fstp	DWORD PTR _DirX$[esp+368]
	fstp	DWORD PTR _DirY$[esp+368]
	fld	DWORD PTR [ebp+168]
	jmp	SHORT $LN280@PartialGet
$LN276@PartialGet:
	fstp	ST(1)
	fld	DWORD PTR _ISlopeS$[esp+368]
	fld	ST(0)
	fmul	DWORD PTR _SlopeX$[esp+368]
	fstp	DWORD PTR _DirX$[esp+368]
	fmul	DWORD PTR _SlopeY$[esp+368]
	fstp	DWORD PTR _DirY$[esp+368]
	fmul	DWORD PTR _avgdz$[esp+368]
	fadd	DWORD PTR [ebp+168]
$LN280@PartialGet:

; 1606 : 										//GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);
; 1607 : 	
; 1608 : 										for (ir = 0; ir < tr.TriggerCount; ir++)

	cmp	DWORD PTR _tr$131463[esp+376], 0
	fstp	DWORD PTR _dirtol$[esp+368]
	mov	DWORD PTR _ir$[esp+368], 0
	jle	$LN23@PartialGet
	mov	edi, DWORD PTR _pTempGrains$[esp+368]
	mov	ebx, DWORD PTR _ZLayer$[esp+368]
	npad	6
$LL225@PartialGet:

; 1609 : 										{
; 1610 : 											int TriggerLayer = tr.Triggers[ir];

	mov	edx, DWORD PTR _ir$[esp+368]

; 1611 : 											float ldz = (tz - ZLayer[TriggerLayer]) * idz;

	fld	DWORD PTR _tz$[esp+368]
	mov	esi, DWORD PTR _tr$131463[esp+edx*4+380]
	fsub	DWORD PTR [ebx+esi*4]

; 1612 : 											float cdz = 1.0f - ldz;
; 1613 : 											ExpX = ldz * gb.Xcm + cdz * gt.Xcm;
; 1614 : 											ExpY = ldz * gb.Ycm + cdz * gt.Ycm;
; 1615 : 											eix = (int)((ExpX - T.Win.Xmin) / T.DxCell);
; 1616 : 											eiy = (int)((ExpY - T.Win.Ymin) / T.DyCell);
; 1617 : 											IntGrain *pTrg = CellSpace[(TriggerLayer * ny + eiy) * nx + eix].FindGrain(ExpX, ExpY, DirX, DirY, dirtol, T.AlignTol);

	sub	esp, 24					; 00000018H
	fmul	DWORD PTR _idz$[esp+392]
	fstp	DWORD PTR _ldz$131511[esp+392]
	fld	DWORD PTR _ldz$131511[esp+392]
	fld	ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	fstp	DWORD PTR _cdz$131512[esp+392]
	fld	ST(0)
	fmul	DWORD PTR _gb$131499[esp+392]
	fld	DWORD PTR _cdz$131512[esp+392]
	fld	ST(0)
	fmul	DWORD PTR _gt$131484[esp+392]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _ExpX$[esp+392]
	fld	DWORD PTR _gb$131499[esp+396]
	fmulp	ST(2), ST(0)
	fmul	DWORD PTR _gt$131484[esp+396]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ExpY$[esp+392]
	fld	DWORD PTR [ebp+168]
	fstp	DWORD PTR [esp+20]
	fld	DWORD PTR _dirtol$[esp+392]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _DirY$[esp+392]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _DirX$[esp+392]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _ExpY$[esp+392]
	fst	DWORD PTR [esp+4]
	fld	DWORD PTR _ExpX$[esp+392]
	fst	DWORD PTR [esp]

; 1618 : 											if (pTrg)

	fld	DWORD PTR [ebp+988]
	fsubp	ST(2), ST(0)
	fld	DWORD PTR [ebp+1000]
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fsub	DWORD PTR [ebp+980]
	imul	esi, DWORD PTR _ny$[esp+392]
	fdiv	DWORD PTR [ebp+996]
	add	eax, esi
	imul	eax, DWORD PTR tv1493[esp+392]
	mov	DWORD PTR tv2252[esp+392], eax
	call	__ftol2_sse
	mov	ecx, DWORD PTR tv2252[esp+392]
	add	ecx, eax
	mov	eax, DWORD PTR _CellSpace$[esp+392]
	lea	ecx, DWORD PTR [eax+ecx*8]
	call	?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z ; Cell::FindGrain
	test	eax, eax
	je	$LN13@PartialGet

; 1619 : 											{
; 1620 : 												memset(pTempGrains, 0, T.Layer * sizeof(Grain *) * T.InitialMultiplicity);

	mov	ecx, DWORD PTR [ebp+932]
	imul	ecx, DWORD PTR [ebp+1016]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	edi
	call	_memset

; 1621 : 												float dz;
; 1622 : 												int seqlength = 0;
; 1623 : 												//int seqlength = 3;
; 1624 : /*	
; 1625 : 												pTempGrains[tr.TopLayer] = pT;
; 1626 : 												pTempGrains[tr.BottomLayer] = pB;
; 1627 : 												pTempGrains[TriggerLayer] = pTrg;
; 1628 : */	
; 1629 : 												CurrDeltaX = fabs(avgdz * SlopeX);
; 1630 : 												CurrDeltaY = fabs(avgdz * SlopeY);
; 1631 : /*	
; 1632 : 												for (lay = tr.TopLayer; lay <= tr.BottomLayer; lay++)
; 1633 : 												{
; 1634 : 													dz = ZLayer[lay] - tz;
; 1635 : 													ExpX = dz * SlopeX + gt.Xcm;
; 1636 : 													ExpY = dz * SlopeY + gt.Ycm;
; 1637 : 													if (FindGrains(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, pTempGrains + lay * T.InitialMultiplicity, T.InitialMultiplicity)) seqlength++;												
; 1638 : 													};
; 1639 : 	
; 1640 : 												Vector topv, bottomv;
; 1641 : 												topv.X = pT->Xcm;
; 1642 : 												topv.Y = pT->Ycm;
; 1643 : 												topv.Z = tz;
; 1644 : 												bottomv.X = pB->Xcm;
; 1645 : 												bottomv.Y = pB->Ycm;
; 1646 : 												bottomv.Z = ZLayer[tr.BottomLayer];
; 1647 : 												for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)
; 1648 : 												{
; 1649 : 													dz = (bottomv.Z - topv.Z);
; 1650 : 													float diz = 1.0f / dz;
; 1651 : 													dz = ZLayer[lay] - topv.Z;
; 1652 : 													ExpX = dz * SlopeX + topv.X;
; 1653 : 													ExpY = dz * SlopeY + topv.Y;
; 1654 : 													if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, 0, DiscardShadows ? pTempGrains[lay + 1] : 0, ShadowXTol, ShadowYTol))
; 1655 : 													{
; 1656 : 														seqlength++;
; 1657 : 														}
; 1658 : 													else if (--availablevoids <= 0) break;
; 1659 : 													};
; 1660 : 												if (availablevoids <= 0) continue;
; 1661 : 												for (lay = (int)tr.BottomLayer + 1; lay <= EndLayer; lay++)
; 1662 : 												{
; 1663 : 													dz = (bottomv.Z - topv.Z);
; 1664 : 													float diz = 1.0f / dz;
; 1665 : 													dz = ZLayer[lay] - topv.Z;
; 1666 : 													ExpX = dz * SlopeX + topv.X;
; 1667 : 													ExpY = dz * SlopeY + topv.Y;
; 1668 : 													if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, DiscardShadows ? pTempGrains[lay - 1] : 0, 0, ShadowXTol, ShadowYTol))
; 1669 : 													{
; 1670 : 														seqlength++;
; 1671 : 														}
; 1672 : 													else if (--availablevoids <= 0) break;
; 1673 : 													};
; 1674 : */	
; 1675 : 												for (lay = StartLayer; lay <= EndLayer; lay++)

	mov	esi, DWORD PTR _StartLayer$[esp+380]
	mov	edx, DWORD PTR _EndLayer$[esp+380]
	add	esp, 12					; 0000000cH
	cmp	esi, edx
	mov	DWORD PTR _seqlength$131519[esp+368], 0
	jg	$LN8@PartialGet
	mov	eax, DWORD PTR _countFindGrains$[esp+368]
	mov	ecx, DWORD PTR tv1579[esp+368]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	DWORD PTR _countFindGrains$[esp+368], edx
	npad	10
$LL10@PartialGet:

; 1676 : 												{
; 1677 : 													dz = ZLayer[lay] - tz;
; 1678 : 													ExpX = dz * SlopeX + gt.Xcm;
; 1679 : 													ExpY = dz * SlopeY + gt.Ycm;
; 1680 : 													countFindGrains++;
; 1681 : 													if (FindGrains(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, pTempGrains + lay * T.InitialMultiplicity, T.InitialMultiplicity)) seqlength++;

	mov	eax, DWORD PTR [ebp+932]
	fld	DWORD PTR [ebx+esi*4]
	fsub	DWORD PTR _tz$[esp+368]
	mov	ecx, DWORD PTR [ebp+976]
	push	eax
	imul	eax, esi
	imul	ecx, esi
	fstp	DWORD PTR _dz$131518[esp+372]
	fld	DWORD PTR _dirtol$[esp+372]
	mov	edx, DWORD PTR _CellSpace$[esp+372]
	lea	eax, DWORD PTR [edi+eax*4]
	push	eax
	sub	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, ebp
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _DirY$[esp+388]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _DirX$[esp+388]
	fstp	DWORD PTR [esp]
	push	eax
	fld	DWORD PTR _dz$131518[esp+392]
	sub	esp, 8
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+400]
	fadd	DWORD PTR _gt$131484[esp+404]
	fstp	DWORD PTR tv2340[esp+400]
	fld	DWORD PTR tv2340[esp+400]
	fstp	DWORD PTR [esp+4]
	fmul	DWORD PTR _SlopeX$[esp+400]
	fadd	DWORD PTR _gt$131484[esp+400]
	fstp	DWORD PTR tv2339[esp+400]
	fld	DWORD PTR tv2339[esp+400]
	fstp	DWORD PTR [esp]
	call	?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z ; CSmartTrackerClass::FindGrains
	test	eax, eax
	je	SHORT $LN9@PartialGet
	add	DWORD PTR _seqlength$131519[esp+368], 1
$LN9@PartialGet:

; 1621 : 												float dz;
; 1622 : 												int seqlength = 0;
; 1623 : 												//int seqlength = 3;
; 1624 : /*	
; 1625 : 												pTempGrains[tr.TopLayer] = pT;
; 1626 : 												pTempGrains[tr.BottomLayer] = pB;
; 1627 : 												pTempGrains[TriggerLayer] = pTrg;
; 1628 : */	
; 1629 : 												CurrDeltaX = fabs(avgdz * SlopeX);
; 1630 : 												CurrDeltaY = fabs(avgdz * SlopeY);
; 1631 : /*	
; 1632 : 												for (lay = tr.TopLayer; lay <= tr.BottomLayer; lay++)
; 1633 : 												{
; 1634 : 													dz = ZLayer[lay] - tz;
; 1635 : 													ExpX = dz * SlopeX + gt.Xcm;
; 1636 : 													ExpY = dz * SlopeY + gt.Ycm;
; 1637 : 													if (FindGrains(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, pTempGrains + lay * T.InitialMultiplicity, T.InitialMultiplicity)) seqlength++;												
; 1638 : 													};
; 1639 : 	
; 1640 : 												Vector topv, bottomv;
; 1641 : 												topv.X = pT->Xcm;
; 1642 : 												topv.Y = pT->Ycm;
; 1643 : 												topv.Z = tz;
; 1644 : 												bottomv.X = pB->Xcm;
; 1645 : 												bottomv.Y = pB->Ycm;
; 1646 : 												bottomv.Z = ZLayer[tr.BottomLayer];
; 1647 : 												for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)
; 1648 : 												{
; 1649 : 													dz = (bottomv.Z - topv.Z);
; 1650 : 													float diz = 1.0f / dz;
; 1651 : 													dz = ZLayer[lay] - topv.Z;
; 1652 : 													ExpX = dz * SlopeX + topv.X;
; 1653 : 													ExpY = dz * SlopeY + topv.Y;
; 1654 : 													if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, 0, DiscardShadows ? pTempGrains[lay + 1] : 0, ShadowXTol, ShadowYTol))
; 1655 : 													{
; 1656 : 														seqlength++;
; 1657 : 														}
; 1658 : 													else if (--availablevoids <= 0) break;
; 1659 : 													};
; 1660 : 												if (availablevoids <= 0) continue;
; 1661 : 												for (lay = (int)tr.BottomLayer + 1; lay <= EndLayer; lay++)
; 1662 : 												{
; 1663 : 													dz = (bottomv.Z - topv.Z);
; 1664 : 													float diz = 1.0f / dz;
; 1665 : 													dz = ZLayer[lay] - topv.Z;
; 1666 : 													ExpX = dz * SlopeX + topv.X;
; 1667 : 													ExpY = dz * SlopeY + topv.Y;
; 1668 : 													if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, DiscardShadows ? pTempGrains[lay - 1] : 0, 0, ShadowXTol, ShadowYTol))
; 1669 : 													{
; 1670 : 														seqlength++;
; 1671 : 														}
; 1672 : 													else if (--availablevoids <= 0) break;
; 1673 : 													};
; 1674 : */	
; 1675 : 												for (lay = StartLayer; lay <= EndLayer; lay++)

	add	esi, 1
	cmp	esi, DWORD PTR _EndLayer$[esp+368]
	jle	$LL10@PartialGet
$LN8@PartialGet:

; 1682 : 													};											
; 1683 : 												
; 1684 : 												if ((float)seqlength > (tinf + td / (1.0f + tsl * SlopeS)))

	fild	DWORD PTR _seqlength$131519[esp+368]
	fld	DWORD PTR _td$[esp+368]
	fld	DWORD PTR _SlopeS$[esp+368]
	fmul	DWORD PTR _tsl$[esp+368]
	fadd	QWORD PTR __real@3ff0000000000000
	fdivp	ST(1), ST(0)
	fadd	DWORD PTR _tinf$[esp+368]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN194@PartialGet
$LN13@PartialGet:

; 1606 : 										//GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);
; 1607 : 	
; 1608 : 										for (ir = 0; ir < tr.TriggerCount; ir++)

	mov	eax, DWORD PTR _ir$[esp+368]
	add	eax, 1
	cmp	eax, DWORD PTR _tr$131463[esp+376]
	mov	DWORD PTR _ir$[esp+368], eax
	jl	$LL225@PartialGet

; 1585 : 									if (GetTickCount() > TimeLimit)

	jmp	$LN23@PartialGet
$LN194@PartialGet:

; 1685 : 												{					
; 1686 : 													countPossible++;
; 1687 : 													if (AR.Found < AR.MaxTracks)

	mov	ecx, DWORD PTR _AR$[esp+364]
	mov	eax, DWORD PTR [ecx+16]
	add	DWORD PTR _countPossible$[esp+368], 1
	cmp	eax, DWORD PTR [ecx+12]
	jge	$LN23@PartialGet

; 1690 : 														Track2 &N = AR.pSpace[AR.Found++];

	mov	esi, DWORD PTR [ecx+8]
	add	DWORD PTR _countAccepted$[esp+368], 1
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax
	add	eax, 1
	mov	DWORD PTR [ecx+16], eax

; 1691 : 														int i, j;
; 1692 : 														for (i = j = 0; i <= EndLayer * T.InitialMultiplicity; i++)

	mov	eax, DWORD PTR [ebp+932]
	imul	eax, DWORD PTR _EndLayer$[esp+368]
	lea	edi, DWORD PTR [esi+edx*4]
	xor	esi, esi
	test	eax, eax
	mov	DWORD PTR _j$131529[esp+368], esi
	jl	SHORT $LN230@PartialGet

; 1688 : 													{
; 1689 : 														countAccepted++;

	xor	ebx, ebx
$LL240@PartialGet:

; 1693 : 															if (pTempGrains[i])

	mov	ecx, DWORD PTR _pTempGrains$[esp+368]
	mov	eax, DWORD PTR [ecx+esi*4]
	test	eax, eax
	je	SHORT $LN3@PartialGet
	mov	ecx, DWORD PTR [edi+12]

; 1694 : 															{
; 1695 : 																IntTrackGrain *pIG = ((IntTrackGrain *)N.pGrains) + j++;

	add	DWORD PTR _j$131529[esp+368], 1
	add	ecx, ebx

; 1696 : 																pIG->T.pG = pTempGrains[i];

	mov	DWORD PTR [ecx], eax

; 1697 : 																pIG->T.Z = ZLayer[i / T.InitialMultiplicity];

	mov	eax, esi
	cdq
	add	ebx, 16					; 00000010H
	idiv	DWORD PTR [ebp+932]
	mov	edx, DWORD PTR _ZLayer$[esp+368]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR [ecx+4]
$LN3@PartialGet:
	mov	eax, DWORD PTR [ebp+932]
	imul	eax, DWORD PTR _EndLayer$[esp+368]
	add	esi, 1
	cmp	esi, eax
	jle	SHORT $LL240@PartialGet
$LN230@PartialGet:

; 1698 : 																}														
; 1699 : 														N.Field = (itr << 24) + (ix << 16) + ifound;

	mov	ecx, DWORD PTR tv2895[esp+368]
	mov	edx, DWORD PTR _ix$[esp+368]
	mov	eax, DWORD PTR _ifound$[esp+368]
	add	ecx, edx
	shl	ecx, 16					; 00000010H
	add	ecx, eax
	mov	DWORD PTR [edi], ecx

; 1700 : 														N.Valid = true;
; 1701 : 														N.Grains = j;//seqlength;

	mov	ecx, DWORD PTR _j$131529[esp+368]

; 1702 : 														ifound++;

	add	eax, 1
	mov	BYTE PTR [edi+56], 1
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR _ifound$[esp+368], eax
	jmp	SHORT $LN23@PartialGet
$LN264@PartialGet:
	fstp	ST(2)
$LN267@PartialGet:

; 1595 : 									if (fabs(SlopeY) >= MaxSlope) continue;

	fstp	ST(1)
$LN270@PartialGet:

; 1598 : restartpreset:	
; 1599 : 									if (Slope2 < MaxSlope2)

	fstp	ST(0)
$LN23@PartialGet:

; 1582 : 								for (;pB < pBE; pB++)

	mov	esi, DWORD PTR _pB$131492[esp+368]
	add	esi, 36					; 00000024H
	cmp	esi, DWORD PTR _pBE$131493[esp+368]
	mov	DWORD PTR _pB$131492[esp+368], esi
	jb	$LL229@PartialGet
	mov	eax, DWORD PTR tv2756[esp+368]
	mov	edx, DWORD PTR _maxiy$[esp+368]
$LN26@PartialGet:
	mov	ecx, DWORD PTR tv1493[esp+368]
	mov	esi, DWORD PTR _iiy$[esp+368]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	esi, 1
	add	eax, ecx
	cmp	esi, edx
	mov	DWORD PTR _iiy$[esp+368], esi
	mov	DWORD PTR tv2756[esp+368], eax
	jle	$LL27@PartialGet

; 1577 : 							for (iiy = miniy; iiy <= maxiy; iiy++)

	mov	ecx, DWORD PTR _iix$[esp+368]
$LN29@PartialGet:

; 1574 : 					{
; 1575 : 						IntGrain gt = *pT;
; 1576 : 						for (iix = minix; iix <= maxix; iix++)

	add	ecx, 1
	cmp	ecx, DWORD PTR _maxix$[esp+368]
	mov	DWORD PTR _iix$[esp+368], ecx
	jle	$LL30@PartialGet
	mov	ebx, DWORD PTR _ny$[esp+368]
$LN32@PartialGet:

; 1573 : 					for (;pT < pTE; pT++)

	mov	eax, DWORD PTR _pT$131479[esp+368]
	add	eax, 36					; 00000024H
	cmp	eax, DWORD PTR _pTE$131480[esp+368]
	mov	DWORD PTR _pT$131479[esp+368], eax
	jb	$LL33@PartialGet
$LN37@PartialGet:

; 1566 : 				for (iy = 0; iy < ny; iy++)

	mov	ecx, DWORD PTR tv1493[esp+368]
	mov	eax, DWORD PTR tv1543[esp+368]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR tv2829[esp+368], ecx
	cmp	eax, ebx
	jl	$LL238@PartialGet
	mov	ecx, DWORD PTR tv1539[esp+368]
$LN42@PartialGet:

; 1559 : 			idz = 1.0f / (tz - ZLayer[tr.BottomLayer]);
; 1560 : 	
; 1561 : 			for (ix = bx; ix < wx; ix++)

	add	DWORD PTR tv2883[esp+368], 8
	mov	eax, ecx
	cmp	eax, DWORD PTR _wx$[esp+368]
	mov	DWORD PTR _ix$[esp+368], eax
	jl	$LL237@PartialGet
$LN47@PartialGet:

; 1534 : 														}
; 1535 : 													break;
; 1536 : 													}
; 1537 : 												}
; 1538 : 											}
; 1539 : 										}
; 1540 : 									}
; 1541 : 								}
; 1542 : 						}
; 1543 : 					}
; 1544 : 				}
; 1545 : 			}
; 1546 : 
; 1547 : 
; 1548 : 		}
; 1549 : 	else
; 1550 : 	{
; 1551 : 
; 1552 : 		for (itr = 0; itr < T.TrialCount; itr++)

	mov	eax, DWORD PTR _itr$[esp+368]
	mov	esi, DWORD PTR tv2923[esp+368]
	add	DWORD PTR tv2895[esp+368], 256		; 00000100H
	add	eax, 1
	add	esi, 44					; 0000002cH
	cmp	eax, DWORD PTR [ebp+172]
	mov	DWORD PTR _itr$[esp+368], eax
	mov	DWORD PTR tv2923[esp+368], esi
	jl	$LL48@PartialGet

; 1585 : 									if (GetTickCount() > TimeLimit)

	jmp	$LN46@PartialGet
$LN195@PartialGet:

; 1586 : 									{
; 1587 : 										AR.Found = 0;

	mov	edx, DWORD PTR _AR$[esp+364]
	pop	edi
	pop	esi
	pop	ebp

; 1588 : 										return S_FALSE;

	mov	eax, ebx
	mov	DWORD PTR [edx+16], 0
	pop	ebx

; 1738 : 	};

	add	esp, 352				; 00000160H
	ret	4
?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z ENDP ; CSmartTrackerClass::PartialGetTracks2
_TEXT	ENDS
PUBLIC	?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z	; CSmartTrackerClass::TrackerThreadHook
EXTRN	__imp___endthreadex:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z
_TEXT	SEGMENT
_HEvsStart$ = -16					; size = 8
_HEvsReset$ = -8					; size = 8
_Context$ = 8						; size = 4
?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z PROC	; CSmartTrackerClass::TrackerThreadHook, COMDAT

; 1742 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 1743 : 	ActivationRecord *pAR = (ActivationRecord *)Context;
; 1744 : 	HANDLE HEvsStart[2], HEvsReset[2];
; 1745 : 	HEvsStart[0] = HEvsReset[0] = pAR->pThis->HTerminate;

	mov	esi, DWORD PTR _Context$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+1120]
	push	edi

; 1746 : 	HEvsStart[1] = pAR->pThis->HStart;
; 1747 : 	HEvsReset[1] = pAR->pThis->HReset;
; 1748 : 	while (WaitForMultipleObjects(2, HEvsStart, FALSE, INFINITE) != WAIT_OBJECT_0)

	mov	edi, DWORD PTR __imp__WaitForMultipleObjects@16
	mov	DWORD PTR _HEvsReset$[esp+32], ecx
	mov	DWORD PTR _HEvsStart$[esp+32], ecx
	mov	ecx, DWORD PTR [eax+1116]
	push	-1
	mov	DWORD PTR _HEvsStart$[esp+40], ecx
	mov	edx, DWORD PTR [eax+1124]
	push	0
	lea	eax, DWORD PTR _HEvsStart$[esp+40]
	push	eax
	push	2
	mov	DWORD PTR _HEvsReset$[esp+52], edx
	call	edi
	test	eax, eax
	je	SHORT $LN7@TrackerThr
	mov	ebx, DWORD PTR __imp__SetEvent@4
$LL3@TrackerThr:

; 1749 : 	{
; 1750 : 		pAR->pThis->PartialGetTracks2(*pAR);

	mov	ecx, DWORD PTR [esi]
	push	esi
	call	?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z ; CSmartTrackerClass::PartialGetTracks2

; 1751 : 		SetEvent(pAR->HFinished);

	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	call	ebx

; 1752 : 		if (WaitForMultipleObjects(2, HEvsReset, FALSE, INFINITE) == WAIT_OBJECT_0) break;

	push	-1
	push	0
	lea	edx, DWORD PTR _HEvsReset$[esp+40]
	push	edx
	push	2
	call	edi
	test	eax, eax
	je	SHORT $LN7@TrackerThr

; 1753 : 		SetEvent(pAR->HFinished);

	mov	eax, DWORD PTR [esi+20]
	push	eax
	call	ebx
	push	-1
	push	0
	lea	ecx, DWORD PTR _HEvsStart$[esp+40]
	push	ecx
	push	2
	call	edi
	test	eax, eax
	jne	SHORT $LL3@TrackerThr
$LN7@TrackerThr:

; 1754 : 		}
; 1755 : 	_endthreadex(S_OK);

	push	0
	call	DWORD PTR __imp___endthreadex
	add	esp, 4

; 1756 : 	return S_OK;
; 1757 : 	};

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z ENDP	; CSmartTrackerClass::TrackerThreadHook
_TEXT	ENDS
PUBLIC	?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z ; CSmartTrackerClass::GetTracks2
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z
_TEXT	SEGMENT
tv975 = -20						; size = 4
tv854 = -20						; size = 4
tv881 = -16						; size = 4
_seqlength$ = -16					; size = 4
tv864 = -12						; size = 4
_found$ = -12						; size = 4
tv391 = -8						; size = 4
_pTemp$ = -8						; size = 4
_maxtracksperthread$ = -8				; size = 4
_TempG$ = -4						; size = 4
tv826 = 8						; size = 4
tv462 = 8						; size = 4
tv456 = 8						; size = 4
_TempV$ = 8						; size = 1
_TimeLimit$ = 8						; size = 4
_this$ = 8						; size = 4
_pSpace$ = 12						; size = 4
_pMaxNumber$ = 16					; size = 4
_i$ = 20						; size = 4
_StartLayer$ = 20					; size = 4
_p$ = 24						; size = 4
_EndLayer$ = 24						; size = 4
?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z PROC ; CSmartTrackerClass::GetTracks2, COMDAT

; 1761 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 1762 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1763 : 
; 1764 : 	// TODO: Add your implementation code here
; 1765 : 
; 1766 : 	//CorrectChains();
; 1767 : 
; 1768 : 	int starttime = GetTickCount();

	mov	esi, DWORD PTR __imp__GetTickCount@0
	push	edi
	call	esi

; 1769 : 	char fdumpname[256];
; 1770 : 	
; 1771 : 	int p, i, j, k, maxtracksperthread = *pMaxNumber / T.Processors;

	mov	eax, DWORD PTR _pMaxNumber$[esp+32]
	mov	eax, DWORD PTR [eax]
	mov	ebp, DWORD PTR _this$[esp+32]
	cdq
	idiv	DWORD PTR [ebp+900]
	mov	ebx, eax

; 1772 : 	int found, seqlength;
; 1773 : 	Grain *pTemp;
; 1774 : 	int TempF, TempG;
; 1775 : 	bool TempV;
; 1776 : 
; 1777 : 	if (T.ShadowSigmaMeasures > 0)

	mov	eax, DWORD PTR [ebp+1044]
	test	eax, eax
	mov	DWORD PTR _maxtracksperthread$[esp+36], ebx
	mov	DWORD PTR tv456[esp+32], eax
	jle	SHORT $LN33@GetTracks2

; 1778 : 	{
; 1779 : 		T.ShadowSigmaX = T.ShadowSigmaXAccumulator / T.ShadowSigmaMeasures;

	fild	DWORD PTR tv456[esp+32]
	fstp	DWORD PTR tv462[esp+32]
	fld	DWORD PTR [ebp+1028]
	fld	DWORD PTR tv462[esp+32]
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR [ebp+1036]

; 1780 : 		T.ShadowSigmaY = T.ShadowSigmaYAccumulator / T.ShadowSigmaMeasures;

	fdivr	DWORD PTR [ebp+1032]
	fstp	DWORD PTR [ebp+1040]

; 1781 : 		}
; 1782 : 	else	

	jmp	SHORT $LN32@GetTracks2
$LN33@GetTracks2:

; 1783 : 		T.ShadowSigmaX = T.ShadowSigmaY = 0.0f;

	fldz
	fst	DWORD PTR [ebp+1040]
	fstp	DWORD PTR [ebp+1036]
$LN32@GetTracks2:

; 1784 : 	
; 1785 : 	int TimeLimit = GetTickCount() + T.MaxTrackingTime;

	call	esi
	add	eax, DWORD PTR [ebp+904]

; 1786 : 	for (p = 0; p < T.Processors; p++)

	xor	edx, edx
	cmp	DWORD PTR [ebp+900], edx
	mov	DWORD PTR _TimeLimit$[esp+32], eax
	jle	$LN54@GetTracks2
	mov	edi, DWORD PTR _pSpace$[esp+32]
	mov	esi, ebx
	shl	esi, 4
	sub	esi, ebx
	add	esi, esi
	xor	ecx, ecx
	add	esi, esi
	jmp	SHORT $LN31@GetTracks2
	npad	5
$LL56@GetTracks2:

; 1784 : 	
; 1785 : 	int TimeLimit = GetTickCount() + T.MaxTrackingTime;

	mov	ebx, DWORD PTR _maxtracksperthread$[esp+36]
$LN31@GetTracks2:

; 1787 : 	{
; 1788 : 		ThreadInfo[p].MaxTracks = maxtracksperthread;

	mov	eax, DWORD PTR [ebp+1136]
	mov	DWORD PTR [ecx+eax+12], ebx

; 1789 : 		ThreadInfo[p].pSpace = pSpace + p * maxtracksperthread;

	mov	eax, DWORD PTR [ebp+1136]
	mov	DWORD PTR [ecx+eax+8], edi

; 1790 : 		HEvs[p] = ThreadInfo[p].HFinished;

	mov	eax, DWORD PTR [ebp+1136]
	mov	eax, DWORD PTR [ecx+eax+20]
	mov	ebx, DWORD PTR [ebp+1140]
	mov	DWORD PTR [ebx+edx*4], eax

; 1791 : 		ThreadInfo[p].StartLayer = StartLayer;

	mov	eax, DWORD PTR [ebp+1136]
	mov	ebx, DWORD PTR _StartLayer$[esp+32]
	mov	DWORD PTR [ecx+eax+28], ebx

; 1792 : 		ThreadInfo[p].EndLayer = EndLayer;

	mov	eax, DWORD PTR [ebp+1136]
	mov	ebx, DWORD PTR _EndLayer$[esp+32]
	mov	DWORD PTR [ecx+eax+32], ebx

; 1793 : 		ThreadInfo[p].TimeLimit = TimeLimit;

	mov	eax, DWORD PTR [ebp+1136]
	mov	ebx, DWORD PTR _TimeLimit$[esp+32]
	mov	DWORD PTR [ecx+eax+36], ebx
	add	edx, 1
	add	edi, esi
	add	ecx, 40					; 00000028H
	cmp	edx, DWORD PTR [ebp+900]
	jl	SHORT $LL56@GetTracks2
$LN54@GetTracks2:

; 1794 : 		}
; 1795 : 	ResetEvent(HReset);

	mov	ecx, DWORD PTR [ebp+1124]
	mov	esi, DWORD PTR __imp__ResetEvent@4
	push	ecx
	call	esi

; 1796 : 	SetEvent(HStart);

	mov	edx, DWORD PTR [ebp+1116]
	mov	ebx, DWORD PTR __imp__SetEvent@4
	push	edx
	call	ebx

; 1797 : 	PartialGetTracks2(ThreadInfo[0]);

	mov	eax, DWORD PTR [ebp+1136]
	push	eax
	mov	ecx, ebp
	call	?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z ; CSmartTrackerClass::PartialGetTracks2

; 1798 : 
; 1799 : 	if (T.Processors > 1) WaitForMultipleObjects(T.Processors - 1, HEvs + 1, TRUE, INFINITE);

	mov	eax, DWORD PTR [ebp+900]
	cmp	eax, 1
	mov	edi, DWORD PTR __imp__WaitForMultipleObjects@16
	jle	SHORT $LN28@GetTracks2
	mov	ecx, DWORD PTR [ebp+1140]
	push	-1
	push	1
	add	ecx, 4
	push	ecx
	add	eax, -1
	push	eax
	call	edi
$LN28@GetTracks2:

; 1800 : 	ResetEvent(HStart);

	mov	edx, DWORD PTR [ebp+1116]
	push	edx
	call	esi

; 1801 : 	SetEvent(HReset);

	mov	eax, DWORD PTR [ebp+1124]
	push	eax
	call	ebx

; 1802 : 	if (T.Processors > 1) WaitForMultipleObjects(T.Processors - 1, HEvs + 1, TRUE, INFINITE);

	mov	eax, DWORD PTR [ebp+900]
	cmp	eax, 1
	jle	SHORT $LN27@GetTracks2
	mov	ecx, DWORD PTR [ebp+1140]
	push	-1
	push	1
	add	ecx, 4
	push	ecx
	add	eax, -1
	push	eax
	call	edi
$LN27@GetTracks2:

; 1803 : 
; 1804 : 	int endtime = GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0

; 1805 : /*	if (endtime - starttime > T.MaxTrackingTime * 2)
; 1806 : 	{
; 1807 : 		sprintf(fdumpname, "c:\\acq\\smt8a_%08X.txt", starttime);
; 1808 : 		FILE *f = fopen(fdumpname, "wt");
; 1809 : 		fprintf(f, "Time: %d", endtime - starttime);
; 1810 : 		fprintf(f, "StartLayer: %d EndLayer: %d", StartLayer, EndLayer);
; 1811 : 		fprintf(f, "\nLayers: %d", T.Layer);
; 1812 : 		fprintf(f, "\nGrains: %d", T.NumGrains);
; 1813 : 		fprintf(f, "\nCells:");				
; 1814 : 		int layer, icell, igrain;
; 1815 : 		for (layer = 0; layer < T.Layer; layer++)
; 1816 : 			for (icell = 0; icell < T.CellsInLayer; icell++)
; 1817 : 				fprintf(f, "\n%d\t%d\t%f\t%d", layer, icell, T.ZLayer[layer], T.CellSpace[layer * T.CellsInLayer + icell].Free);
; 1818 : 		for (layer = 0; layer < T.Layer; layer++)
; 1819 : 			for (icell = 0; icell < T.CellsInLayer; icell++)
; 1820 : 				for (igrain = 0; igrain < T.CellSpace[layer * T.CellsInLayer + icell].Free; igrain++)
; 1821 : 					fprintf(f, "\n%d\t%d\t%f\t%d\t%f\t%f\t%d", layer, icell, T.ZLayer[layer], T.CellSpace[layer * T.CellsInLayer + icell].Free, T.CellSpace[layer * T.CellsInLayer + icell].FirstG[igrain].Xcm, T.CellSpace[layer * T.CellsInLayer + icell].FirstG[igrain].Ycm, T.CellSpace[layer * T.CellsInLayer + icell].FirstG[igrain].Area);
; 1822 : 		fclose(f);
; 1823 : 		}
; 1824 : */
; 1825 : 
; 1826 : 	for (p = 0; p < T.Processors; p++)

	xor	edi, edi
	cmp	DWORD PTR [ebp+900], edi
	mov	DWORD PTR _p$[esp+32], edi
	jle	$LN24@GetTracks2
	xor	edx, edx
	mov	DWORD PTR tv864[esp+36], edx
	npad	11
$LL26@GetTracks2:

; 1827 : 		for (i = 0; i < ThreadInfo[p].Found; i++)

	mov	eax, DWORD PTR [ebp+1136]
	cmp	DWORD PTR [edx+eax+16], edi
	mov	DWORD PTR _i$[esp+32], edi
	jle	$LN25@GetTracks2
	mov	DWORD PTR tv854[esp+36], edi
	npad	8
$LL23@GetTracks2:

; 1828 : 		{
; 1829 : 			Track2 &K = ThreadInfo[p].pSpace[i];

	mov	ecx, DWORD PTR [ebp+1136]
	mov	edi, DWORD PTR [edx+ecx+8]
	add	edi, DWORD PTR tv854[esp+36]

; 1830 : 			seqlength = K.Grains;
; 1831 : #if 1
; 1832 : 			for (j = 0; (j < seqlength) && ((IntTrackGrain *)K.pGrains)[j].T.pG->TrackLength < seqlength; j++);

	xor	eax, eax
	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	mov	DWORD PTR _seqlength$[esp+36], esi
	jle	$LN7@GetTracks2

; 1828 : 		{
; 1829 : 			Track2 &K = ThreadInfo[p].pSpace[i];

	mov	ecx, DWORD PTR [edi+12]
$LL20@GetTracks2:

; 1830 : 			seqlength = K.Grains;
; 1831 : #if 1
; 1832 : 			for (j = 0; (j < seqlength) && ((IntTrackGrain *)K.pGrains)[j].T.pG->TrackLength < seqlength; j++);

	mov	ebx, DWORD PTR [ecx]
	cmp	DWORD PTR [ebx+12], esi
	jge	$LN18@GetTracks2
	add	eax, 1
	add	ecx, 16					; 00000010H
	cmp	eax, esi
	jl	SHORT $LL20@GetTracks2
$LN57@GetTracks2:

; 1839 : 				}
; 1840 : 			for (j = 0; j < seqlength; j++)

	xor	edx, edx
	mov	DWORD PTR tv826[esp+32], edx
	mov	DWORD PTR tv391[esp+36], esi
$LL16@GetTracks2:
	mov	eax, DWORD PTR [edi+12]
	add	eax, DWORD PTR tv826[esp+32]

; 1841 : 			{
; 1842 : 				IntTrackGrain *pIG = ((IntTrackGrain *)K.pGrains) + j;
; 1843 : 				if (pIG->T.pG->pTrack2)

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, edx
	je	SHORT $LN15@GetTracks2

; 1846 : 					for (k = 0; k < N.Grains; k++)

	cmp	DWORD PTR [ecx+4], edx
	jbe	SHORT $LN58@GetTracks2

; 1844 : 				{
; 1845 : 					Track2 &N = *pIG->T.pG->pTrack2;

	xor	esi, esi
$LL12@GetTracks2:

; 1846 : 					for (k = 0; k < N.Grains; k++)

	mov	eax, DWORD PTR [ecx+12]

; 1847 : 					{
; 1848 : 						IntTrackGrain *pIJ = ((IntTrackGrain *)N.pGrains) + k;
; 1849 : 						pIJ->T.pG->pTrack2 = 0;

	mov	ebx, DWORD PTR [eax+esi]
	add	eax, esi
	mov	DWORD PTR [ebx+16], 0

; 1850 : 						pIJ->T.pG->TrackLength = 0;

	mov	eax, DWORD PTR [eax]
	add	edx, 1
	mov	DWORD PTR [eax+12], 0
	add	esi, 16					; 00000010H
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LL12@GetTracks2

; 1846 : 					for (k = 0; k < N.Grains; k++)

	mov	esi, DWORD PTR _seqlength$[esp+36]
$LN58@GetTracks2:

; 1851 : 						}
; 1852 : 					N.Valid = false;
; 1853 : 					N.Grains = 0;

	xor	edx, edx
	mov	BYTE PTR [ecx+56], 0
	mov	DWORD PTR [ecx+4], edx
$LN15@GetTracks2:
	add	DWORD PTR tv826[esp+32], 16		; 00000010H
	sub	DWORD PTR tv391[esp+36], 1
	jne	SHORT $LL16@GetTracks2

; 1854 : 					}
; 1855 : 				}
; 1856 : 
; 1857 : 			for (j = 0; j < seqlength; j++)

	xor	ecx, ecx
	mov	edx, esi
$LL9@GetTracks2:
	mov	eax, DWORD PTR [edi+12]

; 1858 : 			{
; 1859 : 				IntTrackGrain *pIG = ((IntTrackGrain *)K.pGrains) + j;
; 1860 : 				pIG->T.pG->pTrack2 = &K;

	mov	ebx, DWORD PTR [eax+ecx]
	add	eax, ecx
	mov	DWORD PTR [ebx+16], edi

; 1861 : 				pIG->T.pG->TrackLength = seqlength;

	mov	eax, DWORD PTR [eax]
	add	ecx, 16					; 00000010H
	sub	edx, 1
	mov	DWORD PTR [eax+12], esi
	jne	SHORT $LL9@GetTracks2

; 1854 : 					}
; 1855 : 				}
; 1856 : 
; 1857 : 			for (j = 0; j < seqlength; j++)

	mov	edx, DWORD PTR tv864[esp+36]
$LN7@GetTracks2:

; 1862 : 				}
; 1863 : #endif
; 1864 : 			K.Valid = true;

	mov	BYTE PTR [edi+56], 1
$LN22@GetTracks2:

; 1827 : 		for (i = 0; i < ThreadInfo[p].Found; i++)

	mov	eax, DWORD PTR _i$[esp+32]
	mov	ecx, DWORD PTR [ebp+1136]
	add	DWORD PTR tv854[esp+36], 60		; 0000003cH
	add	eax, 1
	cmp	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _i$[esp+32], eax
	jl	$LL23@GetTracks2
	xor	edi, edi
$LN25@GetTracks2:

; 1805 : /*	if (endtime - starttime > T.MaxTrackingTime * 2)
; 1806 : 	{
; 1807 : 		sprintf(fdumpname, "c:\\acq\\smt8a_%08X.txt", starttime);
; 1808 : 		FILE *f = fopen(fdumpname, "wt");
; 1809 : 		fprintf(f, "Time: %d", endtime - starttime);
; 1810 : 		fprintf(f, "StartLayer: %d EndLayer: %d", StartLayer, EndLayer);
; 1811 : 		fprintf(f, "\nLayers: %d", T.Layer);
; 1812 : 		fprintf(f, "\nGrains: %d", T.NumGrains);
; 1813 : 		fprintf(f, "\nCells:");				
; 1814 : 		int layer, icell, igrain;
; 1815 : 		for (layer = 0; layer < T.Layer; layer++)
; 1816 : 			for (icell = 0; icell < T.CellsInLayer; icell++)
; 1817 : 				fprintf(f, "\n%d\t%d\t%f\t%d", layer, icell, T.ZLayer[layer], T.CellSpace[layer * T.CellsInLayer + icell].Free);
; 1818 : 		for (layer = 0; layer < T.Layer; layer++)
; 1819 : 			for (icell = 0; icell < T.CellsInLayer; icell++)
; 1820 : 				for (igrain = 0; igrain < T.CellSpace[layer * T.CellsInLayer + icell].Free; igrain++)
; 1821 : 					fprintf(f, "\n%d\t%d\t%f\t%d\t%f\t%f\t%d", layer, icell, T.ZLayer[layer], T.CellSpace[layer * T.CellsInLayer + icell].Free, T.CellSpace[layer * T.CellsInLayer + icell].FirstG[igrain].Xcm, T.CellSpace[layer * T.CellsInLayer + icell].FirstG[igrain].Ycm, T.CellSpace[layer * T.CellsInLayer + icell].FirstG[igrain].Area);
; 1822 : 		fclose(f);
; 1823 : 		}
; 1824 : */
; 1825 : 
; 1826 : 	for (p = 0; p < T.Processors; p++)

	mov	eax, DWORD PTR _p$[esp+32]
	add	eax, 1
	add	edx, 40					; 00000028H
	cmp	eax, DWORD PTR [ebp+900]
	mov	DWORD PTR _p$[esp+32], eax
	mov	DWORD PTR tv864[esp+36], edx
	jl	$LL26@GetTracks2
$LN24@GetTracks2:

; 1876 : 	pTemp = (Grain *)malloc(sizeof(Grain) * T.LayerNum * T.InitialMultiplicity);

	mov	eax, DWORD PTR [ebp+932]
	imul	eax, DWORD PTR [ebp+144]
	mov	edx, DWORD PTR [ebp+1136]
	mov	esi, DWORD PTR [edx+16]
	shl	eax, 4
	push	eax
	mov	DWORD PTR _found$[esp+40], esi
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 1877 : 	for (p = 1; p < T.Processors; p++)

	cmp	DWORD PTR [ebp+900], 1
	mov	DWORD PTR _pTemp$[esp+36], eax
	mov	DWORD PTR _p$[esp+32], 1
	jle	$LN4@GetTracks2

; 1865 : 			}
; 1866 : /*
; 1867 : 	if ((endtime = GetTickCount()) > TimeLimit) 
; 1868 : 	{
; 1869 : 		sprintf(fdumpname, "c:\\acq\\smt8b_%08X.txt", starttime);
; 1870 : 		FILE *f = fopen(fdumpname, "wt");
; 1871 : 		fprintf(f, "Time: %d TimeLimit: %d", endtime - starttime, TimeLimit);
; 1872 : 		fclose(f);
; 1873 : 		}
; 1874 : */
; 1875 : 	found = ThreadInfo[0].Found;

	mov	DWORD PTR tv975[esp+36], 40		; 00000028H
$LL6@GetTracks2:

; 1878 : 		for (i = 0; i < ThreadInfo[p].Found; i++)

	mov	ecx, DWORD PTR [ebp+1136]
	mov	edx, DWORD PTR tv975[esp+36]
	cmp	DWORD PTR [edx+ecx+16], edi
	mov	DWORD PTR _i$[esp+32], edi
	jle	$LN5@GetTracks2
	mov	edx, DWORD PTR _pSpace$[esp+32]
	mov	eax, esi
	xor	ecx, ecx
	shl	eax, 4
	sub	eax, esi
	mov	DWORD PTR tv881[esp+36], ecx
	lea	esi, DWORD PTR [edx+eax*4+56]
	jmp	SHORT $LN3@GetTracks2
$LN18@GetTracks2:

; 1833 : 	
; 1834 : 			if (j < seqlength) 

	cmp	eax, esi
	jge	$LN57@GetTracks2

; 1835 : 			{
; 1836 : 				K.Valid = false;

	mov	BYTE PTR [edi+56], 0

; 1837 : 				K.Grains = 0;

	mov	DWORD PTR [edi+4], 0

; 1838 : 				continue;

	jmp	$LN22@GetTracks2
	npad	9
$LL55@GetTracks2:

; 1878 : 		for (i = 0; i < ThreadInfo[p].Found; i++)

	mov	ecx, DWORD PTR tv881[esp+36]
$LN3@GetTracks2:

; 1879 : 		{
; 1880 : 			TempF = ThreadInfo[p].pSpace[i].Field;
; 1881 : 			TempG = ThreadInfo[p].pSpace[i].Grains;

	mov	edx, DWORD PTR tv975[esp+36]
	mov	eax, DWORD PTR [ebp+1136]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx+edx+4]

; 1882 : 			//if (TempV = ThreadInfo[p].pSpace[i].Valid)
; 1883 : 			TempV = ThreadInfo[p].pSpace[i].Valid;

	cmp	BYTE PTR [ecx+edx+56], 0
	lea	ebx, DWORD PTR [ecx+edx]
	setne	BYTE PTR _TempV$[esp+32]

; 1884 : 			memcpy(pTemp, ThreadInfo[p].pSpace[i].pGrains, sizeof(Grain) * TempG);

	mov	eax, edx
	mov	ecx, DWORD PTR [ecx+eax+12]
	mov	edx, DWORD PTR _pTemp$[esp+36]
	mov	DWORD PTR _TempG$[esp+36], edi
	shl	edi, 4
	push	edi
	push	ecx
	push	edx
	call	_memcpy

; 1885 : /* THESE LINES DISABLE TRACK ORDERING */
; 1886 : #if 1
; 1887 : 			j = found;
; 1888 : #else
; 1889 : 			for (j = 0; (j < found) && (pSpace[j].Field < TempF); j++);
; 1890 : 			for (k = found; k > j; k--)
; 1891 : 			{
; 1892 : 				pSpace[k].Field = pSpace[k - 1].Field;
; 1893 : 				pSpace[k].Grains = pSpace[k - 1].Grains;
; 1894 : 				//if (pSpace[k].Valid = pSpace[k - 1].Valid)
; 1895 : 				pSpace[k].Valid = pSpace[k - 1].Valid;
; 1896 : 				memcpy(pSpace[k].pGrains, pSpace[k - 1].pGrains, sizeof(Grain) * pSpace[k].Grains);
; 1897 : 				}
; 1898 : #endif
; 1899 : /* END OF TRACK ORDERING DISABLE */
; 1900 : 			pSpace[j].Field = TempF;

	mov	eax, DWORD PTR [ebx]

; 1901 : 			pSpace[j].Grains = TempG;

	mov	ecx, DWORD PTR _TempG$[esp+48]

; 1902 : 			//if (pSpace[j].Valid = TempV)
; 1903 : 			pSpace[j].Valid = TempV;

	mov	dl, BYTE PTR _TempV$[esp+44]
	mov	DWORD PTR [esi-56], eax

; 1904 : 			memcpy(pSpace[j].pGrains, pTemp, sizeof(Grain) * TempG);

	mov	eax, DWORD PTR _pTemp$[esp+48]
	push	edi
	mov	DWORD PTR [esi-52], ecx
	mov	ecx, DWORD PTR [esi-44]
	push	eax
	push	ecx
	mov	BYTE PTR [esi], dl
	call	_memcpy
	mov	eax, DWORD PTR _i$[esp+56]
	mov	edx, DWORD PTR [ebp+1136]
	mov	ecx, DWORD PTR tv975[esp+60]

; 1905 : 			found++;

	add	DWORD PTR _found$[esp+60], 1
	add	DWORD PTR tv881[esp+60], 60		; 0000003cH
	add	eax, 1
	add	esp, 24					; 00000018H
	add	esi, 60					; 0000003cH
	cmp	eax, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _i$[esp+32], eax
	jl	$LL55@GetTracks2
	mov	esi, DWORD PTR _found$[esp+36]
	xor	edi, edi
$LN5@GetTracks2:
	mov	eax, DWORD PTR _p$[esp+32]
	add	DWORD PTR tv975[esp+36], 40		; 00000028H
	add	eax, 1
	cmp	eax, DWORD PTR [ebp+900]
	mov	DWORD PTR _p$[esp+32], eax
	jl	$LL6@GetTracks2
$LN4@GetTracks2:

; 1906 : 			}
; 1907 : 	free(pTemp);

	mov	edx, DWORD PTR _pTemp$[esp+36]
	push	edx
	call	DWORD PTR __imp__free

; 1908 : 
; 1909 : /*
; 1910 : 	if ((endtime = GetTickCount()) > TimeLimit) 
; 1911 : 	{
; 1912 : 		sprintf(fdumpname, "c:\\acq\\smt8c_%08X.txt", starttime);
; 1913 : 		FILE *f = fopen(fdumpname, "wt");
; 1914 : 		fprintf(f, "Time: %d TimeLimit: %d", endtime - starttime, TimeLimit);
; 1915 : 		for (p = 0; p < T.Processors; p++)
; 1916 : 			fprintf(f, "\nThread: %d Found: %d", p, ThreadInfo[p].Found);
; 1917 : 
; 1918 : 		fclose(f);
; 1919 : 		}
; 1920 : */
; 1921 : 	*pMaxNumber = FinalizeTracks(found, pSpace);

	mov	eax, DWORD PTR _pSpace$[esp+36]
	add	esp, 4
	push	eax
	push	esi
	mov	ecx, ebp
	call	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z ; CSmartTrackerClass::FinalizeTracks
	mov	ecx, DWORD PTR _pMaxNumber$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx], eax

; 1922 : /*
; 1923 : 	if ((endtime = GetTickCount()) > TimeLimit) 
; 1924 : 	{
; 1925 : 		sprintf(fdumpname, "c:\\acq\\smt8d_%08X.txt", starttime);
; 1926 : 		FILE *f = fopen(fdumpname, "wt");
; 1927 : 		fprintf(f, "Time: %d TimeLimit: %d", endtime - starttime, TimeLimit);
; 1928 : 		fclose(f);
; 1929 : 		}
; 1930 : */
; 1931 : 	return S_OK;

	xor	eax, eax
	pop	ebx

; 1932 : 	}

	add	esp, 20					; 00000014H
	ret	20					; 00000014H
?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z ENDP ; CSmartTrackerClass::GetTracks2
_TEXT	ENDS
PUBLIC	?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z ; CSmartTrackerClass::SetConfig
EXTRN	__imp___beginthreadex:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z
_TEXT	SEGMENT
_dummy$130657 = 8					; size = 4
_this$ = 8						; size = 4
_pConfig$ = 12						; size = 4
?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z PROC ; CSmartTrackerClass::SetConfig, COMDAT

; 257  : 	// TODO: Add your implementation code here
; 258  : 	OkToRun = false;
; 259  : 	if (GetData(*pConfig, ConfigDataN, ConfigDataQDI, &T, false) != ConfigDataN) return S_FALSE;

	mov	eax, DWORD PTR _pConfig$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _this$[esp+4]
	push	0
	lea	ebx, DWORD PTR [esi+136]
	push	ebx
	push	OFFSET ?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	eax
	mov	BYTE PTR [esi+1108], 0
	call	?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ; GetData
	add	esp, 20					; 00000014H
	cmp	eax, 200				; 000000c8H
	je	SHORT $LN22@SetConfig
	pop	esi
	mov	eax, 1
	pop	ebx

; 314  : }

	ret	8
$LN22@SetConfig:

; 260  : 
; 261  : 	if (T.GrainSpace) GlobalFree(T.GrainSpace);

	mov	eax, DWORD PTR [esi+956]
	test	eax, eax
	push	ebp
	mov	ebp, DWORD PTR __imp__GlobalFree@4
	je	SHORT $LN21@SetConfig
	push	eax
	call	ebp
$LN21@SetConfig:

; 262  : 	if (!(T.GrainSpace = (IntGrain *)GlobalAlloc(GMEM_FIXED, sizeof(IntGrain) * T.MaxGrains)))

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax+eax*8]
	push	edi
	mov	edi, DWORD PTR __imp__GlobalAlloc@8
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	call	edi
	test	eax, eax
	mov	DWORD PTR [esi+956], eax

; 263  : 		return S_FALSE;

	je	$LN32@SetConfig

; 264  : 	if (T.ZLayer) GlobalFree(T.ZLayer);

	mov	eax, DWORD PTR [esi+960]
	test	eax, eax
	je	SHORT $LN19@SetConfig
	push	eax
	call	ebp
$LN19@SetConfig:

; 265  : 	if (!(T.ZLayer = (float *)GlobalAlloc(GMEM_FIXED, sizeof(float) * T.LayerNum)))

	mov	edx, DWORD PTR [esi+140]
	add	edx, edx
	add	edx, edx
	push	edx
	push	0
	call	edi
	test	eax, eax
	mov	DWORD PTR [esi+960], eax

; 266  :    		return S_FALSE;

	je	$LN32@SetConfig

; 267  : 	if (T.LayerGrains) GlobalFree(T.LayerGrains);

	mov	eax, DWORD PTR [esi+964]
	test	eax, eax
	je	SHORT $LN17@SetConfig
	push	eax
	call	ebp
$LN17@SetConfig:

; 268  : 	if (!(T.LayerGrains = (IntGrain **)GlobalAlloc(GMEM_FIXED, sizeof(IntGrain *) * T.LayerNum)))

	mov	eax, DWORD PTR [esi+140]
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	call	edi
	test	eax, eax
	mov	DWORD PTR [esi+964], eax

; 269  :    		return S_FALSE;

	je	$LN32@SetConfig

; 270  : 	T.CellsInLayer = T.CellNumX * T.CellNumY;

	mov	ecx, DWORD PTR [esi+152]
	imul	ecx, DWORD PTR [esi+148]

; 271  : 	if (T.CellSpace) GlobalFree(T.CellSpace);

	mov	eax, DWORD PTR [esi+968]
	test	eax, eax
	mov	DWORD PTR [esi+972], ecx
	je	SHORT $LN15@SetConfig
	push	eax
	call	ebp
$LN15@SetConfig:

; 272  : 	if (!(T.CellSpace = (Cell *)GlobalAlloc(GMEM_FIXED, sizeof(Cell) * (T.CellsInLayer)*(T.LayerNum))))

	mov	edx, DWORD PTR [esi+972]
	imul	edx, DWORD PTR [esi+140]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	push	0
	call	edi
	test	eax, eax
	mov	DWORD PTR [esi+968], eax

; 273  :    		return S_FALSE;

	je	SHORT $LN32@SetConfig

; 274  : 	if (T.pDeltaData) GlobalFree(T.pDeltaData);

	mov	eax, DWORD PTR [esi+1064]
	test	eax, eax
	je	SHORT $LN13@SetConfig
	push	eax
	call	ebp
$LN13@SetConfig:

; 275  : 	if (!(T.pDeltaData = (float *)GlobalAlloc(GMEM_FIXED, (4 * sizeof(float) + sizeof(IntCluster **)) * T.MaxGrains)))

	mov	eax, DWORD PTR [ebx]
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	call	edi
	test	eax, eax
	mov	DWORD PTR [esi+1064], eax

; 276  : 		return S_FALSE;

	je	SHORT $LN32@SetConfig

; 277  : 	else
; 278  : 	{
; 279  : 		T.pX = T.pDeltaData;
; 280  : 		T.pY = T.pX + T.MaxGrains;

	mov	ecx, DWORD PTR [ebx]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [esi+1068], eax
	add	eax, ecx
	mov	DWORD PTR [esi+1072], eax

; 281  : 		T.pDX = T.pY + T.MaxGrains;

	add	eax, ecx
	mov	DWORD PTR [esi+1076], eax

; 282  : 		T.pDY = T.pDX + T.MaxGrains;

	add	eax, ecx
	mov	DWORD PTR [esi+1080], eax

; 283  : 		T.pReplicas = (IntCluster **)(void *)(T.pDY + T.MaxGrains);

	add	eax, ecx

; 284  : 		}
; 285  : 
; 286  : 	if (!ResetDeltaHisto()) return S_FALSE;

	lea	ecx, DWORD PTR [esi-4]
	mov	DWORD PTR [esi+1084], eax
	call	?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ ; CSmartTrackerClass::ResetDeltaHisto
	test	al, al
	jne	SHORT $LN10@SetConfig
$LN32@SetConfig:
	pop	edi
	pop	ebp
	pop	esi
	mov	eax, 1
	pop	ebx

; 314  : }

	ret	8
$LN10@SetConfig:

; 287  : 	SetEvent(HTerminate);

	mov	ecx, DWORD PTR [esi+1116]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4

; 288  : 	int i;
; 289  : 	for (i = 1; i < MaxProcessors; i++)

	mov	ebp, 1
	cmp	DWORD PTR [esi+1124], ebp
	jle	SHORT $LN29@SetConfig
	mov	ebx, DWORD PTR __imp__CloseHandle@4
	mov	edi, 40					; 00000028H
	npad	7
$LL9@SetConfig:

; 290  : 		if (ThreadInfo[i].HThread)

	mov	edx, DWORD PTR [esi+1132]
	mov	eax, DWORD PTR [edi+edx+24]
	test	eax, eax
	je	SHORT $LN8@SetConfig

; 291  : 		{
; 292  : 			WaitForSingleObject(ThreadInfo[i].HThread, INFINITE);

	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 293  : 			CloseHandle(ThreadInfo[i].HThread);

	mov	eax, DWORD PTR [esi+1132]
	mov	ecx, DWORD PTR [edi+eax+24]
	push	ecx
	call	ebx

; 294  : 			CloseHandle(ThreadInfo[i].HFinished);

	mov	edx, DWORD PTR [esi+1132]
	mov	eax, DWORD PTR [edi+edx+20]
	push	eax
	call	ebx

; 295  : 			ThreadInfo[i].HThread = 0;

	mov	ecx, DWORD PTR [esi+1132]
	xor	eax, eax
	mov	DWORD PTR [edi+ecx+24], eax

; 296  : 			ThreadInfo[i].HFinished = 0;

	mov	edx, DWORD PTR [esi+1132]
	mov	DWORD PTR [edi+edx+20], eax
$LN8@SetConfig:
	add	ebp, 1
	add	edi, 40					; 00000028H
	cmp	ebp, DWORD PTR [esi+1124]
	jl	SHORT $LL9@SetConfig
$LN29@SetConfig:

; 297  : 			};
; 298  : 	ResetEvent(HTerminate);

	mov	eax, DWORD PTR [esi+1116]
	mov	edi, DWORD PTR __imp__ResetEvent@4
	push	eax
	call	edi

; 299  : 	ResetEvent(HStart);

	mov	ecx, DWORD PTR [esi+1112]
	push	ecx
	call	edi

; 300  : 	ResetEvent(HReset);

	mov	edx, DWORD PTR [esi+1120]
	push	edx
	call	edi

; 301  : 	ThreadInfo[0].ThreadIndex = 0;

	mov	eax, DWORD PTR [esi+1132]
	mov	DWORD PTR [eax+4], 0

; 302  : 	ConfigMaxProcessors_backup = T.Processors;

	mov	eax, DWORD PTR [esi+896]

; 303  : 	if (T.Processors == 0 || T.Processors > MaxProcessors) T.Processors = MaxProcessors;

	test	eax, eax
	mov	DWORD PTR [esi+1128], eax
	je	SHORT $LN4@SetConfig
	cmp	eax, DWORD PTR [esi+1124]
	jle	SHORT $LN5@SetConfig
$LN4@SetConfig:
	mov	ecx, DWORD PTR [esi+1124]
	mov	DWORD PTR [esi+896], ecx
$LN5@SetConfig:

; 304  : 	for (i = 1; i < T.Processors; i++)

	mov	ebp, 1
	cmp	DWORD PTR [esi+896], ebp
	jle	SHORT $LN1@SetConfig
	mov	ebx, DWORD PTR __imp__CreateEventA@16
	lea	edi, DWORD PTR [ebp+39]
	npad	3
$LL3@SetConfig:

; 305  : 	{
; 306  : 		unsigned dummy;
; 307  : 		ThreadInfo[i].HFinished = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	ebx
	mov	edx, DWORD PTR [esi+1132]
	mov	DWORD PTR [edi+edx+20], eax

; 308  : 		ThreadInfo[i].pThis = this;

	mov	ecx, DWORD PTR [esi+1132]
	lea	eax, DWORD PTR [esi-4]
	mov	DWORD PTR [edi+ecx], eax

; 309  : 		ThreadInfo[i].ThreadIndex = i;

	mov	edx, DWORD PTR [esi+1132]

; 310  : 		ThreadInfo[i].HThread = (HANDLE)_beginthreadex(NULL, 0, TrackerThreadHook, ThreadInfo + i, 0, &dummy);

	lea	eax, DWORD PTR _dummy$130657[esp+12]
	push	eax
	mov	DWORD PTR [edi+edx+4], ebp
	mov	ecx, DWORD PTR [esi+1132]
	push	0
	add	ecx, edi
	push	ecx
	push	OFFSET ?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z ; CSmartTrackerClass::TrackerThreadHook
	push	0
	push	0
	call	DWORD PTR __imp___beginthreadex
	mov	edx, DWORD PTR [esi+1132]
	mov	DWORD PTR [edi+edx+24], eax
	add	ebp, 1
	add	esp, 24					; 00000018H
	add	edi, 40					; 00000028H
	cmp	ebp, DWORD PTR [esi+896]
	jl	SHORT $LL3@SetConfig
$LN1@SetConfig:
	pop	edi
	pop	ebp

; 311  : 		}
; 312  : 	OkToRun = true;

	mov	BYTE PTR [esi+1108], 1
	pop	esi

; 313  : 	return S_OK;

	xor	eax, eax
	pop	ebx

; 314  : }

	ret	8
?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z ENDP ; CSmartTrackerClass::SetConfig
_TEXT	ENDS
PUBLIC	?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z ; CSmartTrackerClass::GetTracks
; Function compile flags: /Ogtpy
;	COMDAT ?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z
_TEXT	SEGMENT
tv1661 = -320						; size = 4
tv1660 = -320						; size = 4
tv1610 = -320						; size = 4
tv1609 = -320						; size = 4
tv1561 = -320						; size = 4
tv1560 = -320						; size = 4
tv1549 = -320						; size = 4
_slope2$134247 = -320					; size = 4
_slope2$134241 = -320					; size = 4
_ExpX$ = -320						; size = 4
tv1683 = -316						; size = 4
tv1682 = -316						; size = 4
_dz$131114 = -316					; size = 4
tv1672 = -312						; size = 4
tv1565 = -312						; size = 4
_pTrg$131111 = -312					; size = 4
_ExpY$ = -312						; size = 4
_cdz$131108 = -312					; size = 4
_ldz$131107 = -312					; size = 4
_SlopeY$ = -308						; size = 4
_SlopeX$ = -304						; size = 4
_DirX$ = -300						; size = 4
_seqlength$131115 = -296				; size = 4
_dirtol$ = -292						; size = 4
_DirY$ = -288						; size = 4
_ZLayer$ = -284						; size = 4
_pTempGrains$ = -280					; size = 4
_CellSpace$ = -276					; size = 4
_topv$131124 = -272					; size = 12
_pT$131083 = -260					; size = 4
_slope2$134229 = -256					; size = 4
_ir$ = -256						; size = 4
_pB$131096 = -252					; size = 4
_tz$ = -248						; size = 4
_idz$ = -244						; size = 4
_miniy$ = -240						; size = 4
_ny$ = -236						; size = 4
tv1981 = -232						; size = 4
tv1772 = -232						; size = 4
tv171 = -228						; size = 4
_tp$131070 = -228					; size = 4
_maxix$ = -224						; size = 4
_nx$ = -220						; size = 4
_NTracks$ = -216					; size = 4
_bottomv$131125 = -212					; size = 12
_avgdz$ = -200						; size = 4
_minix$ = -196						; size = 4
_maxiy$ = -192						; size = 4
tv1944 = -188						; size = 4
_Slope2$ = -184						; size = 4
tv1881 = -180						; size = 4
_itr$ = -176						; size = 4
tv1932 = -172						; size = 4
tv1785 = -168						; size = 4
tv922 = -164						; size = 4
tv1849 = -160						; size = 4
_iix$ = -156						; size = 4
tv912 = -152						; size = 4
_MaxSlope$ = -148					; size = 4
_pTE$131084 = -144					; size = 4
_bp$131071 = -140					; size = 4
_tsl$ = -136						; size = 4
_CellsInLayer$ = -132					; size = 4
_pBE$131097 = -128					; size = 4
_td$ = -124						; size = 4
_tinf$ = -120						; size = 4
_tr$131067 = -116					; size = 44
_gt$131088 = -72					; size = 36
_gb$131101 = -36					; size = 36
_this$ = 8						; size = 4
_pSpace$ = 12						; size = 4
_pMaxNumber$ = 16					; size = 4
_StartLayer$ = 20					; size = 4
_EndLayer$ = 24						; size = 4
?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z PROC ; CSmartTrackerClass::GetTracks, COMDAT

; 943  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 372				; 00000174H
	push	ebx

; 944  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 945  : 
; 946  : 	// TODO: Add your implementation code here
; 947  : 
; 948  : 	int nx, ny;
; 949  : 	int lay;
; 950  : 	int itr, ibr;
; 951  : 	int NTracks = 0;
; 952  : 	float *ZLayer = T.ZLayer;

	mov	ebx, DWORD PTR _this$[ebp]

; 953  : 	float tz;
; 954  : 	int CellsInLayer = T.CellsInLayer;

	mov	eax, DWORD PTR [ebx+976]

; 955  : 	Cell *CellSpace = T.CellSpace;
; 956  : 	float MaxSlope = T.MaxSlope;

	fld	DWORD PTR [ebx+896]
	mov	ecx, DWORD PTR [ebx+972]
	fstp	DWORD PTR _MaxSlope$[esp+376]

; 957  : 	float MinSlope = T.MinSlope;
; 958  : 
; 959  : 	int ix, iy, iix, iiy, eix, eiy;
; 960  : 	int minix, maxix, miniy, maxiy;
; 961  : 	float Slope2;
; 962  : 	float SlopeX, SlopeY, ExpX, ExpY, DirX, DirY;
; 963  : 	float dirtol;
; 964  : 	int it, ib, ir;
; 965  : 	float idz;
; 966  : 
; 967  : 	nx = T.CellNumX;

	mov	edx, DWORD PTR [ebx+152]
	mov	DWORD PTR _CellsInLayer$[esp+376], eax

; 968  : 	ny = T.CellNumY;

	mov	eax, DWORD PTR [ebx+156]
	push	esi
	mov	DWORD PTR _ny$[esp+380], eax

; 969  : 
; 970  : 	if (*pMaxNumber <= 0)

	mov	eax, DWORD PTR _pMaxNumber$[ebp]
	cmp	DWORD PTR [eax], 0
	push	edi
	mov	edi, DWORD PTR [ebx+964]
	mov	DWORD PTR _NTracks$[esp+384], 0
	mov	DWORD PTR _ZLayer$[esp+384], edi
	mov	DWORD PTR _CellSpace$[esp+384], ecx
	mov	DWORD PTR _nx$[esp+384], edx
	jg	SHORT $LN52@GetTracks

; 971  : 	{
; 972  : 		*pMaxNumber = 0;

	mov	DWORD PTR [eax], 0

; 1121 : 	return S_OK;

	xor	eax, eax

; 1122 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN52@GetTracks:

; 973  : 		return S_OK;
; 974  : 		}
; 975  : 
; 976  : 	if (EndLayer >= T.Layer) EndLayer = T.Layer - 1;

	mov	eax, DWORD PTR [ebx+1016]
	mov	esi, DWORD PTR _EndLayer$[ebp]
	cmp	esi, eax
	jl	SHORT $LN51@GetTracks
	add	eax, -1
	mov	DWORD PTR _EndLayer$[ebp], eax
	mov	esi, eax
$LN51@GetTracks:

; 977  : 
; 978  : 	IntGrain **pTempGrains = (IntGrain **)malloc(sizeof(IntGrain *) * (EndLayer + 1));

	lea	ecx, DWORD PTR [esi*4+4]
	push	ecx
	call	DWORD PTR __imp__malloc

; 979  : 
; 980  : 	float avgdz = (ZLayer[StartLayer] - ZLayer[EndLayer]) / (EndLayer - StartLayer);

	mov	edx, DWORD PTR _StartLayer$[ebp]
	fld	DWORD PTR [edi+edx*4]
	add	esp, 4
	fsub	DWORD PTR [edi+esi*4]
	sub	esi, edx

; 981  : 			
; 982  : 	float tsl = 10.0f * (T.NptMinV - T.NptMin01) / (T.NptMin01 - T.NptMinH);
; 983  : 	float tinf = (float)(T.NptMinH);
; 984  : 	float td = (float)(T.NptMinV - T.NptMinH);
; 985  : 
; 986  : 	for (itr = 0; itr < T.TrialCount; itr++)

	cmp	DWORD PTR [ebx+172], 0
	mov	DWORD PTR tv1772[esp+384], esi
	fidiv	DWORD PTR tv1772[esp+384]
	mov	DWORD PTR _pTempGrains$[esp+384], eax
	mov	DWORD PTR _itr$[esp+384], 0
	fstp	DWORD PTR _avgdz$[esp+384]
	fld	DWORD PTR [ebx+880]
	fsub	DWORD PTR [ebx+888]
	fmul	QWORD PTR __real@4024000000000000
	fld	DWORD PTR [ebx+888]
	fsub	DWORD PTR [ebx+884]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _tsl$[esp+384]
	fld	DWORD PTR [ebx+884]
	fstp	DWORD PTR _tinf$[esp+384]
	fld	DWORD PTR [ebx+880]
	fsub	DWORD PTR [ebx+884]
	fstp	DWORD PTR _td$[esp+384]
	jle	$LN48@GetTracks
	lea	esi, DWORD PTR [ebx+176]
	mov	DWORD PTR tv1981[esp+384], esi
	jmp	SHORT $LN50@GetTracks
	npad	10
$LL117@GetTracks:

; 977  : 
; 978  : 	IntGrain **pTempGrains = (IntGrain **)malloc(sizeof(IntGrain *) * (EndLayer + 1));

	mov	edx, DWORD PTR _StartLayer$[ebp]
$LN50@GetTracks:

; 987  : 	{
; 988  : 		Trial tr = T.Trials[itr];

	mov	ecx, 11					; 0000000bH
	lea	edi, DWORD PTR _tr$131067[esp+384]
	rep movsd

; 989  : 		if (tr.TopLayer < StartLayer || tr.BottomLayer > EndLayer) continue;

	mov	eax, DWORD PTR _tr$131067[esp+384]
	cmp	eax, edx
	jl	$LN49@GetTracks
	mov	ecx, DWORD PTR _tr$131067[esp+388]
	cmp	ecx, DWORD PTR _EndLayer$[ebp]
	jg	$LN49@GetTracks

; 990  : 		Cell *tp = CellsInLayer * tr.TopLayer + CellSpace;

	mov	edx, DWORD PTR _CellsInLayer$[esp+384]
	mov	esi, DWORD PTR _CellSpace$[esp+384]
	mov	edi, eax
	imul	edi, edx
	lea	edi, DWORD PTR [esi+edi*8]
	mov	DWORD PTR _tp$131070[esp+384], edi

; 991  : 		Cell *bp = CellsInLayer * tr.BottomLayer + CellSpace;

	mov	edi, ecx
	imul	edi, edx
	lea	edx, DWORD PTR [esi+edi*8]
	mov	DWORD PTR _bp$131071[esp+384], edx

; 992  : 		tz = ZLayer[tr.TopLayer];

	mov	edx, DWORD PTR _ZLayer$[esp+384]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR _tz$[esp+384]

; 993  : 		idz = 1.0f / (tz - ZLayer[tr.BottomLayer]);

	fld	DWORD PTR _tz$[esp+384]
	fsub	DWORD PTR [edx+ecx*4]

; 994  : 
; 995  : 		for (ix = 0; ix < nx; ix++)

	mov	edx, DWORD PTR _nx$[esp+384]
	test	edx, edx
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _idz$[esp+384]
	jle	$LN49@GetTracks
	mov	edi, DWORD PTR _tp$131070[esp+384]
	fld	DWORD PTR _idz$[esp+384]
	mov	ecx, 1
	mov	DWORD PTR tv1932[esp+384], ecx
	mov	DWORD PTR tv1944[esp+384], edi
	mov	DWORD PTR tv171[esp+384], edx
$LN45@GetTracks:

; 996  : 		{
; 997  : 			minix = ix - 1; if (minix < 0) minix = 0;

	lea	eax, DWORD PTR [ecx-2]
	test	eax, eax
	mov	DWORD PTR _minix$[esp+384], eax
	jge	SHORT $LN42@GetTracks
	mov	DWORD PTR _minix$[esp+384], 0
$LN42@GetTracks:

; 998  : 			maxix = ix + 1; if (maxix >= nx) maxix = nx - 1;

	cmp	ecx, edx
	mov	DWORD PTR _maxix$[esp+384], ecx
	jl	SHORT $LN41@GetTracks
	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR _maxix$[esp+384], eax
$LN41@GetTracks:

; 999  : 			for (iy = 0; iy < ny; iy++)

	mov	esi, DWORD PTR _ny$[esp+384]
	test	esi, esi
	jle	$LN44@GetTracks
	mov	ecx, 1
	mov	DWORD PTR tv1849[esp+384], ecx
	mov	DWORD PTR tv1881[esp+384], edi
	mov	DWORD PTR tv922[esp+384], esi
$LN40@GetTracks:

; 1000 : 			{
; 1001 : 				miniy = iy - 1; if (miniy < 0) miniy = 0;

	lea	eax, DWORD PTR [ecx-2]
	test	eax, eax
	mov	DWORD PTR _miniy$[esp+384], eax
	jge	SHORT $LN37@GetTracks
	mov	DWORD PTR _miniy$[esp+384], 0
	mov	eax, DWORD PTR _miniy$[esp+384]
$LN37@GetTracks:

; 1002 : 				maxiy = iy + 1; if (maxiy >= ny) maxiy = ny - 1;

	cmp	ecx, esi
	mov	DWORD PTR _maxiy$[esp+384], ecx
	jl	SHORT $LN36@GetTracks
	add	esi, -1
	mov	DWORD PTR _maxiy$[esp+384], esi
$LN36@GetTracks:

; 1003 : 				Cell &ct = tp[iy * nx + ix];
; 1004 : 				IntGrain *pT = ct.FirstG;

	mov	esi, DWORD PTR [edi]

; 1005 : 				IntGrain *pTE = ct.FirstG + ct.Free;

	mov	edi, DWORD PTR [edi+4]
	lea	edi, DWORD PTR [edi+edi*8]
	lea	edi, DWORD PTR [esi+edi*4]

; 1006 : 				for (;pT < pTE; pT++)

	cmp	esi, edi
	mov	DWORD PTR _pT$131083[esp+384], esi
	mov	DWORD PTR _pTE$131084[esp+384], edi
	jae	$LN114@GetTracks
	jmp	SHORT $LN35@GetTracks
$LN113@GetTracks:
	mov	esi, DWORD PTR _pT$131083[esp+384]
$LN35@GetTracks:

; 1007 : 				{
; 1008 : 					IntGrain gt = *pT;

	mov	ecx, 9
	lea	edi, DWORD PTR _gt$131088[esp+384]
	rep movsd

; 1009 : 					for (iix = minix; iix <= maxix; iix++)

	mov	ecx, DWORD PTR _minix$[esp+384]
	mov	esi, ecx
	cmp	esi, DWORD PTR _maxix$[esp+384]
	mov	DWORD PTR _iix$[esp+384], ecx
	jg	$LN34@GetTracks
$LN32@GetTracks:

; 1010 : 						for (iiy = miniy; iiy <= maxiy; iiy++)

	mov	esi, DWORD PTR _maxiy$[esp+384]
	cmp	eax, esi
	jg	$LN31@GetTracks
	imul	eax, edx
	add	eax, ecx
	mov	ecx, DWORD PTR _bp$131071[esp+384]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, esi
	sub	eax, DWORD PTR _miniy$[esp+384]
	mov	DWORD PTR tv1785[esp+384], ecx
	add	eax, 1
	mov	DWORD PTR tv912[esp+384], eax
$LN29@GetTracks:

; 1011 : 						{
; 1012 : 							Cell &cb = bp[iiy * nx + iix];
; 1013 : 							IntGrain *pB = cb.FirstG;

	mov	esi, DWORD PTR [ecx]

; 1014 : 							IntGrain *pBE = cb.FirstG + cb.Free;

	mov	edi, DWORD PTR [ecx+4]
	lea	edi, DWORD PTR [edi+edi*8]
	lea	edi, DWORD PTR [esi+edi*4]

; 1015 : 							for (;pB < pBE; pB++)

	cmp	esi, edi
	mov	DWORD PTR _pB$131096[esp+384], esi
	mov	DWORD PTR _pBE$131097[esp+384], edi
	jae	$LN28@GetTracks
	jmp	SHORT $LN26@GetTracks
	npad	7
$LL97@GetTracks:
	mov	esi, DWORD PTR _pB$131096[esp+384]
$LN26@GetTracks:

; 1016 : 							{
; 1017 : 								IntGrain gb = *pB;
; 1018 : 								SlopeX = idz * (gt.Xcm - gb.Xcm);

	fld	DWORD PTR _gt$131088[esp+384]
	mov	ecx, 9
	lea	edi, DWORD PTR _gb$131101[esp+384]
	rep movsd
	fsub	DWORD PTR _gb$131101[esp+384]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _SlopeX$[esp+384]

; 1019 : 								SlopeY = idz * (gt.Ycm - gb.Ycm);

	fld	DWORD PTR _gt$131088[esp+388]
	fsub	DWORD PTR _gb$131101[esp+388]
	fmulp	ST(1), ST(0)

; 1020 : 								Slope2 = hypot(SlopeX, SlopeY);

	sub	esp, 16					; 00000010H
	fstp	DWORD PTR _SlopeY$[esp+400]
	fld	DWORD PTR _SlopeY$[esp+400]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR _SlopeX$[esp+400]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__hypot
	fstp	DWORD PTR _Slope2$[esp+400]
	add	esp, 16					; 00000010H

; 1021 : 								if (Slope2 < MaxSlope)

	fld	DWORD PTR _Slope2$[esp+384]
	fld	DWORD PTR _MaxSlope$[esp+384]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN25@GetTracks

; 1022 : 								{
; 1023 : 									GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);

	fld	DWORD PTR _SlopeY$[esp+384]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR _SlopeX$[esp+400]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__hypot
	fstp	DWORD PTR _slope2$134229[esp+400]
	add	esp, 16					; 00000010H
	fldz
	fld	DWORD PTR _slope2$134229[esp+384]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN163@GetTracks
	fstp	ST(0)
	fld1
	fstp	DWORD PTR _DirX$[esp+384]
	fstp	DWORD PTR _DirY$[esp+384]
	fld	DWORD PTR [ebx+168]
	jmp	SHORT $LN174@GetTracks
$LN163@GetTracks:
	fstp	ST(1)
	fld	DWORD PTR _SlopeX$[esp+384]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirX$[esp+384]
	fld	DWORD PTR _SlopeY$[esp+384]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirY$[esp+384]
	fmul	DWORD PTR _avgdz$[esp+384]
	fadd	DWORD PTR [ebx+168]
$LN174@GetTracks:

; 1024 : 									for (ir = 0; ir < tr.TriggerCount; ir++)

	cmp	DWORD PTR _tr$131067[esp+392], 0
	fstp	DWORD PTR _dirtol$[esp+384]
	mov	DWORD PTR _ir$[esp+384], 0
	jle	$LN25@GetTracks
$LN22@GetTracks:

; 1025 : 									{
; 1026 : 										int TriggerLayer = tr.Triggers[ir];

	mov	edx, DWORD PTR _ir$[esp+384]

; 1027 : 										float ldz = (tz - ZLayer[TriggerLayer]) * idz;

	fld	DWORD PTR _tz$[esp+384]
	mov	edi, DWORD PTR _tr$131067[esp+edx*4+396]
	mov	eax, DWORD PTR _ZLayer$[esp+384]
	fsub	DWORD PTR [eax+edi*4]

; 1028 : 										float cdz = 1.0f - ldz;
; 1029 : 										ExpX = ldz * gb.Xcm + cdz * gt.Xcm;
; 1030 : 										ExpY = ldz * gb.Ycm + cdz * gt.Ycm;
; 1031 : 										eix = (int)((ExpX - T.Win.Xmin) / T.DxCell);
; 1032 : 										eiy = (int)((ExpY - T.Win.Ymin) / T.DyCell);
; 1033 : 										IntGrain *pTrg = CellSpace[(TriggerLayer * ny + eiy) * nx + eix].FindGrain(ExpX, ExpY, DirX, DirY, dirtol, T.AlignTol);

	sub	esp, 24					; 00000018H
	fmul	DWORD PTR _idz$[esp+408]
	fstp	DWORD PTR _ldz$131107[esp+408]
	fld	DWORD PTR _ldz$131107[esp+408]
	fld	ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	fstp	DWORD PTR _cdz$131108[esp+408]
	fld	ST(0)
	fmul	DWORD PTR _gb$131101[esp+408]
	fld	DWORD PTR _cdz$131108[esp+408]
	fld	ST(0)
	fmul	DWORD PTR _gt$131088[esp+408]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _ExpX$[esp+408]
	fld	DWORD PTR _gb$131101[esp+412]
	fmulp	ST(2), ST(0)
	fmul	DWORD PTR _gt$131088[esp+412]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ExpY$[esp+408]
	fld	DWORD PTR [ebx+168]
	fstp	DWORD PTR [esp+20]
	fld	DWORD PTR _dirtol$[esp+408]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _DirY$[esp+408]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _DirX$[esp+408]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _ExpY$[esp+408]
	fst	DWORD PTR [esp+4]
	fld	DWORD PTR _ExpX$[esp+408]
	fst	DWORD PTR [esp]
	fld	DWORD PTR [ebx+988]
	fsubp	ST(2), ST(0)
	fld	DWORD PTR [ebx+1000]
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fsub	DWORD PTR [ebx+980]
	mov	ecx, edi
	imul	ecx, DWORD PTR _ny$[esp+408]
	fdiv	DWORD PTR [ebx+996]
	mov	esi, eax
	add	esi, ecx
	imul	esi, DWORD PTR _nx$[esp+408]
	call	__ftol2_sse
	mov	edx, DWORD PTR _CellSpace$[esp+408]
	add	esi, eax
	lea	ecx, DWORD PTR [edx+esi*8]
	call	?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z ; Cell::FindGrain

; 1034 : 										if (pTrg)

	test	eax, eax
	mov	DWORD PTR _pTrg$131111[esp+384], eax
	je	$LN21@GetTracks

; 1035 : 										{
; 1036 : 											memset(pTempGrains, 0, T.Layer * sizeof(Grain *));

	mov	eax, DWORD PTR [ebx+1016]
	mov	esi, DWORD PTR _pTempGrains$[esp+384]
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	push	esi
	call	_memset

; 1037 : 											float dz;
; 1038 : 											int seqlength = 3;
; 1039 : 
; 1040 : 											pTempGrains[tr.TopLayer] = pT;

	mov	eax, DWORD PTR _tr$131067[esp+396]
	mov	ecx, DWORD PTR _pT$131083[esp+396]

; 1041 : 											pTempGrains[tr.BottomLayer] = pB;

	mov	edx, DWORD PTR _tr$131067[esp+400]
	mov	DWORD PTR [esi+eax*4], ecx
	mov	ecx, DWORD PTR _pB$131096[esp+396]
	mov	DWORD PTR [esi+edx*4], ecx

; 1042 : 											pTempGrains[TriggerLayer] = pTrg;

	mov	edx, DWORD PTR _pTrg$131111[esp+396]
	mov	DWORD PTR [esi+edi*4], edx

; 1043 : 
; 1044 : 											for (lay = tr.TopLayer + 1; lay < TriggerLayer; lay++)

	lea	esi, DWORD PTR [eax+1]
	add	esp, 12					; 0000000cH
	cmp	esi, edi
	mov	DWORD PTR _seqlength$131115[esp+384], 3
	jge	$LN16@GetTracks
	mov	ecx, DWORD PTR _pTempGrains$[esp+384]
	lea	eax, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR tv1549[esp+384], eax
	mov	eax, DWORD PTR _ZLayer$[esp+384]
	sub	eax, ecx
	mov	DWORD PTR tv1565[esp+384], eax
	jmp	SHORT $LN18@GetTracks
	npad	9
$LL109@GetTracks:
	mov	eax, DWORD PTR tv1565[esp+384]
$LN18@GetTracks:

; 1045 : 											{
; 1046 : 												dz = ZLayer[lay] - tz;

	mov	ecx, DWORD PTR tv1549[esp+384]
	fld	DWORD PTR [eax+ecx]

; 1047 : 												ExpX = dz * SlopeX + gt.Xcm;
; 1048 : 												ExpY = dz * SlopeY + gt.Ycm;
; 1049 : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol)) seqlength++;

	mov	edx, DWORD PTR [ebx+976]
	fsub	DWORD PTR _tz$[esp+384]
	mov	eax, DWORD PTR _CellSpace$[esp+384]
	imul	edx, esi
	fstp	DWORD PTR _dz$131114[esp+384]
	fldz
	sub	esp, 8
	lea	ecx, DWORD PTR [eax+edx*8]
	fst	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	push	0
	fld	DWORD PTR _dirtol$[esp+396]
	push	0
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _DirY$[esp+412]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _DirX$[esp+412]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _dz$131114[esp+416]
	sub	esp, 8
	fld	ST(0)
	mov	ecx, ebx
	fmul	DWORD PTR _SlopeY$[esp+424]
	fadd	DWORD PTR _gt$131088[esp+428]
	fstp	DWORD PTR tv1683[esp+424]
	fld	DWORD PTR tv1683[esp+424]
	fstp	DWORD PTR [esp+4]
	fmul	DWORD PTR _SlopeX$[esp+424]
	fadd	DWORD PTR _gt$131088[esp+424]
	fstp	DWORD PTR tv1682[esp+424]
	fld	DWORD PTR tv1682[esp+424]
	fstp	DWORD PTR [esp]
	call	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
	test	eax, eax
	mov	edx, DWORD PTR tv1549[esp+384]
	mov	DWORD PTR [edx], eax
	je	SHORT $LN17@GetTracks
	add	DWORD PTR _seqlength$131115[esp+384], 1
$LN17@GetTracks:

; 1043 : 
; 1044 : 											for (lay = tr.TopLayer + 1; lay < TriggerLayer; lay++)

	add	DWORD PTR tv1549[esp+384], 4
	add	esi, 1
	cmp	esi, edi
	jl	$LL109@GetTracks
$LN16@GetTracks:

; 1050 : 												};
; 1051 : 											for (lay = TriggerLayer + 1; lay < tr.BottomLayer; lay++)

	add	edi, 1
	cmp	edi, DWORD PTR _tr$131067[esp+388]
	jge	$LN12@GetTracks
	mov	ecx, DWORD PTR _pTempGrains$[esp+384]
	mov	eax, DWORD PTR _ZLayer$[esp+384]
	sub	eax, ecx
	lea	esi, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR tv1565[esp+384], eax
	jmp	SHORT $LN14@GetTracks
$LL111@GetTracks:
	mov	eax, DWORD PTR tv1565[esp+384]
$LN14@GetTracks:

; 1052 : 											{
; 1053 : 												dz = ZLayer[lay] - tz;

	fld	DWORD PTR [esi+eax]

; 1054 : 												ExpX = dz * SlopeX + gt.Xcm;
; 1055 : 												ExpY = dz * SlopeY + gt.Ycm;
; 1056 : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol)) seqlength++;

	mov	eax, DWORD PTR [ebx+976]
	fsub	DWORD PTR _tz$[esp+384]
	mov	ecx, DWORD PTR _CellSpace$[esp+384]
	imul	eax, edi
	fstp	DWORD PTR _dz$131114[esp+384]
	fldz
	sub	esp, 8
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	ecx, ebx
	fst	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	push	0
	fld	DWORD PTR _dirtol$[esp+396]
	push	0
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _DirY$[esp+412]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _DirX$[esp+412]
	fstp	DWORD PTR [esp]
	push	edx
	fld	DWORD PTR _dz$131114[esp+416]
	sub	esp, 8
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+424]
	fadd	DWORD PTR _gt$131088[esp+428]
	fstp	DWORD PTR tv1661[esp+424]
	fld	DWORD PTR tv1661[esp+424]
	fstp	DWORD PTR [esp+4]
	fmul	DWORD PTR _SlopeX$[esp+424]
	fadd	DWORD PTR _gt$131088[esp+424]
	fstp	DWORD PTR tv1660[esp+424]
	fld	DWORD PTR tv1660[esp+424]
	fstp	DWORD PTR [esp]
	call	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $LN13@GetTracks
	add	DWORD PTR _seqlength$131115[esp+384], 1
$LN13@GetTracks:

; 1050 : 												};
; 1051 : 											for (lay = TriggerLayer + 1; lay < tr.BottomLayer; lay++)

	add	edi, 1
	add	esi, 4
	cmp	edi, DWORD PTR _tr$131067[esp+388]
	jl	$LL111@GetTracks
$LN12@GetTracks:

; 1057 : 												};
; 1058 : 											Vector topv, bottomv;
; 1059 : 											topv.X = pT->Xcm;

	mov	eax, DWORD PTR _pT$131083[esp+384]
	fld	DWORD PTR [eax]

; 1060 : 											topv.Y = pT->Ycm;
; 1061 : 											topv.Z = tz;
; 1062 : 											bottomv.X = pB->Xcm;
; 1063 : 											bottomv.Y = pB->Ycm;
; 1064 : 											bottomv.Z = ZLayer[tr.BottomLayer];

	mov	esi, DWORD PTR _ZLayer$[esp+384]

; 1065 : 											for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)

	mov	edi, DWORD PTR _tr$131067[esp+384]
	fstp	DWORD PTR _topv$131124[esp+384]
	add	edi, -1
	fld	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _pB$131096[esp+384]
	fstp	DWORD PTR _topv$131124[esp+388]
	fld	DWORD PTR _tz$[esp+384]
	fstp	DWORD PTR _topv$131124[esp+392]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR _bottomv$131125[esp+384]
	fld	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _tr$131067[esp+388]
	fstp	DWORD PTR _bottomv$131125[esp+388]
	fld	DWORD PTR [esi+eax*4]
	fstp	DWORD PTR _bottomv$131125[esp+392]
	js	$LN8@GetTracks
	mov	eax, DWORD PTR _pTempGrains$[esp+384]
	sub	eax, DWORD PTR _ZLayer$[esp+384]
	lea	esi, DWORD PTR [esi+edi*4]
	mov	DWORD PTR tv1672[esp+384], eax
$LN10@GetTracks:

; 1066 : 											{
; 1067 : 												dz = (bottomv.Z - topv.Z);

	fld	DWORD PTR _bottomv$131125[esp+392]

; 1068 : 												SlopeX = (bottomv.X - topv.X) / dz;
; 1069 : 												SlopeY = (bottomv.Y - topv.Y) / dz;
; 1070 : 												GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);

	sub	esp, 16					; 00000010H
	fsub	DWORD PTR _topv$131124[esp+408]
	fstp	DWORD PTR _dz$131114[esp+400]
	fld	DWORD PTR _bottomv$131125[esp+400]
	fsub	DWORD PTR _topv$131124[esp+400]
	fld	DWORD PTR _dz$131114[esp+400]
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _SlopeX$[esp+400]
	fld	DWORD PTR _bottomv$131125[esp+404]
	fsub	DWORD PTR _topv$131124[esp+404]
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _SlopeY$[esp+400]
	fld	DWORD PTR _SlopeY$[esp+400]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR _SlopeX$[esp+400]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__hypot
	fstp	DWORD PTR _slope2$134241[esp+400]
	fldz
	add	esp, 16					; 00000010H
	fld	DWORD PTR _slope2$134241[esp+384]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN64@GetTracks
	fstp	ST(0)
	fld1
	fstp	DWORD PTR _DirX$[esp+384]
	fst	DWORD PTR _DirY$[esp+384]
	fld	DWORD PTR [ebx+168]
	jmp	SHORT $LN175@GetTracks
$LN64@GetTracks:
	fld	DWORD PTR _SlopeX$[esp+384]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirX$[esp+384]
	fld	DWORD PTR _SlopeY$[esp+384]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirY$[esp+384]
	fmul	DWORD PTR _avgdz$[esp+384]
	fadd	DWORD PTR [ebx+168]
$LN175@GetTracks:
	fstp	DWORD PTR _dirtol$[esp+384]

; 1071 : 												dz = ZLayer[lay] - topv.Z;
; 1072 : 												ExpX = dz * SlopeX + topv.X;
; 1073 : 												ExpY = dz * SlopeY + topv.Y;
; 1074 : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol))

	mov	ecx, DWORD PTR [ebx+976]
	fld	DWORD PTR [esi]
	mov	edx, DWORD PTR _CellSpace$[esp+384]
	imul	ecx, edi
	fsub	DWORD PTR _topv$131124[esp+392]
	fstp	DWORD PTR _dz$131114[esp+384]
	sub	esp, 8
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, ebx
	fst	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	push	0
	fld	DWORD PTR _dirtol$[esp+396]
	push	0
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _DirY$[esp+412]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _DirX$[esp+412]
	fstp	DWORD PTR [esp]
	push	eax
	fld	DWORD PTR _dz$131114[esp+416]
	sub	esp, 8
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+424]
	fadd	DWORD PTR _topv$131124[esp+428]
	fstp	DWORD PTR tv1610[esp+424]
	fld	DWORD PTR tv1610[esp+424]
	fstp	DWORD PTR [esp+4]
	fmul	DWORD PTR _SlopeX$[esp+424]
	fadd	DWORD PTR _topv$131124[esp+424]
	fstp	DWORD PTR tv1609[esp+424]
	fld	DWORD PTR tv1609[esp+424]
	fstp	DWORD PTR [esp]
	call	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
	test	eax, eax
	mov	ecx, DWORD PTR tv1672[esp+384]
	mov	DWORD PTR [ecx+esi], eax
	je	SHORT $LN9@GetTracks

; 1075 : 												{
; 1076 : 													topv.X = pTempGrains[lay]->Xcm;

	fld	DWORD PTR [eax]

; 1077 : 													topv.Y = pTempGrains[lay]->Ycm;
; 1078 : 													topv.Z = ZLayer[lay];
; 1079 : 													seqlength++;

	add	DWORD PTR _seqlength$131115[esp+384], 1
	fstp	DWORD PTR _topv$131124[esp+384]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR _topv$131124[esp+388]
	fld	DWORD PTR [esi]
	fstp	DWORD PTR _topv$131124[esp+392]
$LN9@GetTracks:
	sub	edi, 1
	sub	esi, 4
	test	edi, edi
	jge	$LN10@GetTracks

; 1065 : 											for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)

	mov	esi, DWORD PTR _ZLayer$[esp+384]
$LN8@GetTracks:

; 1080 : 													}
; 1081 : 												};
; 1082 : 											for (lay = (int)tr.BottomLayer + 1; lay <= EndLayer; lay++)

	mov	edi, DWORD PTR _tr$131067[esp+388]
	add	edi, 1
	cmp	edi, DWORD PTR _EndLayer$[ebp]
	jg	$LN4@GetTracks
	mov	eax, DWORD PTR _pTempGrains$[esp+384]
	sub	eax, DWORD PTR _ZLayer$[esp+384]
	lea	esi, DWORD PTR [esi+edi*4]
	mov	DWORD PTR tv1672[esp+384], eax
$LN6@GetTracks:

; 1083 : 											{
; 1084 : 												dz = (bottomv.Z - topv.Z);

	fld	DWORD PTR _bottomv$131125[esp+392]

; 1085 : 												SlopeX = (bottomv.X - topv.X) / dz;
; 1086 : 												SlopeY = (bottomv.Y - topv.Y) / dz;
; 1087 : 												GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);

	sub	esp, 16					; 00000010H
	fsub	DWORD PTR _topv$131124[esp+408]
	fstp	DWORD PTR _dz$131114[esp+400]
	fld	DWORD PTR _bottomv$131125[esp+400]
	fsub	DWORD PTR _topv$131124[esp+400]
	fld	DWORD PTR _dz$131114[esp+400]
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _SlopeX$[esp+400]
	fld	DWORD PTR _bottomv$131125[esp+404]
	fsub	DWORD PTR _topv$131124[esp+404]
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _SlopeY$[esp+400]
	fld	DWORD PTR _SlopeY$[esp+400]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR _SlopeX$[esp+400]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__hypot
	fstp	DWORD PTR _slope2$134247[esp+400]
	fldz
	add	esp, 16					; 00000010H
	fld	DWORD PTR _slope2$134247[esp+384]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN68@GetTracks
	fstp	ST(0)
	fld1
	fstp	DWORD PTR _DirX$[esp+384]
	fst	DWORD PTR _DirY$[esp+384]
	fld	DWORD PTR [ebx+168]
	jmp	SHORT $LN176@GetTracks
$LN68@GetTracks:
	fld	DWORD PTR _SlopeX$[esp+384]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirX$[esp+384]
	fld	DWORD PTR _SlopeY$[esp+384]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirY$[esp+384]
	fmul	DWORD PTR _avgdz$[esp+384]
	fadd	DWORD PTR [ebx+168]
$LN176@GetTracks:
	fstp	DWORD PTR _dirtol$[esp+384]

; 1088 : 												dz = ZLayer[lay] - topv.Z;
; 1089 : 												ExpX = dz * SlopeX + topv.X;
; 1090 : 												ExpY = dz * SlopeY + topv.Y;
; 1091 : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol))

	mov	edx, DWORD PTR [ebx+976]
	fld	DWORD PTR [esi]
	mov	eax, DWORD PTR _CellSpace$[esp+384]
	imul	edx, edi
	fsub	DWORD PTR _topv$131124[esp+392]
	fstp	DWORD PTR _dz$131114[esp+384]
	sub	esp, 8
	lea	ecx, DWORD PTR [eax+edx*8]
	fst	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	push	0
	fld	DWORD PTR _dirtol$[esp+396]
	push	0
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _DirY$[esp+412]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _DirX$[esp+412]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _dz$131114[esp+416]
	sub	esp, 8
	fld	ST(0)
	mov	ecx, ebx
	fmul	DWORD PTR _SlopeY$[esp+424]
	fadd	DWORD PTR _topv$131124[esp+428]
	fstp	DWORD PTR tv1561[esp+424]
	fld	DWORD PTR tv1561[esp+424]
	fstp	DWORD PTR [esp+4]
	fmul	DWORD PTR _SlopeX$[esp+424]
	fadd	DWORD PTR _topv$131124[esp+424]
	fstp	DWORD PTR tv1560[esp+424]
	fld	DWORD PTR tv1560[esp+424]
	fstp	DWORD PTR [esp]
	call	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
	test	eax, eax
	mov	edx, DWORD PTR tv1672[esp+384]
	mov	DWORD PTR [esi+edx], eax
	je	SHORT $LN5@GetTracks

; 1092 : 												{
; 1093 : 													bottomv.X = pTempGrains[lay]->Xcm;

	fld	DWORD PTR [eax]

; 1094 : 													bottomv.Y = pTempGrains[lay]->Ycm;
; 1095 : 													bottomv.Z = ZLayer[lay];
; 1096 : 													seqlength++;

	add	DWORD PTR _seqlength$131115[esp+384], 1
	fstp	DWORD PTR _bottomv$131125[esp+384]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR _bottomv$131125[esp+388]
	fld	DWORD PTR [esi]
	fstp	DWORD PTR _bottomv$131125[esp+392]
$LN5@GetTracks:
	add	edi, 1
	add	esi, 4
	cmp	edi, DWORD PTR _EndLayer$[ebp]
	jle	$LN6@GetTracks
$LN4@GetTracks:

; 1097 : 													}
; 1098 : 												};
; 1099 : 											if ((float)seqlength > (tinf + td / (1.0f + tsl * Slope2)))

	fild	DWORD PTR _seqlength$131115[esp+384]
	fld	DWORD PTR _td$[esp+384]
	fld	DWORD PTR _Slope2$[esp+384]
	fmul	DWORD PTR _tsl$[esp+384]
	fadd	QWORD PTR __real@3ff0000000000000
	fdivp	ST(1), ST(0)
	fadd	DWORD PTR _tinf$[esp+384]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN83@GetTracks
$LN21@GetTracks:

; 1024 : 									for (ir = 0; ir < tr.TriggerCount; ir++)

	mov	eax, DWORD PTR _ir$[esp+384]
	add	eax, 1
	cmp	eax, DWORD PTR _tr$131067[esp+392]
	mov	DWORD PTR _ir$[esp+384], eax
	jl	$LN22@GetTracks

; 1097 : 													}
; 1098 : 												};
; 1099 : 											if ((float)seqlength > (tinf + td / (1.0f + tsl * Slope2)))

	jmp	SHORT $LN25@GetTracks
$LN83@GetTracks:

; 1100 : 											{
; 1101 : 												InsertNewTrack(pTempGrains, EndLayer + 1, seqlength, pSpace, NTracks);

	mov	edi, DWORD PTR _pSpace$[ebp]
	mov	ecx, DWORD PTR _seqlength$131115[esp+384]
	mov	edx, DWORD PTR _EndLayer$[ebp]
	mov	esi, DWORD PTR _pTempGrains$[esp+384]
	lea	eax, DWORD PTR _NTracks$[esp+384]
	push	eax
	push	edi
	push	ecx
	add	edx, 1
	push	edx
	push	esi
	mov	ecx, ebx
	call	?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z ; CSmartTrackerClass::InsertNewTrack

; 1102 : 												if (NTracks >= *pMaxNumber)

	mov	eax, DWORD PTR _NTracks$[esp+384]
	mov	ecx, DWORD PTR _pMaxNumber$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jl	SHORT $LN25@GetTracks

; 1103 : 												{
; 1104 : 													*pMaxNumber = FinalizeTracks(NTracks, pSpace);

	push	edi
	push	eax
	mov	ecx, ebx
	call	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z ; CSmartTrackerClass::FinalizeTracks
	mov	edx, DWORD PTR _pMaxNumber$[ebp]

; 1105 : 													free(pTempGrains);

	push	esi
	mov	DWORD PTR [edx], eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN25@GetTracks:
	mov	eax, DWORD PTR _pB$131096[esp+384]
	fld	DWORD PTR _idz$[esp+384]
	add	eax, 36					; 00000024H
	cmp	eax, DWORD PTR _pBE$131097[esp+384]
	mov	DWORD PTR _pB$131096[esp+384], eax
	jb	$LL97@GetTracks
	mov	ecx, DWORD PTR tv1785[esp+384]
	mov	eax, DWORD PTR tv912[esp+384]
	mov	edx, DWORD PTR _nx$[esp+384]
$LN28@GetTracks:
	lea	esi, DWORD PTR [edx*8]
	add	ecx, esi
	sub	eax, 1
	mov	DWORD PTR tv1785[esp+384], ecx
	mov	DWORD PTR tv912[esp+384], eax
	jne	$LN29@GetTracks
	mov	eax, DWORD PTR _miniy$[esp+384]
	mov	ecx, DWORD PTR _iix$[esp+384]
$LN31@GetTracks:
	add	ecx, 1
	cmp	ecx, DWORD PTR _maxix$[esp+384]
	mov	DWORD PTR _iix$[esp+384], ecx
	jle	$LN32@GetTracks
$LN34@GetTracks:

; 1006 : 				for (;pT < pTE; pT++)

	mov	ecx, DWORD PTR _pT$131083[esp+384]
	add	ecx, 36					; 00000024H
	cmp	ecx, DWORD PTR _pTE$131084[esp+384]
	mov	DWORD PTR _pT$131083[esp+384], ecx
	jb	$LN113@GetTracks
	mov	ecx, DWORD PTR tv1849[esp+384]
$LN114@GetTracks:

; 999  : 			for (iy = 0; iy < ny; iy++)

	mov	edi, DWORD PTR tv1881[esp+384]

; 1006 : 				for (;pT < pTE; pT++)

	mov	esi, DWORD PTR _ny$[esp+384]
	lea	eax, DWORD PTR [edx*8]
	add	ecx, 1
	add	edi, eax
	sub	DWORD PTR tv922[esp+384], 1
	mov	DWORD PTR tv1849[esp+384], ecx
	mov	DWORD PTR tv1881[esp+384], edi
	jne	$LN40@GetTracks

; 999  : 			for (iy = 0; iy < ny; iy++)

	mov	ecx, DWORD PTR tv1932[esp+384]
$LN44@GetTracks:

; 994  : 
; 995  : 		for (ix = 0; ix < nx; ix++)

	mov	edi, DWORD PTR tv1944[esp+384]
	add	ecx, 1
	add	edi, 8
	sub	DWORD PTR tv171[esp+384], 1
	mov	DWORD PTR tv1932[esp+384], ecx
	mov	DWORD PTR tv1944[esp+384], edi
	jne	$LN45@GetTracks
	fstp	ST(0)
$LN49@GetTracks:

; 981  : 			
; 982  : 	float tsl = 10.0f * (T.NptMinV - T.NptMin01) / (T.NptMin01 - T.NptMinH);
; 983  : 	float tinf = (float)(T.NptMinH);
; 984  : 	float td = (float)(T.NptMinV - T.NptMinH);
; 985  : 
; 986  : 	for (itr = 0; itr < T.TrialCount; itr++)

	mov	eax, DWORD PTR _itr$[esp+384]
	mov	esi, DWORD PTR tv1981[esp+384]
	add	eax, 1
	add	esi, 44					; 0000002cH
	cmp	eax, DWORD PTR [ebx+172]
	mov	DWORD PTR _itr$[esp+384], eax
	mov	DWORD PTR tv1981[esp+384], esi
	jl	$LL117@GetTracks
$LN48@GetTracks:

; 1106 : 													}
; 1107 : 												break;
; 1108 : 												}
; 1109 : 											}
; 1110 : 										}
; 1111 : 									}
; 1112 : 								}
; 1113 : 							}
; 1114 : 					}
; 1115 : 				}
; 1116 : 			}
; 1117 : 		}
; 1118 : 
; 1119 : 	*pMaxNumber = FinalizeTracks(NTracks, pSpace);

	mov	eax, DWORD PTR _pSpace$[ebp]
	mov	ecx, DWORD PTR _NTracks$[esp+384]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z ; CSmartTrackerClass::FinalizeTracks
	mov	edx, DWORD PTR _pMaxNumber$[ebp]
	mov	DWORD PTR [edx], eax

; 1120 : 	free(pTempGrains);

	mov	eax, DWORD PTR _pTempGrains$[esp+384]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 1122 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z ENDP ; CSmartTrackerClass::GetTracks
_TEXT	ENDS
END
