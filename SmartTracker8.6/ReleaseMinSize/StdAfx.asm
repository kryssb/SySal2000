; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	d:\SySal2\SmartTracker8.6\StdAfx.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_AfxInitManaged@@YAHXZ				; _AfxInitManaged
PUBLIC	??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@	; `string'
PUBLIC	??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@	; `string'
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWThunk
PUBLIC	?CharUpperWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWThunk
PUBLIC	?CharLowerWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWThunk
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z	; ATL::CompareStringWThunk
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?_Min@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Min
PUBLIC	?_Max@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Max
PUBLIC	?_Min@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Min
PUBLIC	?_Max@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Max
PUBLIC	?_Min@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Min
PUBLIC	?_Max@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Max
PUBLIC	?_Min@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Min
PUBLIC	?_Max@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Max
PUBLIC	?_Min@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Min
PUBLIC	?_Max@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Max
PUBLIC	?_Min@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Min
PUBLIC	?_Max@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Max
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?VT@?$CVarTypeInfo@D@ATL@@2GB			; ATL::CVarTypeInfo<char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ ; ATL::CVarTypeInfo<char>::pmField
PUBLIC	?VT@?$CVarTypeInfo@E@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ ; ATL::CVarTypeInfo<unsigned char>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAD@ATL@@2GB			; ATL::CVarTypeInfo<char *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ ; ATL::CVarTypeInfo<char *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAE@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ ; ATL::CVarTypeInfo<unsigned char *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@F@ATL@@2GB			; ATL::CVarTypeInfo<short>::VT
PUBLIC	?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ ; ATL::CVarTypeInfo<short>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAF@ATL@@2GB			; ATL::CVarTypeInfo<short *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ ; ATL::CVarTypeInfo<short *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@G@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short>::VT
PUBLIC	?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ ; ATL::CVarTypeInfo<unsigned short>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAG@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ ; ATL::CVarTypeInfo<unsigned short *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@H@ATL@@2GB			; ATL::CVarTypeInfo<int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ ; ATL::CVarTypeInfo<int>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAH@ATL@@2GB			; ATL::CVarTypeInfo<int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ ; ATL::CVarTypeInfo<int *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@I@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ ; ATL::CVarTypeInfo<unsigned int>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAI@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ ; ATL::CVarTypeInfo<unsigned int *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@J@ATL@@2GB			; ATL::CVarTypeInfo<long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ ; ATL::CVarTypeInfo<long>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAJ@ATL@@2GB			; ATL::CVarTypeInfo<long *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ ; ATL::CVarTypeInfo<long *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ ; ATL::CVarTypeInfo<unsigned long>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAK@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ ; ATL::CVarTypeInfo<unsigned long *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@_J@ATL@@2GB			; ATL::CVarTypeInfo<__int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ ; ATL::CVarTypeInfo<__int64>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PA_J@ATL@@2GB		; ATL::CVarTypeInfo<__int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ ; ATL::CVarTypeInfo<__int64 *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@_K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned __int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PA_K@ATL@@2GB		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@M@ATL@@2GB			; ATL::CVarTypeInfo<float>::VT
PUBLIC	?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ ; ATL::CVarTypeInfo<float>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAM@ATL@@2GB			; ATL::CVarTypeInfo<float *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ ; ATL::CVarTypeInfo<float *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@N@ATL@@2GB			; ATL::CVarTypeInfo<double>::VT
PUBLIC	?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ ; ATL::CVarTypeInfo<double>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAN@ATL@@2GB			; ATL::CVarTypeInfo<double *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ ; ATL::CVarTypeInfo<double *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB	; ATL::CVarTypeInfo<tagVARIANT>::VT
PUBLIC	?VT@?$CVarTypeInfo@PA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ ; ATL::CVarTypeInfo<wchar_t *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ ; ATL::CVarTypeInfo<wchar_t * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY>::VT
PUBLIC	?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY *>::pmField
PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A ; ATL::CFixedStringMgr::s_pLog
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
PUBLIC	?generic@CArchiveException@@2HB			; CArchiveException::generic
PUBLIC	?generic@CFileException@@2HB			; CFileException::generic
PUBLIC	?Millisecond@CFileTime@ATL@@2_KB		; ATL::CFileTime::Millisecond
PUBLIC	?Second@CFileTime@ATL@@2_KB			; ATL::CFileTime::Second
PUBLIC	?Minute@CFileTime@ATL@@2_KB			; ATL::CFileTime::Minute
PUBLIC	?Hour@CFileTime@ATL@@2_KB			; ATL::CFileTime::Hour
PUBLIC	?Day@CFileTime@ATL@@2_KB			; ATL::CFileTime::Day
PUBLIC	?Week@CFileTime@ATL@@2_KB			; ATL::CFileTime::Week
PUBLIC	?szInvalidDateTime@ATL@@3QBDB			; ATL::szInvalidDateTime
PUBLIC	?szInvalidDateTimeSpan@ATL@@3QBDB		; ATL::szInvalidDateTimeSpan
PUBLIC	__pIncludeInitManaged
PUBLIC	?OLE_DATETIME_HALFSECOND@COleDateTimeSpan@ATL@@0NB ; ATL::COleDateTimeSpan::OLE_DATETIME_HALFSECOND
PUBLIC	?CLSID_WinFormsControl@@3U_GUID@@B		; CLSID_WinFormsControl
PUBLIC	_LIBID_ATLLib
PUBLIC	_CLSID_Registrar
PUBLIC	_IID_IRegistrar
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	_IID_IInternalConnection
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA	; ATL::CComApartment::ATL_CREATE_OBJECT
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_BSS	SEGMENT
?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A DD 01H DUP (?) ; ATL::CFixedStringMgr::s_pLog
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_BSS	SEGMENT
?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA DD 01H DUP (?) ; ATL::CComApartment::ATL_CREATE_OBJECT
_BSS	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?CLSID_WinFormsControl@@3U_GUID@@B
CONST	SEGMENT
?CLSID_WinFormsControl@@3U_GUID@@B DD 0b7e7a666H	; CLSID_WinFormsControl
	DW	0d623H
	DW	0457fH
	DB	0a3H
	DB	0aH
	DB	06aH
	DB	049H
	DB	0a3H
	DB	0e5H
	DB	0b4H
	DB	070H
CONST	ENDS
;	COMDAT ?OLE_DATETIME_HALFSECOND@COleDateTimeSpan@ATL@@0NB
CONST	SEGMENT
?OLE_DATETIME_HALFSECOND@COleDateTimeSpan@ATL@@0NB DQ 03ed845c8a0ce5129r ; 5.78704e-006 ; ATL::COleDateTimeSpan::OLE_DATETIME_HALFSECOND
CONST	ENDS
;	COMDAT __pIncludeInitManaged
_DATA	SEGMENT
__pIncludeInitManaged DD FLAT:?_AfxInitManaged@@YAHXZ
_DATA	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTimeSpan@ATL@@3QBDB DD FLAT:??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@ ; ATL::szInvalidDateTimeSpan
CONST	ENDS
;	COMDAT ??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@
CONST	SEGMENT
??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@ DB 'Invalid DateTimeSpan', 00H ; `string'
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTime@ATL@@3QBDB DD FLAT:??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@ ; ATL::szInvalidDateTime
CONST	ENDS
;	COMDAT ??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@
CONST	SEGMENT
??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@ DB 'Invalid DateTime', 00H ; `string'
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Week@CFileTime@ATL@@2_KB DQ 0000058028e44000H		; ATL::CFileTime::Week
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Day@CFileTime@ATL@@2_KB DQ 000000c92a69c000H		; ATL::CFileTime::Day
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Hour@CFileTime@ATL@@2_KB DQ 0000000861c46800H		; ATL::CFileTime::Hour
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Minute@CFileTime@ATL@@2_KB DQ 0000000023c34600H	; ATL::CFileTime::Minute
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Second@CFileTime@ATL@@2_KB DQ 0000000000989680H	; ATL::CFileTime::Second
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Millisecond@CFileTime@ATL@@2_KB DQ 0000000000002710H	; ATL::CFileTime::Millisecond
CONST	ENDS
;	COMDAT ?generic@CFileException@@2HB
CONST	SEGMENT
?generic@CFileException@@2HB DD 01H			; CFileException::generic
CONST	ENDS
;	COMDAT ?generic@CArchiveException@@2HB
CONST	SEGMENT
?generic@CArchiveException@@2HB DD 01H			; CArchiveException::generic
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB DB 01H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB DB 01H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_DATA	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB DW 04006H	; ATL::CVarTypeInfo<tagCY *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB DW 06H		; ATL::CVarTypeInfo<tagCY>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB DW 04009H	; ATL::CVarTypeInfo<IDispatch * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB DW 09H	; ATL::CVarTypeInfo<IDispatch *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB DW 0400dH	; ATL::CVarTypeInfo<IUnknown * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB DW 0dH	; ATL::CVarTypeInfo<IUnknown *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB DW 04008H		; ATL::CVarTypeInfo<wchar_t * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_W@ATL@@2GB DW 08H			; ATL::CVarTypeInfo<wchar_t *>::VT
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB DW 0cH	; ATL::CVarTypeInfo<tagVARIANT>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ DD 08H ; ATL::CVarTypeInfo<double *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAN@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAN@ATL@@2GB DW 04005H		; ATL::CVarTypeInfo<double *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ DD 08H ; ATL::CVarTypeInfo<double>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@N@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@N@ATL@@2GB DW 05H			; ATL::CVarTypeInfo<double>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ DD 08H ; ATL::CVarTypeInfo<float *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAM@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAM@ATL@@2GB DW 04004H		; ATL::CVarTypeInfo<float *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ DD 08H ; ATL::CVarTypeInfo<float>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@M@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@M@ATL@@2GB DW 04H			; ATL::CVarTypeInfo<float>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_K@ATL@@2GB DW 04015H		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_K@ATL@@2GB DW 015H			; ATL::CVarTypeInfo<unsigned __int64>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_J@ATL@@2GB DW 04014H		; ATL::CVarTypeInfo<__int64 *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_J@ATL@@2GB DW 014H			; ATL::CVarTypeInfo<__int64>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAK@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAK@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@K@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned long>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ DD 08H ; ATL::CVarTypeInfo<long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAJ@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAJ@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ DD 08H ; ATL::CVarTypeInfo<long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@J@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<long>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAI@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAI@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned int *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@I@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@I@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned int>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ DD 08H ; ATL::CVarTypeInfo<int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAH@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAH@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<int *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ DD 08H ; ATL::CVarTypeInfo<int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@H@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@H@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<int>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAG@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAG@ATL@@2GB DW 04012H		; ATL::CVarTypeInfo<unsigned short *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@G@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@G@ATL@@2GB DW 012H			; ATL::CVarTypeInfo<unsigned short>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ DD 08H ; ATL::CVarTypeInfo<short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAF@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAF@ATL@@2GB DW 04002H		; ATL::CVarTypeInfo<short *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ DD 08H ; ATL::CVarTypeInfo<short>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@F@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@F@ATL@@2GB DW 02H			; ATL::CVarTypeInfo<short>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAE@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAE@ATL@@2GB DW 04011H		; ATL::CVarTypeInfo<unsigned char *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ DD 08H ; ATL::CVarTypeInfo<char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAD@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAD@ATL@@2GB DW 04010H		; ATL::CVarTypeInfo<char *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@E@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@E@ATL@@2GB DW 011H			; ATL::CVarTypeInfo<unsigned char>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ DD 08H ; ATL::CVarTypeInfo<char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@D@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@D@ATL@@2GB DW 010H			; ATL::CVarTypeInfo<char>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Max@?$AtlLimits@_K@ATL@@2_KB DQ ffffffffffffffffH	; ATL::AtlLimits<unsigned __int64>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Min@?$AtlLimits@_K@ATL@@2_KB DQ 0000000000000000H	; ATL::AtlLimits<unsigned __int64>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Max@?$AtlLimits@_J@ATL@@2_JB DQ 7fffffffffffffffH	; ATL::AtlLimits<__int64>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Min@?$AtlLimits@_J@ATL@@2_JB DQ 8000000000000000H	; ATL::AtlLimits<__int64>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Max@?$AtlLimits@K@ATL@@2KB DD 0ffffffffH		; ATL::AtlLimits<unsigned long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Min@?$AtlLimits@K@ATL@@2KB DD 00H			; ATL::AtlLimits<unsigned long>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Max@?$AtlLimits@J@ATL@@2JB DD 07fffffffH		; ATL::AtlLimits<long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Min@?$AtlLimits@J@ATL@@2JB DD 080000000H		; ATL::AtlLimits<long>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Max@?$AtlLimits@I@ATL@@2IB DD 0ffffffffH		; ATL::AtlLimits<unsigned int>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Min@?$AtlLimits@I@ATL@@2IB DD 00H			; ATL::AtlLimits<unsigned int>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Max@?$AtlLimits@H@ATL@@2HB DD 07fffffffH		; ATL::AtlLimits<int>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Min@?$AtlLimits@H@ATL@@2HB DD 080000000H		; ATL::AtlLimits<int>::_Min
CONST	ENDS
PUBLIC	?AfxCrtErrorCheck@@YAHH@Z			; AfxCrtErrorCheck
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	?AfxThrowMemoryException@@YGXXZ:PROC		; AfxThrowMemoryException
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\afx.h
;	COMDAT ?AfxCrtErrorCheck@@YAHH@Z
_TEXT	SEGMENT
_error$ = 8						; size = 4
?AfxCrtErrorCheck@@YAHH@Z PROC				; AfxCrtErrorCheck, COMDAT

; 491  : 	switch(error)

	mov	eax, DWORD PTR _error$[esp-4]
	cmp	eax, 80					; 00000050H
	ja	SHORT $LN3@AfxCrtErro
	movzx	ecx, BYTE PTR $LN9@AfxCrtErro[eax]
	jmp	DWORD PTR $LN11@AfxCrtErro[ecx*4]
$LN4@AfxCrtErro:

; 492  : 	{
; 493  : 	case ENOMEM:
; 494  : 		AfxThrowMemoryException();

	jmp	?AfxThrowMemoryException@@YGXXZ		; AfxThrowMemoryException
$LN3@AfxCrtErro:

; 495  : 		break;
; 496  : 	case EINVAL:
; 497  : 	case ERANGE:
; 498  : 		AfxThrowInvalidArgException();

	jmp	?AfxThrowInvalidArgException@@YGXXZ	; AfxThrowInvalidArgException
$LN7@AfxCrtErro:

; 499  : 		break;
; 500  : 	case STRUNCATE:
; 501  : 	case 0:
; 502  : 		break;
; 503  : 	default:
; 504  : 		AfxThrowInvalidArgException();
; 505  : 		break;
; 506  : 	}
; 507  : 	return error;
; 508  : }

	ret	0
	npad	2
$LN11@AfxCrtErro:
	DD	$LN7@AfxCrtErro
	DD	$LN4@AfxCrtErro
	DD	$LN3@AfxCrtErro
	DD	$LN3@AfxCrtErro
$LN9@AfxCrtErro:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	0
?AfxCrtErrorCheck@@YAHH@Z ENDP				; AfxCrtErrorCheck
_TEXT	ENDS
PUBLIC	??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@	; Define_the_symbol__ATL_MIXED::Thank_you::`vftable'
PUBLIC	??0Thank_you@Define_the_symbol__ATL_MIXED@@QAE@XZ ; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you
PUBLIC	??_R4Thank_you@Define_the_symbol__ATL_MIXED@@6B@ ; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8 ; Define_the_symbol__ATL_MIXED::Thank_you `RTTI Type Descriptor'
PUBLIC	??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8	; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Thank_you@Define_the_symbol__ATL_MIXED@@8	; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Thank_you@Define_the_symbol__ATL_MIXED@@8 ; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ ; Define_the_symbol__ATL_MIXED::Thank_you::one
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Thank_you@Define_the_symbol__ATL_MIXED@@8 DD FLAT:??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8 ; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	ENDS
;	COMDAT ??_R2Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	SEGMENT
??_R2Thank_you@Define_the_symbol__ATL_MIXED@@8 DD FLAT:??_R1A@?0A@EA@Thank_you@Define_the_symbol__ATL_MIXED@@8 ; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	SEGMENT
??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8 DD 00H	; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8
_DATA	SEGMENT
??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8 DD FLAT:??_7type_info@@6B@ ; Define_the_symbol__ATL_MIXED::Thank_you `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUThank_you@Define_the_symbol__ATL_MIXED@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Thank_you@Define_the_symbol__ATL_MIXED@@6B@
rdata$r	SEGMENT
??_R4Thank_you@Define_the_symbol__ATL_MIXED@@6B@ DD 00H	; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8
	DD	FLAT:??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	ENDS
;	COMDAT ??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@
CONST	SEGMENT
??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@ DD FLAT:??_R4Thank_you@Define_the_symbol__ATL_MIXED@@6B@ ; Define_the_symbol__ATL_MIXED::Thank_you::`vftable'
	DD	FLAT:?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0Thank_you@Define_the_symbol__ATL_MIXED@@QAE@XZ
_TEXT	SEGMENT
??0Thank_you@Define_the_symbol__ATL_MIXED@@QAE@XZ PROC	; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@
	ret	0
??0Thank_you@Define_the_symbol__ATL_MIXED@@QAE@XZ ENDP	; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atldef.h
_TEXT	ENDS
;	COMDAT ?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ
_TEXT	SEGMENT
?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ PROC ; Define_the_symbol__ATL_MIXED::Thank_you::one, COMDAT
; _this$ = ecx

; 69   : 	struct Thank_you { virtual void one(){} };

	ret	0
?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ ENDP ; Define_the_symbol__ATL_MIXED::Thank_you::one
_TEXT	ENDS
PUBLIC	??$AtlMultiply@H@ATL@@YAJPAHHH@Z		; ATL::AtlMultiply<int>
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@H@ATL@@YAJPAHHH@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@H@ATL@@YAJPAHHH@Z PROC			; ATL::AtlMultiply<int>, COMDAT

; 126  : 	__int64 i64Result=static_cast<__int64>(iLeft) * static_cast<__int64>(iRight);

	mov	eax, DWORD PTR _iLeft$[esp-4]
	imul	DWORD PTR _iRight$[esp-4]

; 127  : 	if(i64Result>INT_MAX || i64Result < INT_MIN)

	mov	ecx, eax
	add	ecx, -2147483648			; 80000000H
	adc	edx, 0
	test	edx, edx
	ja	SHORT $LN1@AtlMultipl
	jb	SHORT $LN5@AtlMultipl
	cmp	ecx, -1
	ja	SHORT $LN1@AtlMultipl
$LN5@AtlMultipl:

; 130  : 	}
; 131  : 	*piResult=static_cast<int _ATL_W64>(i64Result);

	mov	ecx, DWORD PTR _piResult$[esp-4]
	mov	DWORD PTR [ecx], eax

; 132  : 	return S_OK;

	xor	eax, eax

; 133  : }

	ret	0
$LN1@AtlMultipl:

; 128  : 	{
; 129  : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 133  : }

	ret	0
??$AtlMultiply@H@ATL@@YAJPAHHH@Z ENDP			; ATL::AtlMultiply<int>
_TEXT	ENDS
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 138  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

	mov	eax, DWORD PTR _iLeft$[esp-4]
	mul	DWORD PTR _iRight$[esp-4]

; 139  : 	if(i64Result>UINT_MAX)

	test	edx, edx
	ja	SHORT $LN4@AtlMultipl@2
	cmp	eax, -1
	jbe	SHORT $LN1@AtlMultipl@2
$LN4@AtlMultipl@2:

; 140  : 	{
; 141  : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 145  : }

	ret	0
$LN1@AtlMultipl@2:

; 142  : 	}
; 143  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

	mov	ecx, DWORD PTR _piResult$[esp-4]
	mov	DWORD PTR [ecx], eax

; 144  : 	return S_OK;

	xor	eax, eax

; 145  : }

	ret	0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
EXTRN	__imp__malloc:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 243  : 		return malloc(nBytes);

	jmp	DWORD PTR __imp__malloc
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
EXTRN	__imp__free:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 248  : 		free(p);

	jmp	DWORD PTR __imp__free
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
EXTRN	__imp__InterlockedExchange@8:PROC
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlconv.h
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC	; InterlockedExchangePointer, COMDAT

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

	jmp	DWORD PTR __imp__InterlockedExchange@8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
EXTRN	?g_pfnGetThreadACP@ATL@@3P6GIXZA:DWORD		; ATL::g_pfnGetThreadACP
; Function compile flags: /Ogtpy
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 160  : 	return( g_pfnGetThreadACP() );

	jmp	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
EXTRN	__imp__MultiByteToWideChar@24:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC			; AtlA2WHelper, COMDAT

; 595  : {

	push	esi

; 596  : 	ATLASSERT(lpa != NULL);
; 597  : 	ATLASSERT(lpw != NULL);
; 598  : 	if (lpw == NULL || lpa == NULL)

	mov	esi, DWORD PTR _lpw$[esp]
	test	esi, esi
	je	SHORT $LN2@AtlA2WHelp
	mov	eax, DWORD PTR _lpa$[esp]
	test	eax, eax
	je	SHORT $LN2@AtlA2WHelp

; 600  : 	// verify that no illegal character present
; 601  : 	// since lpw was allocated based on the size of lpa
; 602  : 	// don't worry about the number of chars
; 603  : 	lpw[0] = '\0';
; 604  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

	mov	ecx, DWORD PTR _nChars$[esp]
	mov	edx, DWORD PTR _acp$[esp]
	push	ecx
	push	esi
	push	-1
	push	eax
	push	0
	push	edx
	mov	WORD PTR [esi], 0
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 605  : 	if(ret == 0)

	neg	eax
	sbb	eax, eax
	and	eax, esi
	pop	esi

; 606  : 	{
; 607  : 		ATLASSERT(FALSE);
; 608  : 		return NULL;
; 609  : 	}		
; 610  : 	return lpw;
; 611  : }

	ret	16					; 00000010H
$LN2@AtlA2WHelp:

; 599  : 		return NULL;

	xor	eax, eax
	pop	esi

; 606  : 	{
; 607  : 		ATLASSERT(FALSE);
; 608  : 		return NULL;
; 609  : 	}		
; 610  : 	return lpw;
; 611  : }

	ret	16					; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
EXTRN	__imp__WideCharToMultiByte@32:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC			; AtlW2AHelper, COMDAT

; 614  : {

	push	esi

; 615  : 	ATLASSERT(lpw != NULL);
; 616  : 	ATLASSERT(lpa != NULL);
; 617  : 	if (lpa == NULL || lpw == NULL)

	mov	esi, DWORD PTR _lpa$[esp]
	test	esi, esi
	je	SHORT $LN2@AtlW2AHelp
	mov	eax, DWORD PTR _lpw$[esp]
	test	eax, eax
	je	SHORT $LN2@AtlW2AHelp

; 619  : 	// verify that no illegal character present
; 620  : 	// since lpa was allocated based on the size of lpw
; 621  : 	// don't worry about the number of chars
; 622  : 	lpa[0] = '\0';
; 623  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

	mov	ecx, DWORD PTR _nChars$[esp]
	mov	edx, DWORD PTR _acp$[esp]
	push	0
	push	0
	push	ecx
	push	esi
	push	-1
	push	eax
	push	0
	push	edx
	mov	BYTE PTR [esi], 0
	call	DWORD PTR __imp__WideCharToMultiByte@32

; 624  : 	if(ret == 0)

	neg	eax
	sbb	eax, eax
	and	eax, esi
	pop	esi

; 625  : 	{
; 626  : 		ATLASSERT(FALSE);
; 627  : 		return NULL;
; 628  : 	}
; 629  : 	return lpa;
; 630  : }

	ret	16					; 00000010H
$LN2@AtlW2AHelp:

; 618  : 		return NULL;

	xor	eax, eax
	pop	esi

; 625  : 	{
; 626  : 		ATLASSERT(FALSE);
; 627  : 		return NULL;
; 628  : 	}
; 629  : 	return lpa;
; 630  : }

	ret	16					; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
EXTRN	__imp__RaiseException@16:PROC
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 29   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	mov	eax, DWORD PTR _dwExceptionFlags$[esp-4]
	mov	ecx, DWORD PTR _dwExceptionCode$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	call	DWORD PTR __imp__RaiseException@16

; 30   : }

	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
EXTRN	?AfxThrowOleException@@YGXJ@Z:PROC		; AfxThrowOleException
; Function compile flags: /Ogtpy
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 64   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 65   : #ifdef _AFX
; 66   : 	if( hr == E_OUTOFMEMORY )

	mov	eax, DWORD PTR _hr$[esp-4]
	cmp	eax, -2147024882			; 8007000eH
	jne	SHORT $LN2@AtlThrowIm

; 67   : 	{
; 68   : 		AfxThrowMemoryException();

	call	?AfxThrowMemoryException@@YGXXZ		; AfxThrowMemoryException
$LN2@AtlThrowIm:

; 69   : 	}
; 70   : 	else
; 71   : 	{
; 72   : 		AfxThrowOleException( hr );

	push	eax
	call	?AfxThrowOleException@@YGXJ@Z		; AfxThrowOleException
$LN5@AtlThrowIm:
	int	3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
EXTRN	__imp__GetLastError@0:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
?AtlThrowLastWin32@ATL@@YGXXZ PROC			; ATL::AtlThrowLastWin32, COMDAT

; 83   : 	DWORD dwError = ::GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 84   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

	test	eax, eax
	jle	SHORT $LN4@AtlThrowLa
	and	eax, 65535				; 0000ffffH
	or	eax, -2147024896			; 80070000H
$LN4@AtlThrowLa:
	push	eax
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN5@AtlThrowLa:
	int	3
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
PUBLIC	?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z		; ATL::Checked::wcscpy_s
EXTRN	__imp__wcscpy_s:PROC
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlchecked.h
;	COMDAT ?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S1max$ = 12						; size = 4
__S2$ = 16						; size = 4
?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z PROC		; ATL::Checked::wcscpy_s, COMDAT

; 87   : 	ATLMFC_CRT_ERRORCHECK(::wcscpy_s(_S1, _S1max, _S2));

	mov	eax, DWORD PTR __S2$[esp-4]
	mov	ecx, DWORD PTR __S1max$[esp-4]
	mov	edx, DWORD PTR __S1$[esp-4]
	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__wcscpy_s
	push	eax
	call	?AfxCrtErrorCheck@@YAHH@Z		; AfxCrtErrorCheck
	add	esp, 16					; 00000010H

; 88   : }

	ret	0
?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z ENDP		; ATL::Checked::wcscpy_s
_TEXT	ENDS
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 113  : 		DeleteCriticalSection(&m_sec);

	push	ecx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 114  : 		return S_OK;

	xor	eax, eax

; 115  : 	}	

	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
PUBLIC	??1CComBSTR@ATL@@QAE@XZ				; ATL::CComBSTR::~CComBSTR
EXTRN	__imp__SysFreeString@4:PROC
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComBSTR@ATL@@QAE@XZ PROC				; ATL::CComBSTR::~CComBSTR, COMDAT
; _this$ = ecx

; 1352 : 		::SysFreeString(m_str);

	mov	eax, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 1353 : 	}

	ret	0
??1CComBSTR@ATL@@QAE@XZ ENDP				; ATL::CComBSTR::~CComBSTR
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
EXTRN	__imp__GetVersion@0:PROC
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlconv.h
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\cstringt.h
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC	; ATL::_AtlInstallStringThunk, COMDAT

; 147  : #pragma warning (push)
; 148  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 149  : 
; 150  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

	test	BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	jne	SHORT $LN8@AtlInstall
	or	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	call	DWORD PTR __imp__GetVersion@0
	shr	eax, 31					; 0000001fH
	and	al, 1
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	jmp	SHORT $LN3@AtlInstall
$LN8@AtlInstall:
	mov	al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$LN3@AtlInstall:

; 151  : 	
; 152  : #pragma warning (pop)
; 153  : 
; 154  : 	void* pfn;
; 155  : 	if (s_bWin9x)

	test	al, al

; 156  : 		pfn = pfnWin9x;

	mov	eax, DWORD PTR _pfnWin9x$[esp-4]
	jne	SHORT $LN1@AtlInstall

; 157  : 	else
; 158  : 	{
; 159  : #ifdef _CSTRING_ALWAYS_THUNK
; 160  : 		pfn = pfnWin9x;
; 161  : 		(void)pfnNT;
; 162  : #else
; 163  : 		pfn = pfnNT;

	mov	eax, DWORD PTR _pfnNT$[esp-4]
$LN1@AtlInstall:

; 164  : #endif
; 165  : 	}
; 166  : 	InterlockedExchangePointer(ppThunk, pfn);

	push	eax
	mov	eax, DWORD PTR _ppThunk$[esp]
	push	eax
	call	DWORD PTR __imp__InterlockedExchange@8

; 167  : }

	ret	0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ?_AfxInitManaged@@YAHXZ
_TEXT	SEGMENT
?_AfxInitManaged@@YAHXZ PROC				; _AfxInitManaged, COMDAT

; 77   : 	return 0;

	xor	eax, eax

; 78   : }

	ret	0
?_AfxInitManaged@@YAHXZ ENDP				; _AfxInitManaged
_TEXT	ENDS
PUBLIC	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
; Function compile flags: /Ogtpy
;	COMDAT ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ PROC	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	ret	0
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ENDP	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
_TEXT	ENDS
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 635  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 649  : 	{

	push	esi
	mov	esi, ecx

; 650  : 		// Walk the list and free the buffers
; 651  : 		while (m_pHead != NULL)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN1@CAtlSafeAl
	push	edi
	mov	edi, DWORD PTR __imp__free
	npad	1
$LL2@CAtlSafeAl:

; 652  : 		{
; 653  : 			CAtlSafeAllocBufferNode* p = m_pHead;

	mov	eax, DWORD PTR [esi]

; 654  : 			m_pHead = m_pHead->m_pNext;

	mov	ecx, DWORD PTR [eax]

; 655  : 			Allocator::Free(p);

	push	eax
	mov	DWORD PTR [esi], ecx
	call	edi
	add	esp, 4
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL2@CAtlSafeAl
	pop	edi
$LN1@CAtlSafeAl:
	pop	esi

; 656  : 		}
; 657  : 	}

	ret	0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 455  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 456  : 	}

	ret	0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
; Function compile flags: /Ogtpy
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 473  : 		return( m_p );

	mov	eax, DWORD PTR [ecx]

; 474  : 	}

	ret	0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlconv.h
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC			; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 474  : 		return( m_psz );

	mov	eax, DWORD PTR [ecx]

; 475  : 	}

	ret	0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 144  : 		return m_nSize;

	mov	eax, DWORD PTR [ecx+4]

; 145  : 	}

	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 192  : 	{

	push	esi
	mov	esi, ecx

; 193  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN9@RemoveAll

; 194  : 		{
; 195  : 			for(int i = 0; i < m_nSize; i++)
; 196  : 				m_aT[i].~T();
; 197  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 198  : 			m_aT = NULL;

	mov	DWORD PTR [esi], edi
$LN9@RemoveAll:

; 199  : 		}
; 200  : 		m_nSize = 0;
; 201  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 202  :     }   

	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 214  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 215  : 		if(nIndex < 0 || nIndex >= m_nSize)

	mov	eax, DWORD PTR _nIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@operator
	cmp	eax, DWORD PTR [ecx+4]
	jge	SHORT $LN1@operator

; 216  : 		{
; 217  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);					
; 218  : 		}
; 219  : 		return m_aT[nIndex];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*2]

; 220  : 	}

	ret	4
$LN1@operator:
	push	0
	push	0
	push	1
	push	-1073741684				; c000008cH
	call	DWORD PTR __imp__RaiseException@16
$LN7@operator:
	int	3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 553  : 		Allocator::Free( m_p );

	mov	eax, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp__free
	pop	ecx

; 554  : 	}

	ret	0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Ogtpy
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 628  : 			return (this + 1);

	lea	eax, DWORD PTR [ecx+8]

; 629  : 		}

	ret	0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Ogtpy
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 533  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

	mov	eax, DWORD PTR _nBytes$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 534  : 		if( p == NULL )

	test	eax, eax
	jne	SHORT $LN1@AllocateHe

; 535  : 		{
; 536  : 			AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN1@AllocateHe:

; 537  : 		}
; 538  : 		m_p = p;

	mov	DWORD PTR [esi], eax
	pop	esi

; 539  : 	}

	ret	4
$LN6@AllocateHe:
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
PUBLIC	??$AtlAdd@K@ATL@@YAJPAKKK@Z			; ATL::AtlAdd<unsigned long>
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlAdd@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlAdd<unsigned long>, COMDAT

; 96   : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

	mov	eax, DWORD PTR _tLeft$[esp-4]
	mov	ecx, DWORD PTR _tRight$[esp-4]
	or	edx, -1
	sub	edx, eax
	cmp	edx, ecx
	jae	SHORT $LN1@AtlAdd

; 97   : 	{
; 98   : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 102  : }

	ret	0
$LN1@AtlAdd:

; 99   : 	}
; 100  : 	*ptResult= tLeft + tRight;

	add	eax, ecx
	mov	ecx, DWORD PTR _ptResult$[esp-4]
	mov	DWORD PTR [ecx], eax

; 101  : 	return S_OK;

	xor	eax, eax

; 102  : }

	ret	0
??$AtlAdd@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlAdd<unsigned long>
_TEXT	ENDS
PUBLIC	??$AtlAddThrow@K@ATL@@YAKKK@Z			; ATL::AtlAddThrow<unsigned long>
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlAddThrow@K@ATL@@YAKKK@Z
_TEXT	SEGMENT
_tLeft$ = 8						; size = 4
_tRight$ = 12						; size = 4
??$AtlAddThrow@K@ATL@@YAKKK@Z PROC			; ATL::AtlAddThrow<unsigned long>, COMDAT

; 186  : 	T tResult;
; 187  : 	HRESULT hr=AtlAdd(&tResult, tLeft, tRight);

	mov	eax, DWORD PTR _tLeft$[esp-4]
	mov	ecx, DWORD PTR _tRight$[esp-4]
	or	edx, -1
	sub	edx, eax
	cmp	edx, ecx
	jb	SHORT $LN7@AtlAddThro
	add	eax, ecx

; 188  : 	if(FAILED(hr))
; 189  : 	{
; 190  : 		AtlThrow(hr);
; 191  : 	}
; 192  : 	return tResult;
; 193  : }

	ret	0
$LN7@AtlAddThro:
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN8@AtlAddThro:
	int	3
??$AtlAddThrow@K@ATL@@YAKKK@Z ENDP			; ATL::AtlAddThrow<unsigned long>
_TEXT	ENDS
PUBLIC	??$AtlMultiplyThrow@I@ATL@@YAIII@Z		; ATL::AtlMultiplyThrow<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlMultiplyThrow@I@ATL@@YAIII@Z
_TEXT	SEGMENT
_tLeft$ = 8						; size = 4
_tRight$ = 12						; size = 4
??$AtlMultiplyThrow@I@ATL@@YAIII@Z PROC			; ATL::AtlMultiplyThrow<unsigned int>, COMDAT

; 174  : 	T tResult;
; 175  : 	HRESULT hr=AtlMultiply(&tResult, tLeft, tRight);

	mov	eax, DWORD PTR _tLeft$[esp-4]
	mul	DWORD PTR _tRight$[esp-4]
	test	edx, edx
	ja	SHORT $LN8@AtlMultipl@3
	cmp	eax, -1

; 176  : 	if(FAILED(hr))

	jbe	SHORT $LN2@AtlMultipl@3
$LN8@AtlMultipl@3:

; 177  : 	{
; 178  : 		AtlThrow(hr);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN2@AtlMultipl@3:

; 179  : 	}
; 180  : 	return tResult;
; 181  : }

	ret	0
$LN9@AtlMultipl@3:
??$AtlMultiplyThrow@I@ATL@@YAIII@Z ENDP			; ATL::AtlMultiplyThrow<unsigned int>
_TEXT	ENDS
PUBLIC	??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z		; ATL::AtlConvFreeMemory<char>
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
_pszFixedBuffer$ = 12					; size = 4
_nFixedBufferLength$ = 16				; size = 4
??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z PROC		; ATL::AtlConvFreeMemory<char>, COMDAT

; 216  : 	(nFixedBufferLength);
; 217  : 	if( pBuff != pszFixedBuffer )

	mov	eax, DWORD PTR _pBuff$[esp-4]
	cmp	eax, DWORD PTR _pszFixedBuffer$[esp-4]
	je	SHORT $LN1@AtlConvFre

; 218  : 	{
; 219  : 		free( pBuff );

	push	eax
	call	DWORD PTR __imp__free
	pop	ecx
$LN1@AtlConvFre:

; 220  : 	} 	
; 221  : #ifdef _DEBUG
; 222  : 	else
; 223  : 	{		
; 224  : 		memset(pszFixedBuffer,ATLCONV_DEADLAND_FILL,nFixedBufferLength*sizeof(_CharType));
; 225  : 	}
; 226  : #endif
; 227  : 
; 228  : }

	ret	0
??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z ENDP		; ATL::AtlConvFreeMemory<char>
_TEXT	ENDS
PUBLIC	??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z	; ATL::AtlConvAllocMemory<char>
EXTRN	__imp__calloc:PROC
EXTRN	__imp___recalloc:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z
_TEXT	SEGMENT
_ppBuff$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pszFixedBuffer$ = 16					; size = 4
_nFixedBufferLength$ = 20				; size = 4
??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z PROC	; ATL::AtlConvAllocMemory<char>, COMDAT

; 173  : {

	push	esi

; 174  : 	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);

	mov	esi, DWORD PTR _ppBuff$[esp]
	test	esi, esi
	jne	SHORT $LN19@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN19@AtlConvAll:

; 175  : 	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);

	mov	ecx, DWORD PTR _nLength$[esp]
	test	ecx, ecx
	jge	SHORT $LN15@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN15@AtlConvAll:
	push	edi

; 176  : 	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

	mov	edi, DWORD PTR _pszFixedBuffer$[esp+4]
	test	edi, edi
	jne	SHORT $LN11@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN11@AtlConvAll:

; 177  : 
; 178  : 	//if buffer malloced, try to realloc.
; 179  : 	if (*ppBuff != pszFixedBuffer)

	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	je	SHORT $LN8@AtlConvAll

; 180  : 	{
; 181  : 		if( nLength > nFixedBufferLength )

	cmp	ecx, DWORD PTR _nFixedBufferLength$[esp+4]
	jle	SHORT $LN7@AtlConvAll

; 182  : 		{
; 183  : 			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );

	push	1
	push	ecx
	push	eax
	call	DWORD PTR __imp___recalloc
	add	esp, 12					; 0000000cH

; 184  : 			if (ppReallocBuf == NULL) 

	test	eax, eax
	jne	SHORT $LN6@AtlConvAll

; 185  : 			{
; 186  : 				AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN7@AtlConvAll:

; 187  : 			}
; 188  : 			*ppBuff = ppReallocBuf;
; 189  : 		} else
; 190  : 		{
; 191  : 			free(*ppBuff);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN3@AtlConvAll:

; 201  : 		{			
; 202  : 			*ppBuff=pszFixedBuffer;

	mov	DWORD PTR [esi], edi
$LN2@AtlConvAll:

; 203  : 		}
; 204  : 	}
; 205  : 
; 206  : 	if (*ppBuff == NULL)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN23@AtlConvAll

; 207  : 	{
; 208  : 		AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN8@AtlConvAll:

; 192  : 			*ppBuff=pszFixedBuffer;
; 193  : 		}
; 194  : 
; 195  : 	} else //Buffer is not currently malloced.
; 196  : 	{
; 197  : 		if( nLength > nFixedBufferLength )

	cmp	ecx, DWORD PTR _nFixedBufferLength$[esp+4]
	jle	SHORT $LN3@AtlConvAll

; 198  : 		{
; 199  : 			*ppBuff = static_cast< _CharType* >( calloc(nLength,sizeof( _CharType ) ) );

	push	1
	push	ecx
	call	DWORD PTR __imp__calloc
	add	esp, 8
$LN6@AtlConvAll:
	mov	DWORD PTR [esi], eax

; 200  : 		} else

	jmp	SHORT $LN2@AtlConvAll
$LN23@AtlConvAll:
	pop	edi
	pop	esi

; 209  : 	}
; 210  : 
; 211  : }

	ret	0
$LN24@AtlConvAll:
??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z ENDP	; ATL::AtlConvAllocMemory<char>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
EXTRN	__imp___resetstkoflw:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__except_handler4:PROC
EXTRN	__alloca_probe_16:PROC
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__sehtable$?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN7@AtlVerifyS
	DD	FLAT:$LN8@AtlVerifyS
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
_size$51497 = -36					; size = 4
_bStackAvailable$ = -29					; size = 1
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 580  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 581  :     bool bStackAvailable = true;

	mov	bl, 1

; 582  : 
; 583  :     __try

	xor	esi, esi
	mov	DWORD PTR __$SEHRec$[ebp+20], esi

; 584  :     {
; 585  : 		SIZE_T size=0;

	mov	DWORD PTR _size$51497[ebp], esi

; 586  : 		HRESULT hrAdd=::ATL::AtlAdd(&size, Size, static_cast<SIZE_T>(_ATL_STACK_MARGIN));

	push	8192					; 00002000H
	mov	eax, DWORD PTR _Size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _size$51497[ebp]
	push	ecx
	call	??$AtlAdd@K@ATL@@YAJPAKKK@Z		; ATL::AtlAdd<unsigned long>
	add	esp, 12					; 0000000cH

; 587  : 		if(FAILED(hrAdd))

	cmp	eax, esi
	jge	SHORT $LN2@AtlVerifyS

; 588  : 		{
; 589  : 			ATLASSERT(FALSE);
; 590  : 			bStackAvailable = false;

	xor	bl, bl
	mov	BYTE PTR _bStackAvailable$[ebp], bl

; 591  : 		}
; 592  : 		else

	jmp	SHORT $LN1@AtlVerifyS
$LN2@AtlVerifyS:

; 593  : 		{
; 594  : 			PVOID p = _alloca(size);

	mov	eax, DWORD PTR _size$51497[ebp]
	call	__alloca_probe_16
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 595  : 			(p);
; 596  : 		}
; 597  :     }

	jmp	SHORT $LN1@AtlVerifyS
$LN7@AtlVerifyS:

; 598  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 599  :                    EXCEPTION_EXECUTE_HANDLER :
; 600  :                    EXCEPTION_CONTINUE_SEARCH)

	mov	edx, DWORD PTR __$SEHRec$[ebp+4]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	xor	ecx, ecx
	cmp	eax, -1073741571			; c00000fdH
	sete	cl
	mov	eax, ecx
$LN9@AtlVerifyS:
	ret	0
$LN8@AtlVerifyS:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 601  :     {
; 602  :         bStackAvailable = false;

	xor	bl, bl
	mov	BYTE PTR _bStackAvailable$[ebp], bl

; 603  :         _resetstkoflw();

	call	DWORD PTR __imp___resetstkoflw
$LN1@AtlVerifyS:

; 604  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH

; 605  :     return bStackAvailable;

	mov	al, bl

; 606  : }

	lea	esp, DWORD PTR [ebp-52]
	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
PUBLIC	_AtlWinModuleTerm@8
EXTRN	__imp__UnregisterClassA@8:PROC
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlbase.h
;	COMDAT _AtlWinModuleTerm@8
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
_AtlWinModuleTerm@8 PROC				; COMDAT

; 6735 : {

	push	esi

; 6736 : 	if (pWinModule == NULL)

	mov	esi, DWORD PTR _pWinModule$[esp]
	push	edi
	xor	edi, edi
	cmp	esi, edi
	jne	SHORT $LN6@AtlWinModu
$LN35@AtlWinModu:
	pop	edi

; 6737 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	pop	esi

; 6749 : }

	ret	8
$LN6@AtlWinModu:

; 6738 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR [esi]
	cmp	eax, edi

; 6739 : 		return S_OK;

	je	SHORT $LN34@AtlWinModu

; 6740 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	eax, 44					; 0000002cH

; 6741 : 		return E_INVALIDARG;

	jne	SHORT $LN35@AtlWinModu

; 6742 : 
; 6743 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	cmp	DWORD PTR [esi+36], edi
	push	ebx
	push	ebp
	jle	SHORT $LN1@AtlWinModu

; 6744 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	ebx, DWORD PTR _hInst$[esp+12]
	mov	ebp, DWORD PTR __imp__UnregisterClassA@8
$LL3@AtlWinModu:
	test	edi, edi
	jl	SHORT $LN28@AtlWinModu
	cmp	edi, DWORD PTR [esi+36]
	jge	SHORT $LN28@AtlWinModu
	mov	eax, DWORD PTR [esi+32]
	movzx	ecx, WORD PTR [eax+edi*2]
	push	ebx
	push	ecx
	call	ebp
	add	edi, 1
	cmp	edi, DWORD PTR [esi+36]
	jl	SHORT $LL3@AtlWinModu
	xor	edi, edi
$LN1@AtlWinModu:

; 6745 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, edi
	je	SHORT $LN21@AtlWinModu
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	mov	DWORD PTR [esi+32], edi
$LN21@AtlWinModu:

; 6746 : 	pWinModule->m_csWindowCreate.Term();

	lea	edx, DWORD PTR [esi+4]
	push	edx
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	call	DWORD PTR __imp__DeleteCriticalSection@4
	pop	ebp

; 6747 : 	pWinModule->cbSize = 0;

	mov	DWORD PTR [esi], edi
	pop	ebx
$LN34@AtlWinModu:
	pop	edi

; 6748 : 	return S_OK;

	xor	eax, eax
	pop	esi

; 6749 : }

	ret	8
$LN28@AtlWinModu:
	push	0
	push	0
	push	1
	push	-1073741684				; c000008cH
	call	DWORD PTR __imp__RaiseException@16
$LN33@AtlWinModu:
	int	3
_AtlWinModuleTerm@8 ENDP
_TEXT	ENDS
PUBLIC	??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z PROC	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	test	bl, 2
	push	esi
	mov	esi, ecx
	je	SHORT $LN3@vector
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector:
	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	test	bl, 1
	je	SHORT $LN1@vector
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ENDP	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 638  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));

	mov	eax, DWORD PTR _nRequestedSize$[esp-4]
	push	esi
	mov	esi, ecx
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, 8
	jb	SHORT $LN15@Allocate
	add	eax, 8
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 639  : 		if (p == NULL)

	test	eax, eax
	jne	SHORT $LN1@Allocate
	pop	esi

; 647  : 	}

	ret	4
$LN15@Allocate:

; 638  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN1@Allocate:

; 640  : 			return NULL;
; 641  : 		
; 642  : 		// Add buffer to the list
; 643  : 		p->m_pNext = m_pHead;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 644  : 		m_pHead = p;

	mov	DWORD PTR [esi], eax

; 645  : 		
; 646  : 		return p->GetData();

	add	eax, 8
	pop	esi

; 647  : 	}

	ret	4
$LN16@Allocate:
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 465  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

	lea	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN1@CTempBuffe

; 466  : 		{
; 467  : 			FreeHeap();

	jmp	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$LN1@CTempBuffe:

; 468  : 		}
; 469  : 	}

	ret	0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlconv.h
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 469  : 		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 4
	cmp	eax, ecx
	je	SHORT $LN3@CW2AEX
	push	eax
	call	DWORD PTR __imp__free
	pop	ecx
$LN3@CW2AEX:

; 470  : 	}

	ret	0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 517  : 		ATLASSERT( m_p == NULL );
; 518  : 		if( nBytes > t_nFixedBytes )

	mov	eax, DWORD PTR _nBytes$[esp-4]
	cmp	eax, 128				; 00000080H
	push	esi
	mov	esi, ecx
	jbe	SHORT $LN2@AllocateBy

; 519  : 		{
; 520  : 			AllocateHeap( nBytes );

	push	eax
	call	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 525  : 		}
; 526  : 
; 527  : 		return( m_p );

	mov	eax, DWORD PTR [esi]
	pop	esi

; 528  : 	}

	ret	4
$LN2@AllocateBy:

; 521  : 		}
; 522  : 		else
; 523  : 		{
; 524  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	pop	esi

; 528  : 	}

	ret	4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z		; ATL::CW2AEX<128>::Init
EXTRN	__imp__lstrlenW@4:PROC
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
_nConvertCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z PROC		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 479  : 	{

	push	ebx
	push	ebp

; 480  : 		if (psz == NULL)

	mov	ebp, DWORD PTR _psz$[esp+4]
	test	ebp, ebp
	mov	ebx, ecx
	jne	SHORT $LN4@Init

; 481  : 		{
; 482  : 			m_psz = NULL;

	mov	DWORD PTR [ebx], ebp
	pop	ebp
	pop	ebx

; 503  : 		}
; 504  : 	}

	ret	8
$LN4@Init:
	push	esi
	push	edi

; 483  : 			return;
; 484  : 		}
; 485  : 		int nLengthW = lstrlenW( psz )+1;		 

	push	ebp
	call	DWORD PTR __imp__lstrlenW@4
	mov	edi, eax

; 486  : 		int nLengthA = nLengthW*4;
; 487  : 		
; 488  : 		AtlConvAllocMemory(&m_psz,nLengthA,m_szBuffer,t_nBufferLength);

	push	128					; 00000080H
	lea	eax, DWORD PTR [ebx+4]
	add	edi, 1
	push	eax
	lea	esi, DWORD PTR [edi*4]
	push	esi
	push	ebx
	call	??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z ; ATL::AtlConvAllocMemory<char>

; 489  : 
; 490  : 		BOOL bFailed=(0 == ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ));

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _nConvertCodePage$[esp+28]
	add	esp, 16					; 00000010H
	push	0
	push	0
	push	esi
	push	eax
	push	edi
	push	ebp
	push	0
	push	ecx
	call	DWORD PTR __imp__WideCharToMultiByte@32
	mov	esi, eax
	neg	esi
	sbb	esi, esi
	inc	esi

; 491  : 		if (bFailed)

	je	SHORT $LN7@Init

; 492  : 		{
; 493  : 			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)

	call	DWORD PTR __imp__GetLastError@0
	cmp	eax, 122				; 0000007aH
	jne	SHORT $LN2@Init

; 494  : 			{
; 495  : 				nLengthA = ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, NULL, 0, NULL, NULL );

	mov	edx, DWORD PTR _nConvertCodePage$[esp+12]
	push	0
	push	0
	push	0
	push	0
	push	edi
	push	ebp
	push	0
	push	edx
	call	DWORD PTR __imp__WideCharToMultiByte@32
	mov	esi, eax

; 496  : 				AtlConvAllocMemory(&m_psz,nLengthA,m_szBuffer,t_nBufferLength);

	push	128					; 00000080H
	lea	eax, DWORD PTR [ebx+4]
	push	eax
	push	esi
	push	ebx
	call	??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z ; ATL::AtlConvAllocMemory<char>

; 497  : 				bFailed=(0 == ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ));

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _nConvertCodePage$[esp+28]
	add	esp, 16					; 00000010H
	push	0
	push	0
	push	esi
	push	eax
	push	edi
	push	ebp
	push	0
	push	ecx
	call	DWORD PTR __imp__WideCharToMultiByte@32
	mov	esi, eax
	neg	esi
	sbb	esi, esi
	add	esi, 1
$LN2@Init:

; 498  : 			}			
; 499  : 		}
; 500  : 		if (bFailed)

	test	esi, esi
	je	SHORT $LN7@Init

; 501  : 		{
; 502  : 			AtlThrowLastWin32();

	call	?AtlThrowLastWin32@ATL@@YGXXZ		; ATL::AtlThrowLastWin32
$LN7@Init:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 503  : 		}
; 504  : 	}

	ret	8
$LN9@Init:
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringA@24:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__allmul:PROC
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z$0
__ehfuncinfo$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
_pszAString1$ = -28					; size = 4
__acp_ex$ = -24						; size = 4
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z PROC		; ATL::CompareStringWFake, COMDAT

; 235  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 236  : 	USES_CONVERSION_EX;

	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	xor	ebx, ebx
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __AtlSafeAllocaManager$[ebp], ebx

; 237  : 	
; 238  : 	LPCSTR pszAString1 = NULL;
; 239  : 	if(pszString1 != NULL)

	mov	edi, DWORD PTR _pszString1$[ebp]
	cmp	edi, ebx
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	mov	DWORD PTR _pszAString1$[ebp], ebx
	je	SHORT $LN3@CompareStr

; 240  : 	{
; 241  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	push	edi
	call	DWORD PTR __imp__lstrlenW@4
	push	ebx
	add	eax, 1
	cdq
	push	2
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	add	eax, -2147483648			; 80000000H
	adc	edx, ebx
	test	edx, edx
	ja	SHORT $LN41@CompareStr
	jb	SHORT $LN44@CompareStr
	cmp	eax, -1
	ja	SHORT $LN41@CompareStr
$LN44@CompareStr:
	cmp	esi, 1024				; 00000400H
	jg	SHORT $LN7@CompareStr
	push	esi
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	test	al, al
	je	SHORT $LN7@CompareStr
	mov	eax, esi
	call	__alloca_probe_16
	mov	eax, esp
	jmp	SHORT $LN8@CompareStr
$LN7@CompareStr:
	push	esi
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	ebx, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN8@CompareStr:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	push	esi
	push	edi
	push	eax
	call	?AtlW2AHelper@@YGPADPADPB_WHI@Z		; AtlW2AHelper

; 242  : 		if(pszAString1 == NULL)

	test	eax, eax
	mov	DWORD PTR _pszAString1$[ebp], eax
	jne	SHORT $LN3@CompareStr
$LN41@CompareStr:

; 243  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN3@CompareStr:

; 244  : 	}
; 245  : 
; 246  : 	LPCSTR pszAString2 = NULL;
; 247  : 	if(pszString2 != NULL)

	mov	edi, DWORD PTR _pszString2$[ebp]
	xor	eax, eax
	test	edi, edi
	je	SHORT $LN1@CompareStr

; 248  : 	{
; 249  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	push	edi
	call	DWORD PTR __imp__lstrlenW@4
	push	0
	add	eax, 1
	cdq
	push	2
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	add	eax, -2147483648			; 80000000H
	adc	edx, 0
	test	edx, edx
	ja	SHORT $LN43@CompareStr
	jb	SHORT $LN45@CompareStr
	cmp	eax, -1
	ja	SHORT $LN43@CompareStr
$LN45@CompareStr:
	cmp	esi, 1024				; 00000400H
	jg	SHORT $LN13@CompareStr
	push	esi
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	test	al, al
	je	SHORT $LN13@CompareStr
	mov	eax, esi
	call	__alloca_probe_16
	mov	eax, esp
	jmp	SHORT $LN14@CompareStr
$LN13@CompareStr:
	push	esi
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	ebx, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN14@CompareStr:
	mov	edx, DWORD PTR __acp_ex$[ebp]
	push	edx
	push	esi
	push	edi
	push	eax
	call	?AtlW2AHelper@@YGPADPADPB_WHI@Z		; AtlW2AHelper

; 250  : 		if(pszAString2 == NULL)

	test	eax, eax
	jne	SHORT $LN1@CompareStr
$LN43@CompareStr:

; 251  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN1@CompareStr:

; 252  : 	}
; 253  : 
; 254  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

	mov	ecx, DWORD PTR _nLength2$[ebp]
	mov	edx, DWORD PTR _nLength1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _dwFlags$[ebp]
	push	eax
	mov	eax, DWORD PTR _pszAString1$[ebp]
	push	edx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__CompareStringA@24
	test	ebx, ebx
	mov	edi, eax
	je	SHORT $LN32@CompareStr
	mov	esi, DWORD PTR __imp__free
	npad	7
$LL33@CompareStr:
	mov	eax, ebx
	mov	ebx, DWORD PTR [ebx]
	push	eax
	call	esi
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LL33@CompareStr
$LN32@CompareStr:
	mov	eax, edi

; 255  : }

	lea	esp, DWORD PTR [ebp-44]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN49@CompareStr:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z$0:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z PROC		; ATL::CompareStringWThunk, COMDAT

; 260  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

	test	BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	jne	SHORT $LN10@CompareStr@2
	or	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	call	DWORD PTR __imp__GetVersion@0
	shr	eax, 31					; 0000001fH
	and	al, 1
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	jmp	SHORT $LN5@CompareStr@2
$LN10@CompareStr@2:
	mov	al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$LN5@CompareStr@2:
	test	al, al
	mov	eax, OFFSET ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ; ATL::CompareStringWFake
	jne	SHORT $LN3@CompareStr@2
	mov	eax, DWORD PTR __imp__CompareStringW@24
$LN3@CompareStr@2:
	push	eax
	push	OFFSET ?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
	call	DWORD PTR __imp__InterlockedExchange@8

; 261  : 
; 262  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

	jmp	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?lstrcmpiWFake@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiA@8:PROC
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?lstrcmpiWFake@ATL@@YGHPB_W0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?lstrcmpiWFake@ATL@@YGHPB_W0@Z$0
__ehfuncinfo$?lstrcmpiWFake@ATL@@YGHPB_W0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?lstrcmpiWFake@ATL@@YGHPB_W0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
tv204 = -40						; size = 8
tv235 = -32						; size = 8
tv128 = -28						; size = 4
__acp_ex$ = -24						; size = 4
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPB_W0@Z PROC			; ATL::lstrcmpiWFake, COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?lstrcmpiWFake@ATL@@YGHPB_W0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 291  : 	USES_CONVERSION_EX;

	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	xor	ebx, ebx
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __AtlSafeAllocaManager$[ebp], ebx

; 292  : 
; 293  : 	return ::lstrcmpiA(W2A_EX_DEF(psz1), W2A_EX_DEF(psz2));

	mov	edi, DWORD PTR _psz2$[ebp]
	cmp	edi, ebx
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	jne	SHORT $LN7@lstrcmpiWF
	mov	DWORD PTR tv128[ebp], ebx
	jmp	SHORT $LN6@lstrcmpiWF
$LN7@lstrcmpiWF:
	push	edi
	call	DWORD PTR __imp__lstrlenW@4
	push	ebx
	add	eax, 1
	cdq
	push	2
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	add	eax, -2147483648			; 80000000H
	adc	edx, 0
	mov	DWORD PTR tv235[ebp+4], edx
	jne	SHORT $LN38@lstrcmpiWF
	cmp	eax, -1
	jbe	SHORT $LN5@lstrcmpiWF
$LN38@lstrcmpiWF:
	mov	DWORD PTR tv128[ebp], 0
	jmp	SHORT $LN6@lstrcmpiWF
$LN5@lstrcmpiWF:
	cmp	esi, 1024				; 00000400H
	jg	SHORT $LN3@lstrcmpiWF
	push	esi
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	test	al, al
	je	SHORT $LN3@lstrcmpiWF
	mov	eax, esi
	call	__alloca_probe_16
	mov	eax, esp
	jmp	SHORT $LN4@lstrcmpiWF
$LN3@lstrcmpiWF:
	push	esi
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	ebx, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN4@lstrcmpiWF:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	push	esi
	push	edi
	push	eax
	call	?AtlW2AHelper@@YGPADPADPB_WHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv128[ebp], eax
$LN6@lstrcmpiWF:
	mov	edi, DWORD PTR _psz1$[ebp]
	test	edi, edi
	jne	SHORT $LN13@lstrcmpiWF
	xor	eax, eax
	jmp	SHORT $LN12@lstrcmpiWF
$LN13@lstrcmpiWF:
	push	edi
	call	DWORD PTR __imp__lstrlenW@4
	push	0
	add	eax, 1
	cdq
	push	2
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	add	eax, -2147483648			; 80000000H
	adc	edx, 0
	mov	DWORD PTR tv204[ebp+4], edx
	jne	SHORT $LN39@lstrcmpiWF
	cmp	eax, -1
	jbe	SHORT $LN11@lstrcmpiWF
$LN39@lstrcmpiWF:
	xor	eax, eax
	jmp	SHORT $LN12@lstrcmpiWF
$LN11@lstrcmpiWF:
	cmp	esi, 1024				; 00000400H
	jg	SHORT $LN9@lstrcmpiWF
	push	esi
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	test	al, al
	je	SHORT $LN9@lstrcmpiWF
	mov	eax, esi
	call	__alloca_probe_16
	mov	eax, esp
	jmp	SHORT $LN10@lstrcmpiWF
$LN9@lstrcmpiWF:
	push	esi
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	ebx, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN10@lstrcmpiWF:
	mov	edx, DWORD PTR __acp_ex$[ebp]
	push	edx
	push	esi
	push	edi
	push	eax
	call	?AtlW2AHelper@@YGPADPADPB_WHI@Z		; AtlW2AHelper
$LN12@lstrcmpiWF:
	mov	ecx, DWORD PTR tv128[ebp]
	push	ecx
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	test	ebx, ebx
	mov	edi, eax
	je	SHORT $LN40@lstrcmpiWF
	mov	esi, DWORD PTR __imp__free
	npad	3
$LL29@lstrcmpiWF:
	mov	eax, ebx
	mov	ebx, DWORD PTR [ebx]
	push	eax
	call	esi
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LL29@lstrcmpiWF
$LN40@lstrcmpiWF:
	mov	eax, edi

; 294  : }

	lea	esp, DWORD PTR [ebp-56]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?lstrcmpiWFake@ATL@@YGHPB_W0@Z$0:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?lstrcmpiWFake@ATL@@YGHPB_W0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?lstrcmpiWFake@ATL@@YGHPB_W0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?lstrcmpiWFake@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z PROC			; ATL::lstrcmpiWThunk, COMDAT

; 298  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

	test	BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	jne	SHORT $LN10@lstrcmpiWT
	or	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	call	DWORD PTR __imp__GetVersion@0
	shr	eax, 31					; 0000001fH
	and	al, 1
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	jmp	SHORT $LN5@lstrcmpiWT
$LN10@lstrcmpiWT:
	mov	al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$LN5@lstrcmpiWT:
	test	al, al
	mov	eax, OFFSET ?lstrcmpiWFake@ATL@@YGHPB_W0@Z ; ATL::lstrcmpiWFake
	jne	SHORT $LN3@lstrcmpiWT
	mov	eax, DWORD PTR __imp__lstrcmpiW@8
$LN3@lstrcmpiWT:
	push	eax
	push	OFFSET ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	call	DWORD PTR __imp__InterlockedExchange@8

; 299  : 
; 300  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

	jmp	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CharLowerWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWFake
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__CharLowerA@4:PROC
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?CharLowerWFake@ATL@@YGPA_WPA_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CharLowerWFake@ATL@@YGPA_WPA_W@Z$0
__ehfuncinfo$?CharLowerWFake@ATL@@YGPA_WPA_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CharLowerWFake@ATL@@YGPA_WPA_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv241 = -32						; size = 8
tv210 = -32						; size = 8
__acp_ex$ = -24						; size = 4
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z PROC			; ATL::CharLowerWFake, COMDAT

; 304  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CharLowerWFake@ATL@@YGPA_WPA_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 305  : 	ATLENSURE(psz);

	mov	esi, DWORD PTR _psz$[ebp]
	xor	eax, eax
	xor	edi, edi
	cmp	esi, edi
	setne	al
	cmp	eax, edi
	jne	SHORT $LN3@CharLowerW
	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN3@CharLowerW:

; 306  : 	USES_CONVERSION_EX;

	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	xor	ebx, ebx
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __AtlSafeAllocaManager$[ebp], ebx

; 307  : 	LPSTR pszA;
; 308  : 
; 309  : 	pszA = W2A_EX_DEF(psz);

	cmp	esi, edi
	mov	DWORD PTR __$EHRec$[ebp+8], edi
	je	SHORT $LN10@CharLowerW
	push	esi
	call	DWORD PTR __imp__lstrlenW@4
	push	edi
	add	eax, 1
	cdq
	push	2
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	add	eax, -2147483648			; 80000000H
	adc	edx, ebx
	mov	DWORD PTR tv241[ebp+4], edx
	jne	SHORT $LN44@CharLowerW
	cmp	eax, -1
	jbe	SHORT $LN9@CharLowerW
$LN44@CharLowerW:
	xor	edi, edi
	jmp	SHORT $LN49@CharLowerW
$LN9@CharLowerW:
	cmp	esi, 1024				; 00000400H
	jg	SHORT $LN7@CharLowerW
	push	esi
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	test	al, al
	je	SHORT $LN7@CharLowerW
	mov	eax, esi
	call	__alloca_probe_16
	mov	eax, esp
	jmp	SHORT $LN8@CharLowerW
$LN7@CharLowerW:
	push	esi
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	ebx, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN8@CharLowerW:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	mov	edx, DWORD PTR _psz$[ebp]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	?AtlW2AHelper@@YGPADPADPB_WHI@Z		; AtlW2AHelper
	mov	edi, eax
$LN49@CharLowerW:
	mov	esi, DWORD PTR _psz$[ebp]
$LN10@CharLowerW:

; 310  : 	::CharLowerA(pszA);

	push	edi
	call	DWORD PTR __imp__CharLowerA@4

; 311  : 
; 312  : 	Checked::wcscpy_s(psz, wcslen(psz) + 1, A2W_EX_DEF(pszA));

	test	edi, edi
	jne	SHORT $LN17@CharLowerW
	xor	eax, eax
	jmp	SHORT $LN16@CharLowerW
$LN17@CharLowerW:
	push	edi
	call	DWORD PTR __imp__lstrlenA@4
	push	0
	add	eax, 1
	cdq
	push	2
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	add	eax, -2147483648			; 80000000H
	adc	edx, 0
	mov	DWORD PTR tv210[ebp+4], edx
	jne	SHORT $LN45@CharLowerW
	cmp	eax, -1
	jbe	SHORT $LN15@CharLowerW
$LN45@CharLowerW:
	xor	eax, eax
	jmp	SHORT $LN50@CharLowerW
$LN15@CharLowerW:
	cmp	esi, 1024				; 00000400H
	jg	SHORT $LN13@CharLowerW
	push	esi
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	test	al, al
	je	SHORT $LN13@CharLowerW
	mov	eax, esi
	call	__alloca_probe_16
	mov	eax, esp
	jmp	SHORT $LN14@CharLowerW
$LN13@CharLowerW:
	push	esi
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	ebx, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN14@CharLowerW:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	shr	esi, 1
	push	esi
	push	edi
	push	eax
	call	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z	; AtlA2WHelper
$LN50@CharLowerW:
	mov	esi, DWORD PTR _psz$[ebp]
$LN16@CharLowerW:
	mov	ecx, esi
	lea	edi, DWORD PTR [ecx+2]
$LL46@CharLowerW:
	mov	dx, WORD PTR [ecx]
	add	ecx, 2
	test	dx, dx
	jne	SHORT $LL46@CharLowerW
	sub	ecx, edi
	sar	ecx, 1
	push	eax
	add	ecx, 1
	push	ecx
	push	esi
	call	DWORD PTR __imp__wcscpy_s
	push	eax
	call	?AfxCrtErrorCheck@@YAHH@Z		; AfxCrtErrorCheck
	add	esp, 16					; 00000010H

; 313  : 	return psz;

	test	ebx, ebx
	je	SHORT $LN34@CharLowerW
	mov	edi, DWORD PTR __imp__free
$LL35@CharLowerW:
	mov	eax, ebx
	mov	ebx, DWORD PTR [ebx]
	push	eax
	call	edi
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LL35@CharLowerW
$LN34@CharLowerW:
	mov	eax, esi

; 314  : }

	lea	esp, DWORD PTR [ebp-48]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN48@CharLowerW:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CharLowerWFake@ATL@@YGPA_WPA_W@Z$0:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CharLowerWFake@ATL@@YGPA_WPA_W@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CharLowerWFake@ATL@@YGPA_WPA_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CharLowerWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z PROC			; ATL::CharLowerWThunk, COMDAT

; 318  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

	test	BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	jne	SHORT $LN10@CharLowerW@2
	or	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	call	DWORD PTR __imp__GetVersion@0
	shr	eax, 31					; 0000001fH
	and	al, 1
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	jmp	SHORT $LN5@CharLowerW@2
$LN10@CharLowerW@2:
	mov	al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$LN5@CharLowerW@2:
	test	al, al
	mov	eax, OFFSET ?CharLowerWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharLowerWFake
	jne	SHORT $LN3@CharLowerW@2
	mov	eax, DWORD PTR __imp__CharLowerW@4
$LN3@CharLowerW@2:
	push	eax
	push	OFFSET ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	call	DWORD PTR __imp__InterlockedExchange@8

; 319  : 
; 320  : 	return _strthunks.pfnCharLowerW(psz);

	jmp	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CharUpperWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWFake
EXTRN	__imp__CharUpperA@4:PROC
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?CharUpperWFake@ATL@@YGPA_WPA_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CharUpperWFake@ATL@@YGPA_WPA_W@Z$0
__ehfuncinfo$?CharUpperWFake@ATL@@YGPA_WPA_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CharUpperWFake@ATL@@YGPA_WPA_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv241 = -32						; size = 8
tv210 = -32						; size = 8
__acp_ex$ = -24						; size = 4
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z PROC			; ATL::CharUpperWFake, COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CharUpperWFake@ATL@@YGPA_WPA_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 325  : 	ATLENSURE(psz);

	mov	esi, DWORD PTR _psz$[ebp]
	xor	eax, eax
	xor	edi, edi
	cmp	esi, edi
	setne	al
	cmp	eax, edi
	jne	SHORT $LN3@CharUpperW
	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN3@CharUpperW:

; 326  : 	USES_CONVERSION_EX;

	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	xor	ebx, ebx
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __AtlSafeAllocaManager$[ebp], ebx

; 327  : 	LPSTR pszA;
; 328  : 
; 329  : 	pszA = W2A_EX_DEF(psz);

	cmp	esi, edi
	mov	DWORD PTR __$EHRec$[ebp+8], edi
	je	SHORT $LN10@CharUpperW
	push	esi
	call	DWORD PTR __imp__lstrlenW@4
	push	edi
	add	eax, 1
	cdq
	push	2
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	add	eax, -2147483648			; 80000000H
	adc	edx, ebx
	mov	DWORD PTR tv241[ebp+4], edx
	jne	SHORT $LN44@CharUpperW
	cmp	eax, -1
	jbe	SHORT $LN9@CharUpperW
$LN44@CharUpperW:
	xor	edi, edi
	jmp	SHORT $LN49@CharUpperW
$LN9@CharUpperW:
	cmp	esi, 1024				; 00000400H
	jg	SHORT $LN7@CharUpperW
	push	esi
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	test	al, al
	je	SHORT $LN7@CharUpperW
	mov	eax, esi
	call	__alloca_probe_16
	mov	eax, esp
	jmp	SHORT $LN8@CharUpperW
$LN7@CharUpperW:
	push	esi
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	ebx, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN8@CharUpperW:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	mov	edx, DWORD PTR _psz$[ebp]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	?AtlW2AHelper@@YGPADPADPB_WHI@Z		; AtlW2AHelper
	mov	edi, eax
$LN49@CharUpperW:
	mov	esi, DWORD PTR _psz$[ebp]
$LN10@CharUpperW:

; 330  : 	::CharUpperA(pszA);

	push	edi
	call	DWORD PTR __imp__CharUpperA@4

; 331  : 
; 332  : 	Checked::wcscpy_s(psz, wcslen(psz) + 1, A2W_EX_DEF(pszA));

	test	edi, edi
	jne	SHORT $LN17@CharUpperW
	xor	eax, eax
	jmp	SHORT $LN16@CharUpperW
$LN17@CharUpperW:
	push	edi
	call	DWORD PTR __imp__lstrlenA@4
	push	0
	add	eax, 1
	cdq
	push	2
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	add	eax, -2147483648			; 80000000H
	adc	edx, 0
	mov	DWORD PTR tv210[ebp+4], edx
	jne	SHORT $LN45@CharUpperW
	cmp	eax, -1
	jbe	SHORT $LN15@CharUpperW
$LN45@CharUpperW:
	xor	eax, eax
	jmp	SHORT $LN50@CharUpperW
$LN15@CharUpperW:
	cmp	esi, 1024				; 00000400H
	jg	SHORT $LN13@CharUpperW
	push	esi
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	test	al, al
	je	SHORT $LN13@CharUpperW
	mov	eax, esi
	call	__alloca_probe_16
	mov	eax, esp
	jmp	SHORT $LN14@CharUpperW
$LN13@CharUpperW:
	push	esi
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	ebx, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN14@CharUpperW:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	shr	esi, 1
	push	esi
	push	edi
	push	eax
	call	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z	; AtlA2WHelper
$LN50@CharUpperW:
	mov	esi, DWORD PTR _psz$[ebp]
$LN16@CharUpperW:
	mov	ecx, esi
	lea	edi, DWORD PTR [ecx+2]
$LL46@CharUpperW:
	mov	dx, WORD PTR [ecx]
	add	ecx, 2
	test	dx, dx
	jne	SHORT $LL46@CharUpperW
	sub	ecx, edi
	sar	ecx, 1
	push	eax
	add	ecx, 1
	push	ecx
	push	esi
	call	DWORD PTR __imp__wcscpy_s
	push	eax
	call	?AfxCrtErrorCheck@@YAHH@Z		; AfxCrtErrorCheck
	add	esp, 16					; 00000010H

; 333  : 	return psz;

	test	ebx, ebx
	je	SHORT $LN34@CharUpperW
	mov	edi, DWORD PTR __imp__free
$LL35@CharUpperW:
	mov	eax, ebx
	mov	ebx, DWORD PTR [ebx]
	push	eax
	call	edi
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LL35@CharUpperW
$LN34@CharUpperW:
	mov	eax, esi

; 334  : }

	lea	esp, DWORD PTR [ebp-48]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN48@CharUpperW:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CharUpperWFake@ATL@@YGPA_WPA_W@Z$0:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CharUpperWFake@ATL@@YGPA_WPA_W@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CharUpperWFake@ATL@@YGPA_WPA_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CharUpperWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z PROC			; ATL::CharUpperWThunk, COMDAT

; 338  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

	test	BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	jne	SHORT $LN10@CharUpperW@2
	or	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	call	DWORD PTR __imp__GetVersion@0
	shr	eax, 31					; 0000001fH
	and	al, 1
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	jmp	SHORT $LN5@CharUpperW@2
$LN10@CharUpperW@2:
	mov	al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$LN5@CharUpperW@2:
	test	al, al
	mov	eax, OFFSET ?CharUpperWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharUpperWFake
	jne	SHORT $LN3@CharUpperW@2
	mov	eax, DWORD PTR __imp__CharUpperW@4
$LN3@CharUpperW@2:
	push	eax
	push	OFFSET ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	call	DWORD PTR __imp__InterlockedExchange@8

; 339  : 
; 340  : 	return _strthunks.pfnCharUpperW(psz);

	jmp	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 483  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

	mov	eax, DWORD PTR _nElements$[esp-4]
	push	esi
	mov	esi, ecx
	xor	ecx, ecx
	ja	SHORT $LN15@Allocate@2
	cmp	eax, -1
	jbe	SHORT $LN3@Allocate@2
$LN15@Allocate@2:
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN3@Allocate@2:
	cmp	eax, 128				; 00000080H
	jbe	SHORT $LN11@Allocate@2
	push	eax
	mov	ecx, esi
	call	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
	mov	eax, DWORD PTR [esi]
	pop	esi

; 484  : 	}

	ret	4

; 483  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

$LN11@Allocate@2:
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	pop	esi

; 484  : 	}

	ret	4
$LN16@Allocate@2:
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z		; ATL::CW2AEX<128>::CW2AEX<128>
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z PROC			; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 459  : 	{

	push	esi
	mov	esi, ecx
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax

; 460  : 		Init( psz, _AtlGetConversionACP() );

	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	mov	ecx, DWORD PTR _psz$[esp]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z	; ATL::CW2AEX<128>::Init

; 461  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableA@12:PROC
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z$1
__ehfuncinfo$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszBufferA$ = -280					; size = 132
_pszNameA$ = -148					; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z PROC	; ATL::GetEnvironmentVariableWFake, COMDAT

; 192  : {

	push	-1
	push	__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+280], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+300]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _pszName$[esp+296]
	mov	ebp, DWORD PTR _pszBuffer$[esp+296]

; 193  : 	ULONG nSizeA;
; 194  : 	ULONG nSizeW;
; 195  : 	CTempBuffer<char> pszBufferA;

	xor	ebx, ebx
	mov	DWORD PTR _pszBufferA$[esp+300], ebx

; 196  : 	CW2A pszNameA(pszName);

	lea	eax, DWORD PTR _pszNameA$[esp+304]
	mov	DWORD PTR __$EHRec$[esp+308], ebx
	mov	DWORD PTR _pszNameA$[esp+300], eax
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	push	eax
	push	esi
	lea	ecx, DWORD PTR _pszNameA$[esp+308]
	call	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z	; ATL::CW2AEX<128>::Init

; 197  : 
; 198  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

	mov	ecx, DWORD PTR _pszNameA$[esp+300]
	mov	edi, DWORD PTR __imp__GetEnvironmentVariableA@12
	push	ebx
	push	ebx
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+320], 1
	call	edi
	mov	esi, eax

; 199  : 	if( nSizeA == 0 || nSizeA==ULONG_MAX)

	cmp	esi, ebx
	je	$LN4@GetEnviron
	cmp	esi, -1
	je	$LN4@GetEnviron

; 202  : 	}
; 203  : 
; 204  : 	pszBufferA.Allocate(nSizeA + 1);

	xor	ecx, ecx
	cmp	ecx, ebx
	lea	eax, DWORD PTR [esi+1]
	ja	SHORT $LN77@GetEnviron
	cmp	eax, -1
	jbe	SHORT $LN28@GetEnviron
$LN77@GetEnviron:
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN28@GetEnviron:
	cmp	eax, 128				; 00000080H
	jbe	SHORT $LN36@GetEnviron
	push	eax
	lea	ecx, DWORD PTR _pszBufferA$[esp+304]
	call	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
	jmp	SHORT $LN35@GetEnviron
$LN36@GetEnviron:
	lea	edx, DWORD PTR _pszBufferA$[esp+304]
	mov	DWORD PTR _pszBufferA$[esp+300], edx
$LN35@GetEnviron:

; 205  : 	if( 0 == ::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA))

	mov	eax, DWORD PTR _pszBufferA$[esp+300]
	mov	ecx, DWORD PTR _pszNameA$[esp+300]
	push	esi
	push	eax
	push	ecx
	call	edi
	test	eax, eax
	jne	SHORT $LN3@GetEnviron

; 206  : 	{
; 207  : 		return 0;

	mov	eax, DWORD PTR _pszNameA$[esp+300]
	lea	edx, DWORD PTR _pszNameA$[esp+304]
	cmp	eax, edx
	je	SHORT $LN46@GetEnviron
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN46@GetEnviron:
	lea	eax, DWORD PTR _pszBufferA$[esp+304]
	cmp	DWORD PTR _pszBufferA$[esp+300], eax
	jmp	$LN81@GetEnviron
$LN3@GetEnviron:

; 208  : 	}
; 209  : 
; 210  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

	mov	esi, DWORD PTR _pszBufferA$[esp+300]
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	push	ebx
	push	ebx
	push	-1
	push	esi
	push	ebx
	mov	ebx, DWORD PTR __imp__MultiByteToWideChar@24
	push	eax
	call	ebx
	mov	esi, eax

; 211  : 	if( nSize == 0 )

	mov	eax, DWORD PTR _nSize$[esp+296]
	test	eax, eax
	jne	SHORT $LN2@GetEnviron
$LN1@GetEnviron:

; 212  : 	{
; 213  : 		return nSizeW;

	mov	eax, DWORD PTR _pszNameA$[esp+300]
	lea	ecx, DWORD PTR _pszNameA$[esp+304]
	cmp	eax, ecx
	je	SHORT $LN58@GetEnviron
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN58@GetEnviron:
	lea	edx, DWORD PTR _pszBufferA$[esp+304]
	cmp	DWORD PTR _pszBufferA$[esp+300], edx
	je	SHORT $LN61@GetEnviron
	lea	ecx, DWORD PTR _pszBufferA$[esp+300]
	call	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$LN61@GetEnviron:
	mov	eax, esi
	jmp	SHORT $LN6@GetEnviron
$LN2@GetEnviron:

; 214  : 	}
; 215  : 	
; 216  : 	if( nSize >= nSizeW )

	cmp	eax, esi
	jb	SHORT $LN1@GetEnviron

; 217  : 	{
; 218  : 		nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW );

	mov	edi, DWORD PTR _pszBufferA$[esp+300]
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	push	esi
	push	ebp
	push	-1
	push	edi
	push	0
	push	eax
	call	ebx
	mov	esi, eax

; 219  : 	}
; 220  : 
; 221  : 	return nSizeW;

	jmp	SHORT $LN1@GetEnviron
$LN4@GetEnviron:

; 200  : 	{
; 201  : 		return 0;

	mov	eax, DWORD PTR _pszNameA$[esp+300]
	lea	ecx, DWORD PTR _pszNameA$[esp+304]
	cmp	eax, ecx
	je	SHORT $LN20@GetEnviron
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN20@GetEnviron:
	lea	edx, DWORD PTR _pszBufferA$[esp+304]
	cmp	DWORD PTR _pszBufferA$[esp+300], edx
$LN81@GetEnviron:
	je	SHORT $LN23@GetEnviron
	lea	ecx, DWORD PTR _pszBufferA$[esp+300]
	call	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$LN23@GetEnviron:
	xor	eax, eax
$LN6@GetEnviron:

; 222  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+300]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+280]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 280				; 00000118H
	ret	12					; 0000000cH
$LN79@GetEnviron:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z$0:
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__unwindfunclet$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z$1:
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	jmp	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-284]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z PROC	; ATL::GetEnvironmentVariableWThunk, COMDAT

; 227  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 228  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

	test	BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	jne	SHORT $LN10@GetEnviron@2
	or	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	call	DWORD PTR __imp__GetVersion@0
	shr	eax, 31					; 0000001fH
	and	al, 1
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	jmp	SHORT $LN5@GetEnviron@2
$LN10@GetEnviron@2:
	mov	al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$LN5@GetEnviron@2:
	test	al, al
	mov	eax, OFFSET ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
	jne	SHORT $LN3@GetEnviron@2
	mov	eax, DWORD PTR __imp__GetEnvironmentVariableW@12
$LN3@GetEnviron@2:
	push	eax
	push	OFFSET ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	call	DWORD PTR __imp__InterlockedExchange@8

; 229  : 
; 230  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

	jmp	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	_pwCharType$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExA@20:PROC
;	COMDAT xdata$x
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z$0
__ehfuncinfo$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_pwCharType$GSCopy$ = -152				; size = 4
_pszA$ = -148						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z PROC		; ATL::GetStringTypeExWFake, COMDAT

; 267  : {

	push	-1
	push	__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+152], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+172]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _pwCharType$[esp+168]
	mov	edi, DWORD PTR _pszSrc$[esp+168]

; 268  : 	int nLengthA;
; 269  : 	CTempBuffer<char> pszA;

	xor	esi, esi

; 273  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

	mov	DWORD PTR _pwCharType$GSCopy$[esp+172], eax
	mov	DWORD PTR _pszA$[esp+172], esi
	mov	DWORD PTR __$EHRec$[esp+180], esi
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	mov	ebx, DWORD PTR _nLength$[esp+168]
	mov	ebp, DWORD PTR __imp__WideCharToMultiByte@32
	push	esi
	push	esi
	push	esi
	push	esi
	push	ebx
	push	edi
	push	esi
	push	eax
	call	ebp
	mov	esi, eax
	xor	eax, eax
	ja	SHORT $LN33@GetStringT

; 270  : 
; 271  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);
; 272  : 	pszA.Allocate(nLengthA);

	cmp	esi, -1
	jbe	SHORT $LN11@GetStringT
$LN33@GetStringT:
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN11@GetStringT:
	cmp	esi, 128				; 00000080H
	jbe	SHORT $LN19@GetStringT
	push	esi
	lea	ecx, DWORD PTR _pszA$[esp+176]
	call	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
	jmp	SHORT $LN18@GetStringT
$LN19@GetStringT:
	lea	ecx, DWORD PTR _pszA$[esp+176]
	mov	DWORD PTR _pszA$[esp+172], ecx
$LN18@GetStringT:

; 273  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

	mov	edx, DWORD PTR _pszA$[esp+172]
	push	0
	push	0
	push	esi
	push	edx
	push	ebx
	push	edi
	push	0
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	push	eax
	call	ebp

; 274  : 
; 275  : 	if (nLength == -1)

	cmp	ebx, -1
	jne	SHORT $LN1@GetStringT

; 276  : 		nLengthA = -1;

	or	esi, ebx
$LN1@GetStringT:

; 277  : 
; 278  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

	mov	eax, DWORD PTR _pwCharType$GSCopy$[esp+172]
	mov	ecx, DWORD PTR _pszA$[esp+172]
	mov	edx, DWORD PTR _dwInfoType$[esp+168]
	push	eax
	mov	eax, DWORD PTR _lcid$[esp+172]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__GetStringTypeExA@20
	lea	ecx, DWORD PTR _pszA$[esp+176]
	cmp	DWORD PTR _pszA$[esp+172], ecx
	mov	esi, eax
	je	SHORT $LN29@GetStringT
	lea	ecx, DWORD PTR _pszA$[esp+172]
	call	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$LN29@GetStringT:
	mov	eax, esi

; 279  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+172]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+152]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 152				; 00000098H
	ret	20					; 00000014H
$LN35@GetStringT:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z$0:
	lea	ecx, DWORD PTR _pszA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-156]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ENDP		; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z PROC	; ATL::GetStringTypeExWThunk, COMDAT

; 284  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

	test	BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	jne	SHORT $LN10@GetStringT@2
	or	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
	call	DWORD PTR __imp__GetVersion@0
	shr	eax, 31					; 0000001fH
	and	al, 1
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	jmp	SHORT $LN5@GetStringT@2
$LN10@GetStringT@2:
	mov	al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$LN5@GetStringT@2:
	test	al, al
	mov	eax, OFFSET ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ; ATL::GetStringTypeExWFake
	jne	SHORT $LN3@GetStringT@2
	mov	eax, DWORD PTR __imp__GetStringTypeExW@20
$LN3@GetStringT@2:
	push	eax
	push	OFFSET ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	call	DWORD PTR __imp__InterlockedExchange@8

; 285  : 
; 286  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

	jmp	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z ENDP	; ATL::GetStringTypeExWThunk
_TEXT	ENDS
PUBLIC	?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A ; Define_the_symbol__ATL_MIXED::clash
;	COMDAT ?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A
; File f:\program files\microsoft visual studio 8\vc\atlmfc\include\atldef.h
_DATA	SEGMENT
?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A DD FLAT:??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@ ; Define_the_symbol__ATL_MIXED::clash
_DATA	ENDS
PUBLIC	?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A ; Inconsistent_definition_of_symbol__ATL_MIXED::clash
;	COMDAT ?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A
_BSS	SEGMENT
?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A DB 01H DUP (?) ; Inconsistent_definition_of_symbol__ATL_MIXED::clash
_BSS	ENDS
END
