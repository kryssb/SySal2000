	TITLE	D:\SySal2\SmartTracker8\SmartTrackerClass.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BB@NAAD@Magellan?5MSWHEEL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FPAF@MouseZ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CLBL@MSWHEEL_ROLLMSG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@DLPD@MSH_WHEELSUPPORT_MSG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@ODOJ@MSH_SCROLL_LINES_MSG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@EDBF@Object?5created?5on?5thread?5?$DN?5?$CFd?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FGFK@CLSID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03DMDD@?5?9?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MOFL@Interface?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FNJL@?$CICLSID?$DP?$DP?$DP?$CJ?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DLIL@?5?9?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@DOIJ@CPropertyHelper?3?3GetProperty?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@EJEI@CPropertyHelper?3?3PutProperty?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FH@HFKE@CComClassFactory?3?5asked?5for?5non?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PBBD@Smart?5Tracker?58?41?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GFNK@Debug?5Info?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09IOG@Here?5?9?5A?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DDBJ@Here?5?9?5B?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CFLD@Here?5?9?5C?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02JBAA@?$CFf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02DLJH@?$CFg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSmartTrackerClass@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetRawUnknown@CSmartTrackerClass@@QAEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CSmartTrackerClass@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSmartTrackerClass@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITracker4@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ISySalObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITracker3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITracker2@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITracker@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCDragListBox@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCToolBarCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStatusBarCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCListCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextItem@CListCtrl@@QBEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTreeCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHotKeyCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSpinButtonCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSliderCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCProgressCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHeaderCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCImageList@@QBEPAU_IMAGELIST@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CImageList@@QBEPAU_IMAGELIST@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTabCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAnimateCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRichEditCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCReBarCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CReBarCtrl@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCComboBoxEx@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCIPAddressCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetName@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetName@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CEditConfig@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableMonitor@CSmartTrackerClass@@UAGJE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SyncExec@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AsyncExec@CSmartTrackerClass@@UAGJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AsyncWait@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AsyncPause@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AsyncStop@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AsyncResume@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartFilling@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitTrackerData@CSmartTrackerClass@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCell@CSmartTrackerClass@@IAEHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtr@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtr@UIUnknown@@@ATL@@QAEPAPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8?$CComPtr@UIUnknown@@@ATL@@QBE_NPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIPersistStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIPersistStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtr@UIPersistStream@@@ATL@@QBEPAUIPersistStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtr@UIPersistStream@@@ATL@@QAEPAPAUIPersistStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtr@UITypeInfo@@@ATL@@QBEPAUITypeInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtr@UITypeInfo@@@ATL@@QAEPAPAUITypeInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtr@UITypeInfo@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeInfo@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtr@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtr@UITypeInfo2@@@ATL@@QAEPAPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@IUnknown@@QAGJPAPAUITypeInfo2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCScrollBar@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCEdit@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCComboBox@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCheckListBox@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCheckListBox@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCListBox@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCButton@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStatic@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMenu@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMenu@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMenu@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCRgn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRgn@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CRgn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCPalette@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPalette@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CPalette@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCNoTrackObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CNoTrackObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBrush@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCPen@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPen@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CPen@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCUserException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUserException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CUserException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CSimpleException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSimpleException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCResourceException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CResourceException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CResourceException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCNotSupportedException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CNotSupportedException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CNotSupportedException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMemoryException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMemoryException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMemoryException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCSimpleException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFileException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFileException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFileException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCArchiveException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CArchiveException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CArchiveException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCOleException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1COleException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7COleException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00020412_0000_0000_c000_000000000046
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComAutoCriticalSection@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CComAutoCriticalSection@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0H@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CIPAddressCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CComboBoxEx@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CComboBox@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CComboBox@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?FromHandle@CPalette@@SGPAV1@PAUHPALETTE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CReBarCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CRichEditCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CAnimateCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CSize@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTabCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CHeaderCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CProgressCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSliderCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSpinButtonCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHotKeyCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTreeCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CListCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CStatusBarCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CToolBarCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CDragListBox@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CListBox@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CListBox@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CComAutoCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComAutoCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CSmartTrackerClass@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_c022eead_748a_11d3_a47b_e89c0bce9720
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __GUID_04e5187b_933e_4d9e_9a7f_eb20840da9d0
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __GUID_7a9e779c_aa32_4565_8e69_5f1bc4e362b7
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __GUID_67a71430_f2e4_42ae_8910_28279a7616d6
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __GUID_e416c46d_7f68_11d3_a47c_fa1e4afa2721
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Cache@CComObjectRootBase@ATL@@SGJPAXABU_GUID@@PAPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AFX_MAINTAIN_STATE2@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, xdata$x
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?pHelpPath@CSmartTrackerClass@@2PADA		; CSmartTrackerClass::pHelpPath
PUBLIC	?ConfigDataQDI@@3PAUQueryDataInfo@@A		; ConfigDataQDI
_BSS	SEGMENT
?pHelpPath@CSmartTrackerClass@@2PADA DD 01H DUP (?)	; CSmartTrackerClass::pHelpPath
_?run@?7??PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z@4HA DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?ConfigDataQDI@@3PAUQueryDataInfo@@A DB 'MaxGrains', 00H ; ConfigDataQDI
	ORG $+54
	DB	01H
	ORG $+3
	DD	00H
	DB	'10000', 00H
	ORG $+58
	DB	'CellOverflow', 00H
	ORG $+51
	DB	01H
	ORG $+3
	DD	08H
	DB	'32', 00H
	ORG $+61
	DB	'LayerNum', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	04H
	DB	'20', 00H
	ORG $+61
	DB	'CellNumX', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0cH
	DB	'10', 00H
	ORG $+61
	DB	'CellNumY', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	010H
	DB	'10', 00H
	ORG $+61
	DB	'PixMin', 00H
	ORG $+57
	DB	01H
	ORG $+3
	DD	014H
	DB	'2', 00H
	ORG $+62
	DB	'PixMax', 00H
	ORG $+57
	DB	01H
	ORG $+3
	DD	018H
	DB	'64', 00H
	ORG $+61
	DB	'AlignTol', 00H
	ORG $+55
	DB	02H
	ORG $+3
	DD	01cH
	DB	'.7', 00H
	ORG $+61
	DB	'LongitTolMultiplier', 00H
	ORG $+44
	DB	02H
	ORG $+3
	DD	020H
	DB	'1.0', 00H
	ORG $+60
	DB	'TrialCount', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	024H
	DB	'0', 00H
	ORG $+62
	DB	'NptMinV', 00H
	ORG $+56
	DB	02H
	ORG $+3
	DD	02e8H
	DB	'8.1', 00H
	ORG $+60
	DB	'NptMinH', 00H
	ORG $+56
	DB	02H
	ORG $+3
	DD	02ecH
	DB	'7', 00H
	ORG $+62
	DB	'NptMin01', 00H
	ORG $+55
	DB	02H
	ORG $+3
	DD	02f0H
	DB	'8', 00H
	ORG $+62
	DB	'MinSlope', 00H
	ORG $+55
	DB	02H
	ORG $+3
	DD	02f4H
	DB	'-.0005', 00H
	ORG $+57
	DB	'MaxSlope', 00H
	ORG $+55
	DB	02H
	ORG $+3
	DD	02f8H
	DB	'1', 00H
	ORG $+62
	DB	'Processors', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02fcH
	DB	'2', 00H
	ORG $+62
	DB	'MaxTrackingTime', 00H
	ORG $+48
	DB	01H
	ORG $+3
	DD	0300H
	DB	'300', 00H
	ORG $+60
	DB	'ReplicaRadius', 00H
	ORG $+50
	DB	02H
	ORG $+3
	DD	0304H
	DB	'2', 00H
	ORG $+62
	DB	'MinReplicas', 00H
	ORG $+52
	DB	01H
	ORG $+3
	DD	0308H
	DB	'40', 00H
	ORG $+61
	DB	'MaxReplicaSpread', 00H
	ORG $+47
	DB	02H
	ORG $+3
	DD	030cH
	DB	'1', 00H
	ORG $+62
	DB	'DiscardShadowSigma', 00H
	ORG $+45
	DB	02H
	ORG $+3
	DD	0310H
	DB	'2', 00H
	ORG $+62
	DB	'CheckGrainSpacing', 00H
	ORG $+46
	DB	01H
	ORG $+3
	DD	0314H
	DB	'1', 00H
	ORG $+62
	DB	'InitialMultiplicity', 00H
	ORG $+44
	DB	01H
	ORG $+3
	DD	0318H
	DB	'2', 00H
	ORG $+62
	DB	'TransverseSigmaLimit', 00H
	ORG $+43
	DB	02H
	ORG $+3
	DD	031cH
	DB	'0.2', 00H
	ORG $+60
	DB	'TTop0', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	028H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom0', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	02cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggers0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	030H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger00', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	034H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger01', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	038H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger02', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	03cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger03', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	040H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger04', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	044H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger05', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	048H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger06', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	04cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger07', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	050H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop1', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	054H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom1', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	058H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger1', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	05cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger10', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	060H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger11', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	064H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger12', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	068H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger13', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	06cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger14', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	070H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger15', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	074H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger16', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	078H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger17', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	07cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTop2', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	080H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom2', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	084H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger2', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	088H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger20', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	08cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger21', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	090H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger22', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	094H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger23', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	098H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger24', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	09cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger25', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0a0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger26', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0a4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger27', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0a8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop3', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0acH
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom3', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0b0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger3', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0b4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger30', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0b8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger31', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0bcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger32', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0c0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger33', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0c4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger34', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0c8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger35', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0ccH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger36', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0d0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger37', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0d4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop4', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0d8H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom4', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0dcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger4', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0e0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger40', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0e4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger41', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0e8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger42', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0ecH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger43', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0f0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger44', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0f4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger45', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0f8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger46', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0fcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger47', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0100H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop5', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0104H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom5', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0108H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger5', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	010cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger50', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0110H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger51', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0114H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger52', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0118H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger53', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	011cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger54', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0120H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger55', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0124H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger56', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0128H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger57', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	012cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTop6', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0130H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom6', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0134H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger6', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0138H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger60', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	013cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger61', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0140H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger62', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0144H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger63', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0148H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger64', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	014cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger65', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0150H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger66', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0154H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger67', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0158H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop7', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	015cH
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom7', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0160H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger7', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0164H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger70', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0168H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger71', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	016cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger72', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0170H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger73', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0174H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger74', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0178H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger75', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	017cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger76', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0180H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger77', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0184H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop8', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0188H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom8', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	018cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger8', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0190H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger80', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0194H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger81', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0198H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger82', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	019cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger83', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01a0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger84', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01a4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger85', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01a8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger86', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01acH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger87', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01b0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTop9', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	01b4H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottom9', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	01b8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger9', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	01bcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger90', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01c0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger91', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01c4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger92', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01c8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger93', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01ccH
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger94', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01d0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger95', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01d4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger96', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01d8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTrigger97', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01dcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTopA', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	01e0H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomA', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	01e4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	01e8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01ecH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01f0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01f4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01f8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	01fcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0200H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0204H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerA7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0208H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopB', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	020cH
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomB', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0210H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0214H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0218H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	021cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0220H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0224H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0228H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	022cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0230H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerB7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0234H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopC', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0238H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomC', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	023cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0240H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0244H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0248H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	024cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0250H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0254H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0258H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	025cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerC7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0260H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopD', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0264H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomD', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0268H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	026cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0270H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0274H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0278H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	027cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0280H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0284H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	0288H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerD7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	028cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTopE', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	0290H
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomE', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	0294H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	0298H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	029cH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02a0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02a4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02a8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02acH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02b0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02b4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerE7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02b8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTopF', 00H
	ORG $+58
	DB	01H
	ORG $+3
	DD	02bcH
	DB	'-1', 00H
	ORG $+61
	DB	'TBottomF', 00H
	ORG $+55
	DB	01H
	ORG $+3
	DD	02c0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF', 00H
	ORG $+54
	DB	01H
	ORG $+3
	DD	02c4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF0', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02c8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF1', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02ccH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF2', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02d0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF3', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02d4H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF4', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02d8H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF5', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02dcH
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF6', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02e0H
	DB	'-1', 00H
	ORG $+61
	DB	'TTriggerF7', 00H
	ORG $+53
	DB	01H
	ORG $+3
	DD	02e4H
	DB	'-1', 00H
	ORG $+61
_DATA	ENDS
PUBLIC	?SetName@CSmartTrackerClass@@UAGJQAD@Z		; CSmartTrackerClass::SetName
EXTRN	__imp__strncpy:NEAR
;	COMDAT ?SetName@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT
_name$ = 12
_this$ = 8
?SetName@CSmartTrackerClass@@UAGJQAD@Z PROC NEAR	; CSmartTrackerClass::SetName, COMDAT

; 243  : 	// TODO: Add your implementation code here
; 244  : 	strncpy(Name, name, SYSAL_MAX_CONN_NAME_LEN);

	mov	ecx, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR _name$[esp-4]
	push	64					; 00000040H
	add	ecx, 32					; 00000020H
	push	eax
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 245  : 	return S_OK;

	xor	eax, eax

; 246  : }

	ret	8
?SetName@CSmartTrackerClass@@UAGJQAD@Z ENDP		; CSmartTrackerClass::SetName
_TEXT	ENDS
PUBLIC	?GetName@CSmartTrackerClass@@UAGJQAD@Z		; CSmartTrackerClass::GetName
;	COMDAT ?GetName@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT
_name$ = 12
_this$ = 8
?GetName@CSmartTrackerClass@@UAGJQAD@Z PROC NEAR	; CSmartTrackerClass::GetName, COMDAT

; 250  : 	// TODO: Add your implementation code here
; 251  : 	strncpy(name, Name, SYSAL_MAX_CONN_NAME_LEN);

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ecx, DWORD PTR _name$[esp-4]
	add	eax, 32					; 00000020H
	push	64					; 00000040H
	push	eax
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 252  : 	return S_OK;

	xor	eax, eax

; 253  : }

	ret	8
?GetName@CSmartTrackerClass@@UAGJQAD@Z ENDP		; CSmartTrackerClass::GetName
_TEXT	ENDS
PUBLIC	?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z ; CSmartTrackerClass::SetConfig
PUBLIC	?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ	; CSmartTrackerClass::ResetDeltaHisto
PUBLIC	?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z	; CSmartTrackerClass::TrackerThreadHook
PUBLIC	?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ; GetData
EXTRN	__imp__GlobalFree@4:NEAR
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	__imp___beginthreadex:NEAR
EXTRN	__imp__SetEvent@4:NEAR
EXTRN	__imp__ResetEvent@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	__imp__GlobalAlloc@8:NEAR
;	COMDAT ?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z
_TEXT	SEGMENT
_dummy$78848 = 8
_pConfig$ = 12
_this$ = 8
?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z PROC NEAR ; CSmartTrackerClass::SetConfig, COMDAT

; 256  : {

	push	ebx
	push	ebp

; 257  : 	// TODO: Add your implementation code here
; 258  : 	OkToRun = false;
; 259  : 	if (GetData(*pConfig, ConfigDataN, ConfigDataQDI, &T, false) != ConfigDataN) return S_FALSE;

	mov	eax, DWORD PTR _pConfig$[esp+4]
	push	esi
	mov	esi, DWORD PTR _this$[esp+8]
	push	edi
	push	0
	lea	edi, DWORD PTR [esi+132]
	mov	BYTE PTR [esi+1072], 0
	push	edi
	push	OFFSET FLAT:?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	eax
	call	?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ; GetData
	add	esp, 20					; 00000014H
	cmp	eax, 200				; 000000c8H
	je	SHORT $L78807
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx

; 312  : }

	ret	8
$L78807:

; 260  : 
; 261  : 	if (T.GrainSpace) GlobalFree(T.GrainSpace);

	mov	eax, DWORD PTR [esi+932]
	mov	ebp, DWORD PTR __imp__GlobalFree@4
	test	eax, eax
	je	SHORT $L78809
	push	eax
	call	ebp
$L78809:

; 262  : 	if (!(T.GrainSpace = (IntGrain *)GlobalAlloc(GMEM_FIXED, sizeof(IntGrain) * T.MaxGrains)))

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR __imp__GlobalAlloc@8
	lea	ecx, DWORD PTR [eax+eax*4]
	shl	ecx, 2
	push	ecx
	push	0
	call	ebx
	test	eax, eax
	mov	DWORD PTR [esi+932], eax
	jne	SHORT $L78812
	pop	edi
	pop	esi
	pop	ebp

; 263  : 		return S_FALSE;

	mov	eax, 1
	pop	ebx

; 312  : }

	ret	8
$L78812:

; 264  : 	if (T.ZLayer) GlobalFree(T.ZLayer);

	mov	eax, DWORD PTR [esi+936]
	test	eax, eax
	je	SHORT $L78814
	push	eax
	call	ebp
$L78814:

; 265  : 	if (!(T.ZLayer = (float *)GlobalAlloc(GMEM_FIXED, sizeof(float) * T.LayerNum)))

	mov	edx, DWORD PTR [esi+136]
	shl	edx, 2
	push	edx
	push	0
	call	ebx
	test	eax, eax
	mov	DWORD PTR [esi+936], eax
	jne	SHORT $L78817
	pop	edi
	pop	esi
	pop	ebp

; 266  :    		return S_FALSE;

	mov	eax, 1
	pop	ebx

; 312  : }

	ret	8
$L78817:

; 267  : 	if (T.LayerGrains) GlobalFree(T.LayerGrains);

	mov	eax, DWORD PTR [esi+940]
	test	eax, eax
	je	SHORT $L78819
	push	eax
	call	ebp
$L78819:

; 268  : 	if (!(T.LayerGrains = (IntGrain **)GlobalAlloc(GMEM_FIXED, sizeof(IntGrain *) * T.LayerNum)))

	mov	eax, DWORD PTR [esi+136]
	shl	eax, 2
	push	eax
	push	0
	call	ebx
	test	eax, eax
	mov	DWORD PTR [esi+940], eax
	jne	SHORT $L78822
	pop	edi
	pop	esi
	pop	ebp

; 269  :    		return S_FALSE;

	mov	eax, 1
	pop	ebx

; 312  : }

	ret	8
$L78822:

; 270  : 	T.CellsInLayer = T.CellNumX * T.CellNumY;

	mov	ecx, DWORD PTR [esi+148]
	imul	ecx, DWORD PTR [esi+144]
	mov	DWORD PTR [esi+948], ecx

; 271  : 	if (T.CellSpace) GlobalFree(T.CellSpace);

	mov	eax, DWORD PTR [esi+944]
	test	eax, eax
	je	SHORT $L78824
	push	eax
	call	ebp
$L78824:

; 272  : 	if (!(T.CellSpace = (Cell *)GlobalAlloc(GMEM_FIXED, sizeof(Cell) * (T.CellsInLayer)*(T.LayerNum))))

	mov	edx, DWORD PTR [esi+948]
	imul	edx, DWORD PTR [esi+136]
	shl	edx, 3
	push	edx
	push	0
	call	ebx
	test	eax, eax
	mov	DWORD PTR [esi+944], eax
	jne	SHORT $L78827
	pop	edi
	pop	esi
	pop	ebp

; 273  :    		return S_FALSE;

	mov	eax, 1
	pop	ebx

; 312  : }

	ret	8
$L78827:

; 274  : 	if (T.pDeltaData) GlobalFree(T.pDeltaData);

	mov	eax, DWORD PTR [esi+1040]
	test	eax, eax
	je	SHORT $L78829
	push	eax
	call	ebp
$L78829:

; 275  : 	if (!(T.pDeltaData = (float *)GlobalAlloc(GMEM_FIXED, (4 * sizeof(float) + sizeof(IntCluster **)) * T.MaxGrains)))

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	push	eax
	push	0
	call	ebx
	test	eax, eax
	mov	DWORD PTR [esi+1040], eax
	jne	SHORT $L78833
	pop	edi
	pop	esi
	pop	ebp

; 276  : 		return S_FALSE;

	mov	eax, 1
	pop	ebx

; 312  : }

	ret	8
$L78833:

; 277  : 	else
; 278  : 	{
; 279  : 		T.pX = T.pDeltaData;

	mov	DWORD PTR [esi+1044], eax

; 280  : 		T.pY = T.pX + T.MaxGrains;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+1048], eax

; 281  : 		T.pDX = T.pY + T.MaxGrains;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+1052], eax

; 282  : 		T.pDY = T.pDX + T.MaxGrains;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ecx*4]

; 283  : 		T.pReplicas = (IntCluster **)(void *)(T.pDY + T.MaxGrains);
; 284  : 		}
; 285  : 
; 286  : 	if (!ResetDeltaHisto()) return S_FALSE;

	lea	ecx, DWORD PTR [esi-4]
	mov	DWORD PTR [esi+1056], eax
	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+1060], eax
	call	?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ ; CSmartTrackerClass::ResetDeltaHisto
	test	al, al
	jne	SHORT $L78838
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx

; 312  : }

	ret	8
$L78838:

; 287  : 	SetEvent(HTerminate);

	mov	ecx, DWORD PTR [esi+1080]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4
	mov	ebp, DWORD PTR __imp__WaitForSingleObject@8
	mov	ebx, DWORD PTR __imp__CloseHandle@4
	lea	edi, DWORD PTR [esi+1152]
	mov	DWORD PTR 8+[esp+12], 7
$L78841:

; 288  : 	int i;
; 289  : 	for (i = 1; i < MAX_PROCESSORS; i++)
; 290  : 		if (ThreadInfo[i].HThread)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $L78842

; 291  : 		{
; 292  : 			WaitForSingleObject(ThreadInfo[i].HThread, INFINITE);

	push	-1
	push	eax
	call	ebp

; 293  : 			CloseHandle(ThreadInfo[i].HThread);

	mov	edx, DWORD PTR [edi]
	push	edx
	call	ebx

; 294  : 			CloseHandle(ThreadInfo[i].HFinished);

	mov	eax, DWORD PTR [edi-4]
	push	eax
	call	ebx

; 295  : 			ThreadInfo[i].HThread = 0;

	mov	DWORD PTR [edi], 0

; 296  : 			ThreadInfo[i].HFinished = 0;

	mov	DWORD PTR [edi-4], 0
$L78842:
	mov	eax, DWORD PTR 8+[esp+12]
	add	edi, 40					; 00000028H
	dec	eax
	mov	DWORD PTR 8+[esp+12], eax
	jne	SHORT $L78841

; 297  : 			};
; 298  : 	ResetEvent(HTerminate);

	mov	ecx, DWORD PTR [esi+1080]
	mov	edi, DWORD PTR __imp__ResetEvent@4
	push	ecx
	call	edi

; 299  : 	ResetEvent(HStart);

	mov	edx, DWORD PTR [esi+1076]
	push	edx
	call	edi

; 300  : 	ResetEvent(HReset);

	mov	eax, DWORD PTR [esi+1084]
	push	eax
	call	edi

; 301  : 	ThreadInfo[0].ThreadIndex = 0;

	mov	DWORD PTR [esi+1092], 0

; 302  : 	for (i = 1; i < T.Processors; i++)

	mov	eax, DWORD PTR [esi+896]
	mov	ebp, 1
	cmp	eax, ebp
	jle	SHORT $L78847
	mov	ebx, DWORD PTR __imp__CreateEventA@16
	lea	edi, DWORD PTR [esi+1128]
$L78845:

; 303  : 	{
; 304  : 		unsigned dummy;
; 305  : 		ThreadInfo[i].HFinished = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	ebx

; 306  : 		ThreadInfo[i].pThis = this;
; 307  : 		ThreadInfo[i].ThreadIndex = i;
; 308  : 		ThreadInfo[i].HThread = (HANDLE)_beginthreadex(NULL, 0, TrackerThreadHook, ThreadInfo + i, 0, &dummy);

	lea	ecx, DWORD PTR _dummy$78848[esp+12]
	mov	DWORD PTR [edi+20], eax
	push	ecx
	push	0
	push	edi
	lea	eax, DWORD PTR [esi-4]
	push	OFFSET FLAT:?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z ; CSmartTrackerClass::TrackerThreadHook
	push	0
	mov	DWORD PTR [edi], eax
	push	0
	mov	DWORD PTR [edi+4], ebp
	call	DWORD PTR __imp___beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+24], eax
	mov	eax, DWORD PTR [esi+896]
	inc	ebp
	add	edi, 40					; 00000028H
	cmp	ebp, eax
	jl	SHORT $L78845
$L78847:

; 309  : 		}
; 310  : 	OkToRun = true;

	mov	BYTE PTR [esi+1072], 1
	pop	edi
	pop	esi
	pop	ebp

; 311  : 	return S_OK;

	xor	eax, eax
	pop	ebx

; 312  : }

	ret	8
?SetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z ENDP ; CSmartTrackerClass::SetConfig
_TEXT	ENDS
PUBLIC	?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z ; CSmartTrackerClass::GetConfig
PUBLIC	?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutData
;	COMDAT ?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z
_TEXT	SEGMENT
_pConfig$ = 12
_this$ = 8
?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z PROC NEAR ; CSmartTrackerClass::GetConfig, COMDAT

; 316  : 	// TODO: Add your implementation code here
; 317  : 
; 318  : 	if (::PutData(*pConfig, ConfigDataN, ConfigDataQDI, &T) != ConfigDataN) return S_FALSE;

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ecx, DWORD PTR _pConfig$[esp-4]
	add	eax, 132				; 00000084H
	push	eax
	push	OFFSET FLAT:?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	ecx
	call	?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutData
	add	esp, 16					; 00000010H
	xor	edx, edx
	cmp	eax, 200				; 000000c8H
	setne	dl
	mov	eax, edx

; 319  : 	return S_OK;	
; 320  : }

	ret	8
?GetConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@@Z ENDP ; CSmartTrackerClass::GetConfig
_TEXT	ENDS
PUBLIC	?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z ; CSmartTrackerClass::EditConfig
PUBLIC	??1AFX_MAINTAIN_STATE2@@QAE@XZ			; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2
PUBLIC	??1CEditConfig@@UAE@XZ				; CEditConfig::~CEditConfig
EXTRN	??1CListCtrl@@UAE@XZ:NEAR			; CListCtrl::~CListCtrl
EXTRN	?AfxGetStaticModuleState@@YGPAVAFX_MODULE_STATE@@XZ:NEAR ; AfxGetStaticModuleState
EXTRN	??0AFX_MAINTAIN_STATE2@@QAE@PAVAFX_MODULE_STATE@@@Z:NEAR ; AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2
EXTRN	??0CEditConfig@@QAE@PAVCSmartTrackerClass@@PAVCWnd@@@Z:NEAR ; CEditConfig::CEditConfig
EXTRN	??1CString@@QAE@XZ:NEAR				; CString::~CString
EXTRN	??1CWnd@@UAE@XZ:NEAR				; CWnd::~CWnd
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??0CWnd@@QAE@XZ:NEAR				; CWnd::CWnd
EXTRN	?Attach@CWnd@@QAEHPAUHWND__@@@Z:NEAR		; CWnd::Attach
EXTRN	?Detach@CWnd@@QAEPAUHWND__@@XZ:NEAR		; CWnd::Detach
EXTRN	?DoModal@CDialog@@UAEHXZ:NEAR			; CDialog::DoModal
EXTRN	??1CDialog@@UAE@XZ:NEAR				; CDialog::~CDialog
;	COMDAT xdata$x
; File C:\Program Files\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxwin1.inl
xdata$x	SEGMENT
$T80424	DD	019930520H
	DD	07H
	DD	FLAT:$T80427
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80427	DD	0ffffffffH
	DD	FLAT:$L80400
	DD	00H
	DD	FLAT:$L80401
	DD	01H
	DD	FLAT:$L80402
	DD	01H
	DD	FLAT:$L80404
	DD	03H
	DD	FLAT:$L80405
	DD	01H
	DD	FLAT:$L80413
	DD	05H
	DD	FLAT:$L80414
xdata$x	ENDS
;	COMDAT ?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z
_TEXT	SEGMENT
_pConfig$ = 12
_hWnd$ = 16
_this$ = 8
__ctlState$ = -1060
_Owner$ = -1052
_MyDlg$ = -988
__$EHRec$ = -12
?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z PROC NEAR ; CSmartTrackerClass::EditConfig, COMDAT

; 323  : {

	push	-1
	push	$L80425
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 1048				; 00000418H
	push	esi

; 324  : 	// TODO: Add your implementation code here
; 325  : 	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	call	?AfxGetStaticModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetStaticModuleState
	push	eax
	lea	ecx, DWORD PTR __ctlState$[esp+1068]
	call	??0AFX_MAINTAIN_STATE2@@QAE@PAVAFX_MODULE_STATE@@@Z ; AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2

; 326  : 	CWnd Owner;

	lea	ecx, DWORD PTR _Owner$[esp+1064]
	mov	DWORD PTR __$EHRec$[esp+1072], 0
	call	??0CWnd@@QAE@XZ				; CWnd::CWnd

; 327  : 	Owner.Attach((HWND)hWnd);

	mov	eax, DWORD PTR _hWnd$[esp+1060]
	lea	ecx, DWORD PTR _Owner$[esp+1064]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1076], 1
	call	?Attach@CWnd@@QAEHPAUHWND__@@@Z		; CWnd::Attach

; 328  : 	CEditConfig MyDlg(this, &Owner);

	lea	ecx, DWORD PTR _Owner$[esp+1064]
	mov	edx, DWORD PTR _this$[esp+1060]
	push	ecx
	add	edx, -4					; fffffffcH
	lea	ecx, DWORD PTR _MyDlg$[esp+1068]
	push	edx
	call	??0CEditConfig@@QAE@PAVCSmartTrackerClass@@PAVCWnd@@@Z ; CEditConfig::CEditConfig

; 329  : 
; 330  : 	GetData(*pConfig, ConfigDataN, ConfigDataQDI, &MyDlg.C, true);

	mov	esi, DWORD PTR _pConfig$[esp+1060]
	lea	eax, DWORD PTR _MyDlg$[esp+1160]
	push	1
	push	eax
	push	OFFSET FLAT:?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	esi
	mov	BYTE PTR __$EHRec$[esp+1092], 2
	call	?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ; GetData
	add	esp, 20					; 00000014H

; 331  : 
; 332  : 	if (MyDlg.DoModal() == IDOK)

	lea	ecx, DWORD PTR _MyDlg$[esp+1064]
	call	?DoModal@CDialog@@UAEHXZ		; CDialog::DoModal
	cmp	eax, 1
	jne	SHORT $L78867

; 333  : 	{
; 334  : 		::PutData(*pConfig, ConfigDataN, ConfigDataQDI, &MyDlg.C);

	lea	ecx, DWORD PTR _MyDlg$[esp+1160]
	push	ecx
	push	OFFSET FLAT:?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	esi
	call	?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutData
	add	esp, 16					; 00000010H

; 335  : 		Owner.Detach();

	lea	ecx, DWORD PTR _Owner$[esp+1064]
	call	?Detach@CWnd@@QAEPAUHWND__@@XZ		; CWnd::Detach

; 336  : 		return S_OK;

	lea	ecx, DWORD PTR _MyDlg$[esp+2032]
	mov	BYTE PTR __$EHRec$[esp+1072], 4
	call	??1CString@@QAE@XZ			; CString::~CString
	lea	ecx, DWORD PTR _MyDlg$[esp+1960]
	mov	BYTE PTR __$EHRec$[esp+1072], 3
	call	??1CListCtrl@@UAE@XZ			; CListCtrl::~CListCtrl
	lea	ecx, DWORD PTR _MyDlg$[esp+1064]
	mov	BYTE PTR __$EHRec$[esp+1072], 1
	call	??1CDialog@@UAE@XZ			; CDialog::~CDialog
	lea	ecx, DWORD PTR _Owner$[esp+1064]
	mov	BYTE PTR __$EHRec$[esp+1072], 0
	call	??1CWnd@@UAE@XZ				; CWnd::~CWnd
	mov	edx, DWORD PTR __ctlState$[esp+1068]
	mov	eax, DWORD PTR __ctlState$[esp+1064]
	mov	DWORD PTR [edx+4], eax
	xor	eax, eax
	jmp	SHORT $L78862
$L78867:

; 337  : 		};
; 338  : 	Owner.Detach();

	lea	ecx, DWORD PTR _Owner$[esp+1064]
	call	?Detach@CWnd@@QAEPAUHWND__@@XZ		; CWnd::Detach

; 339  : 	return S_FALSE;

	lea	ecx, DWORD PTR _MyDlg$[esp+2032]
	mov	BYTE PTR __$EHRec$[esp+1072], 6
	call	??1CString@@QAE@XZ			; CString::~CString
	lea	ecx, DWORD PTR _MyDlg$[esp+1960]
	mov	BYTE PTR __$EHRec$[esp+1072], 5
	call	??1CListCtrl@@UAE@XZ			; CListCtrl::~CListCtrl
	lea	ecx, DWORD PTR _MyDlg$[esp+1064]
	mov	BYTE PTR __$EHRec$[esp+1072], 1
	call	??1CDialog@@UAE@XZ			; CDialog::~CDialog
	lea	ecx, DWORD PTR _Owner$[esp+1064]
	mov	BYTE PTR __$EHRec$[esp+1072], 0
	call	??1CWnd@@UAE@XZ				; CWnd::~CWnd
	mov	ecx, DWORD PTR __ctlState$[esp+1068]
	mov	edx, DWORD PTR __ctlState$[esp+1064]
	mov	eax, 1
	mov	DWORD PTR [ecx+4], edx
$L78862:

; 340  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1064]
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 1060				; 00000424H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80400:
	lea	ecx, DWORD PTR __ctlState$[ebp]
	jmp	??1AFX_MAINTAIN_STATE2@@QAE@XZ		; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2
$L80401:
	lea	ecx, DWORD PTR _Owner$[ebp]
	jmp	??1CWnd@@UAE@XZ				; CWnd::~CWnd
$L80402:
	lea	ecx, DWORD PTR _MyDlg$[ebp]
	jmp	??1CEditConfig@@UAE@XZ			; CEditConfig::~CEditConfig
$L80404:
	lea	ecx, DWORD PTR _MyDlg$[ebp]
	jmp	??1CDialog@@UAE@XZ			; CDialog::~CDialog
$L80405:
	lea	ecx, DWORD PTR _MyDlg$[ebp+896]
	jmp	??1CListCtrl@@UAE@XZ			; CListCtrl::~CListCtrl
$L80413:
	lea	ecx, DWORD PTR _MyDlg$[ebp]
	jmp	??1CDialog@@UAE@XZ			; CDialog::~CDialog
$L80414:
	lea	ecx, DWORD PTR _MyDlg$[ebp+896]
	jmp	??1CListCtrl@@UAE@XZ			; CListCtrl::~CListCtrl
$L80425:
	mov	eax, OFFSET FLAT:$T80424
	jmp	___CxxFrameHandler
text$x	ENDS
?EditConfig@CSmartTrackerClass@@UAGJPAUSySalConfig@@J@Z ENDP ; CSmartTrackerClass::EditConfig
;	COMDAT ??1AFX_MAINTAIN_STATE2@@QAE@XZ
_TEXT	SEGMENT
??1AFX_MAINTAIN_STATE2@@QAE@XZ PROC NEAR		; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2, COMDAT

; 41   : 	{  m_pThreadState->m_pModuleState = m_pPrevModuleState; }

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	ret	0
??1AFX_MAINTAIN_STATE2@@QAE@XZ ENDP			; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T80439	DD	019930520H
	DD	02H
	DD	FLAT:$T80441
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80441	DD	0ffffffffH
	DD	FLAT:$L80435
	DD	00H
	DD	FLAT:$L80436
xdata$x	ENDS
;	COMDAT ??1CEditConfig@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1CEditConfig@@UAE@XZ PROC NEAR			; CEditConfig::~CEditConfig, COMDAT
	push	-1
	push	$L80440
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+968]
	mov	DWORD PTR __$EHRec$[esp+28], 1
	call	??1CString@@QAE@XZ			; CString::~CString
	lea	ecx, DWORD PTR [esi+896]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	??1CListCtrl@@UAE@XZ			; CListCtrl::~CListCtrl
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CDialog@@UAE@XZ			; CDialog::~CDialog
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80435:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CDialog@@UAE@XZ			; CDialog::~CDialog
$L80436:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	jmp	??1CListCtrl@@UAE@XZ			; CListCtrl::~CListCtrl
$L80440:
	mov	eax, OFFSET FLAT:$T80439
	jmp	___CxxFrameHandler
text$x	ENDS
??1CEditConfig@@UAE@XZ ENDP				; CEditConfig::~CEditConfig
PUBLIC	?EnableMonitor@CSmartTrackerClass@@UAGJE@Z	; CSmartTrackerClass::EnableMonitor
;	COMDAT ?EnableMonitor@CSmartTrackerClass@@UAGJE@Z
_TEXT	SEGMENT
_bEnable$ = 12
?EnableMonitor@CSmartTrackerClass@@UAGJE@Z PROC NEAR	; CSmartTrackerClass::EnableMonitor, COMDAT

; 344  : 	// TODO: Add your implementation code here
; 345  : 
; 346  : 	return (bEnable) ? S_FALSE : S_OK;

	mov	cl, BYTE PTR _bEnable$[esp-4]
	xor	eax, eax
	test	cl, cl
	setne	al

; 347  : }

	ret	8
?EnableMonitor@CSmartTrackerClass@@UAGJE@Z ENDP		; CSmartTrackerClass::EnableMonitor
_TEXT	ENDS
PUBLIC	?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z ; CSmartTrackerClass::GetNumberOfConnections
;	COMDAT ?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z
_TEXT	SEGMENT
_pNumber$ = 12
?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z PROC NEAR ; CSmartTrackerClass::GetNumberOfConnections, COMDAT

; 351  : 	// TODO: Add your implementation code here
; 352  : 
; 353  : 	*pNumber = 0;

	mov	eax, DWORD PTR _pNumber$[esp-4]
	mov	DWORD PTR [eax], 0

; 354  : 	return S_OK;

	xor	eax, eax

; 355  : }

	ret	8
?GetNumberOfConnections@CSmartTrackerClass@@UAGJPAH@Z ENDP ; CSmartTrackerClass::GetNumberOfConnections
_TEXT	ENDS
PUBLIC	?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z ; CSmartTrackerClass::SetConnection
;	COMDAT ?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z
_TEXT	SEGMENT
?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z PROC NEAR ; CSmartTrackerClass::SetConnection, COMDAT

; 359  : 	// TODO: Add your implementation code here
; 360  : 
; 361  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 362  : }

	ret	80					; 00000050H
?SetConnection@CSmartTrackerClass@@UAGJHUSySalConnection@@@Z ENDP ; CSmartTrackerClass::SetConnection
_TEXT	ENDS
PUBLIC	?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z ; CSmartTrackerClass::GetConnection
;	COMDAT ?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z
_TEXT	SEGMENT
?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z PROC NEAR ; CSmartTrackerClass::GetConnection, COMDAT

; 366  : 	// TODO: Add your implementation code here
; 367  : 
; 368  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 369  : }

	ret	12					; 0000000cH
?GetConnection@CSmartTrackerClass@@UAGJHPAUSySalConnection@@@Z ENDP ; CSmartTrackerClass::GetConnection
_TEXT	ENDS
PUBLIC	?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z		; CSmartTrackerClass::GetIcon
EXTRN	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ:NEAR ; AfxGetModuleState
EXTRN	__imp__LoadImageA@24:NEAR
;	COMDAT xdata$x
; File C:\Program Files\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxwin1.inl
xdata$x	SEGMENT
$T80472	DD	019930520H
	DD	01H
	DD	FLAT:$T80475
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80475	DD	0ffffffffH
	DD	FLAT:$L80456
xdata$x	ENDS
;	COMDAT ?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z
_TEXT	SEGMENT
_n$ = 12
_pHICON$ = 16
__ctlState$ = -20
__$EHRec$ = -12
?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z PROC NEAR	; CSmartTrackerClass::GetIcon, COMDAT

; 372  : {

	push	-1
	push	$L80473
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8

; 373  : 	// TODO: Add your implementation code here
; 374  : 	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	call	?AfxGetStaticModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetStaticModuleState
	push	eax
	lea	ecx, DWORD PTR __ctlState$[esp+24]
	call	??0AFX_MAINTAIN_STATE2@@QAE@PAVAFX_MODULE_STATE@@@Z ; AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2

; 375  : 
; 376  : 	HANDLE HTemp = 0;
; 377  : 	switch (n)
; 378  : 	{

	mov	eax, DWORD PTR _n$[esp+16]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	sub	eax, 0
	je	SHORT $L78908
	dec	eax
	je	SHORT $L78912

; 384  : 
; 385  : 		default:	return E_INVALIDARG;

	mov	eax, DWORD PTR __ctlState$[esp+24]
	mov	ecx, DWORD PTR __ctlState$[esp+20]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, -2147024809			; 80070057H

; 389  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
$L78912:

; 380  : 					break;
; 381  : 
; 382  : 		case 1:		HTemp = LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(IDI_ICON64), IMAGE_ICON, 64, 64, LR_SHARED);

	call	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
	mov	eax, DWORD PTR [eax+12]
	push	32768					; 00008000H
	push	64					; 00000040H
	push	64					; 00000040H
	push	1
	push	202					; 000000caH

; 383  : 					break;

	jmp	SHORT $L80474
$L78908:

; 379  : 		case 0:		HTemp = LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(IDI_ICON32), IMAGE_ICON, 32, 32, LR_SHARED);

	call	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
	mov	eax, DWORD PTR [eax+12]
	push	32768					; 00008000H
	push	32					; 00000020H
	push	32					; 00000020H
	push	1
	push	201					; 000000c9H
$L80474:
	push	eax
	call	DWORD PTR __imp__LoadImageA@24

; 386  : 		};
; 387  : 	*pHICON = (HSySalHICON)HTemp;

	mov	edx, DWORD PTR _pHICON$[esp+16]

; 388  : 	return S_OK;	

	mov	ecx, DWORD PTR __ctlState$[esp+20]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR __ctlState$[esp+24]
	mov	DWORD PTR [eax+4], ecx

; 389  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	xor	eax, eax
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80456:
	lea	ecx, DWORD PTR __ctlState$[ebp]
	jmp	??1AFX_MAINTAIN_STATE2@@QAE@XZ		; AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2
$L80473:
	mov	eax, OFFSET FLAT:$T80472
	jmp	___CxxFrameHandler
text$x	ENDS
?GetIcon@CSmartTrackerClass@@UAGJHPAJ@Z ENDP		; CSmartTrackerClass::GetIcon
PUBLIC	??_C@_0BC@PBBD@Smart?5Tracker?58?41?$AA@	; `string'
PUBLIC	?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z	; CSmartTrackerClass::GetClassNameA
;	COMDAT ??_C@_0BC@PBBD@Smart?5Tracker?58?41?$AA@
; File D:\SySal2\SmartTracker8\SmartTrackerClass.cpp
_DATA	SEGMENT
??_C@_0BC@PBBD@Smart?5Tracker?58?41?$AA@ DB 'Smart Tracker 8.1', 00H ; `string'
_DATA	ENDS
;	COMDAT ?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z
_TEXT	SEGMENT
_name$ = 12
?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z PROC NEAR	; CSmartTrackerClass::GetClassNameA, COMDAT

; 393  : 	// TODO: Add your implementation code here
; 394  : 	
; 395  : 	strncpy(name, "Smart Tracker 8.1", SYSAL_MAX_CONN_NAME_LEN);

	mov	eax, DWORD PTR _name$[esp-4]
	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0BC@PBBD@Smart?5Tracker?58?41?$AA@ ; `string'
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 396  : 	return S_OK;

	xor	eax, eax

; 397  : }

	ret	8
?GetClassNameA@CSmartTrackerClass@@UAGJQAD@Z ENDP	; CSmartTrackerClass::GetClassNameA
_TEXT	ENDS
PUBLIC	?SyncExec@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::SyncExec
;	COMDAT ?SyncExec@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
?SyncExec@CSmartTrackerClass@@UAGJXZ PROC NEAR		; CSmartTrackerClass::SyncExec, COMDAT

; 401  : 	// TODO: Add your implementation code here
; 402  : 
; 403  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 404  : }

	ret	4
?SyncExec@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::SyncExec
_TEXT	ENDS
PUBLIC	?AsyncExec@CSmartTrackerClass@@UAGJJ@Z		; CSmartTrackerClass::AsyncExec
;	COMDAT ?AsyncExec@CSmartTrackerClass@@UAGJJ@Z
_TEXT	SEGMENT
_HNotifyStatusChangeEvent$ = 12
_this$ = 8
?AsyncExec@CSmartTrackerClass@@UAGJJ@Z PROC NEAR	; CSmartTrackerClass::AsyncExec, COMDAT

; 408  : 	// TODO: Add your implementation code here
; 409  : 
; 410  : 	HStatusChangeEvent = (HANDLE)HNotifyStatusChangeEvent;

	mov	eax, DWORD PTR _HNotifyStatusChangeEvent$[esp-4]
	mov	ecx, DWORD PTR _this$[esp-4]

; 411  : 	if (HStatusChangeEvent) SetEvent(HStatusChangeEvent);

	test	eax, eax
	mov	DWORD PTR [ecx+96], eax
	je	SHORT $L80484
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$L80484:

; 412  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 413  : }

	ret	8
?AsyncExec@CSmartTrackerClass@@UAGJJ@Z ENDP		; CSmartTrackerClass::AsyncExec
_TEXT	ENDS
PUBLIC	?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z	; CSmartTrackerClass::AsyncCheckStatus
;	COMDAT ?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z
_TEXT	SEGMENT
_pStatus$ = 12
?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z PROC NEAR ; CSmartTrackerClass::AsyncCheckStatus, COMDAT

; 417  : 	// TODO: Add your implementation code here
; 418  : 	
; 419  : 	*pStatus = SYSAL_ASYNC_STATUS_IDLE;

	mov	eax, DWORD PTR _pStatus$[esp-4]
	mov	DWORD PTR [eax], 0

; 420  : 	return S_OK;

	xor	eax, eax

; 421  : }

	ret	8
?AsyncCheckStatus@CSmartTrackerClass@@UAGJPAJ@Z ENDP	; CSmartTrackerClass::AsyncCheckStatus
_TEXT	ENDS
PUBLIC	?AsyncWait@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::AsyncWait
;	COMDAT ?AsyncWait@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
?AsyncWait@CSmartTrackerClass@@UAGJXZ PROC NEAR		; CSmartTrackerClass::AsyncWait, COMDAT

; 425  : 	// TODO: Add your implementation code here
; 426  : 
; 427  : 	return S_OK;

	xor	eax, eax

; 428  : }

	ret	4
?AsyncWait@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::AsyncWait
_TEXT	ENDS
PUBLIC	?AsyncPause@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::AsyncPause
;	COMDAT ?AsyncPause@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?AsyncPause@CSmartTrackerClass@@UAGJXZ PROC NEAR	; CSmartTrackerClass::AsyncPause, COMDAT

; 432  : 	// TODO: Add your implementation code here
; 433  : 
; 434  : 	if (HStatusChangeEvent) SetEvent(HStatusChangeEvent);

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+96]
	test	eax, eax
	je	SHORT $L80491
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$L80491:

; 435  : 	return S_OK;

	xor	eax, eax

; 436  : }

	ret	4
?AsyncPause@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::AsyncPause
_TEXT	ENDS
PUBLIC	?AsyncStop@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::AsyncStop
;	COMDAT ?AsyncStop@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?AsyncStop@CSmartTrackerClass@@UAGJXZ PROC NEAR		; CSmartTrackerClass::AsyncStop, COMDAT

; 439  : {

	push	esi

; 440  : 	// TODO: Add your implementation code here
; 441  : 
; 442  : 	if (HStatusChangeEvent) 

	mov	esi, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	je	SHORT $L80494

; 443  : 	{
; 444  : 		SetEvent(HStatusChangeEvent);

	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 445  : 		HStatusChangeEvent = 0;

	mov	DWORD PTR [esi+96], 0
$L80494:

; 446  : 		};
; 447  : 	return S_OK;

	xor	eax, eax
	pop	esi

; 448  : }

	ret	4
?AsyncStop@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::AsyncStop
_TEXT	ENDS
PUBLIC	?AsyncResume@CSmartTrackerClass@@UAGJXZ		; CSmartTrackerClass::AsyncResume
;	COMDAT ?AsyncResume@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?AsyncResume@CSmartTrackerClass@@UAGJXZ PROC NEAR	; CSmartTrackerClass::AsyncResume, COMDAT

; 452  : 	// TODO: Add your implementation code here
; 453  : 
; 454  : 	if (HStatusChangeEvent) SetEvent(HStatusChangeEvent);

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+96]
	test	eax, eax
	je	SHORT $L80497
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$L80497:

; 455  : 	return S_OK;

	xor	eax, eax

; 456  : }

	ret	4
?AsyncResume@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::AsyncResume
_TEXT	ENDS
PUBLIC	?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z		; CSmartTrackerClass::IsReady
;	COMDAT ?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z
_TEXT	SEGMENT
_pWrongConn$ = 12
_pRetCode$ = 16
?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z PROC NEAR	; CSmartTrackerClass::IsReady, COMDAT

; 460  : 	// TODO: Add your implementation code here
; 461  : 
; 462  : 	*pWrongConn = -1;

	mov	eax, DWORD PTR _pWrongConn$[esp-4]

; 463  : 	*pRetCode = SYSAL_READYSTATUS_READY;

	mov	ecx, DWORD PTR _pRetCode$[esp-4]
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [ecx], 0

; 464  : 	return S_OK;

	xor	eax, eax

; 465  : }

	ret	12					; 0000000cH
?IsReady@CSmartTrackerClass@@UAGJPAJ0@Z ENDP		; CSmartTrackerClass::IsReady
_TEXT	ENDS
PUBLIC	?StartFilling@CSmartTrackerClass@@UAGJXZ	; CSmartTrackerClass::StartFilling
EXTRN	__fltused:NEAR
;	COMDAT ?StartFilling@CSmartTrackerClass@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?StartFilling@CSmartTrackerClass@@UAGJXZ PROC NEAR	; CSmartTrackerClass::StartFilling, COMDAT

; 469  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 470  : 
; 471  : 	// TODO: Add your implementation code here
; 472  : 	if (!OkToRun) return S_FALSE;

	mov	eax, DWORD PTR _this$[esp-4]
	xor	ecx, ecx
	cmp	BYTE PTR [eax+1076], cl
	jne	SHORT $L78972
	mov	eax, 1

; 479  : }

	ret	4
$L78972:

; 473  : 	T.Layer = 0;

	mov	DWORD PTR [eax+992], ecx

; 474  : 	T.NumGrains = 0;

	mov	DWORD PTR [eax+988], ecx

; 475  : 	T.DispX = T.DispY = 0.0f;

	mov	DWORD PTR [eax+1000], ecx
	mov	DWORD PTR [eax+996], ecx

; 476  : 	T.ShadowSigmaMeasures = 0;

	mov	DWORD PTR [eax+1020], ecx

; 477  : 	T.ShadowSigmaXAccumulator = T.ShadowSigmaYAccumulator = 0.0f;

	mov	DWORD PTR [eax+1008], ecx
	mov	DWORD PTR [eax+1004], ecx

; 478  : 	return S_OK;

	xor	eax, eax

; 479  : }

	ret	4
?StartFilling@CSmartTrackerClass@@UAGJXZ ENDP		; CSmartTrackerClass::StartFilling
_TEXT	ENDS
PUBLIC	?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z ; CSmartTrackerClass::SetCameraSpec
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@8@3ffe8000000000000000
;	COMDAT __real@4@00000000000000000000
; File D:\SySal2\SmartTracker8\SmartTrackerClass.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT ?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z
_TEXT	SEGMENT
_Spec$ = 12
_this$ = 8
?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z PROC NEAR ; CSmartTrackerClass::SetCameraSpec, COMDAT

; 485  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 486  : 
; 487  : 	// TODO: Add your implementation code here
; 488  : 	if (Spec.PixelToMicronX != 0.f && Spec.PixelToMicronY != 0.f &&
; 489  : 		Spec.Height > 0 && Spec.Width > 0 && Spec.WinHeight > 0 && Spec.WinWidth > 0)

	fld	DWORD PTR _Spec$[esp+20]
	fcomp	DWORD PTR __real@4@00000000000000000000
	sub	esp, 8
	push	ebx
	push	ebp
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L78979
	fld	DWORD PTR _Spec$[esp+40]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L78979
	mov	eax, DWORD PTR _Spec$[esp+16]
	xor	ebx, ebx
	cmp	eax, ebx
	jbe	$L78979
	cmp	DWORD PTR _Spec$[esp+12], ebx
	jbe	$L78979
	cmp	DWORD PTR _Spec$[esp+32], ebx
	jbe	$L78979
	mov	ebp, DWORD PTR _Spec$[esp+28]
	cmp	ebp, ebx
	jbe	$L78979

; 490  : 	{
; 491  : 		CamSpec = Spec;
; 492  : 		T.PixelToMicronX = Spec.PixelToMicronX;
; 493  : 		T.PixelToMicronY = Spec.PixelToMicronY;
; 494  : 		if (T.PixelToMicronX > 0)

	fld	DWORD PTR _Spec$[esp+36]
	mov	edx, DWORD PTR _this$[esp+12]
	mov	eax, DWORD PTR _Spec$[esp+36]
	fcomp	DWORD PTR __real@4@00000000000000000000
	push	esi
	push	edi
	lea	edi, DWORD PTR [edx+104]
	mov	ecx, 8
	lea	esi, DWORD PTR _Spec$[esp+20]
	mov	DWORD PTR [edx+980], eax
	rep movsd
	fnstsw	ax
	mov	ecx, DWORD PTR _Spec$[esp+48]
	pop	edi
	test	ah, 65					; 00000041H

; 495  : 		{	T.Win.Xmin = Spec.OffX;

	mov	eax, DWORD PTR _Spec$[esp+24]
	mov	DWORD PTR [edx+984], ecx
	pop	esi
	jne	SHORT $L78980
	mov	DWORD PTR -8+[esp+16], eax
	mov	DWORD PTR -8+[esp+20], ebx
	fild	QWORD PTR -8+[esp+16]

; 496  : 			T.Win.Xmax = Spec.OffX + Spec.WinWidth;

	add	eax, ebp
	mov	DWORD PTR -8+[esp+20], ebx
	mov	DWORD PTR -8+[esp+16], eax
	fstp	DWORD PTR [edx+956]
	fild	QWORD PTR -8+[esp+16]
	fstp	DWORD PTR [edx+960]

; 497  : 			}
; 498  : 		else

	jmp	SHORT $L78981
$L78980:

; 499  : 		{	T.Win.Xmax = Spec.OffX;

	mov	DWORD PTR -8+[esp+16], eax
	mov	DWORD PTR -8+[esp+20], ebx
	fild	QWORD PTR -8+[esp+16]

; 500  : 			T.Win.Xmin = Spec.OffX + Spec.WinWidth;

	add	eax, ebp
	mov	DWORD PTR -8+[esp+20], ebx
	mov	DWORD PTR -8+[esp+16], eax
	fstp	DWORD PTR [edx+960]
	fild	QWORD PTR -8+[esp+16]
	fstp	DWORD PTR [edx+956]
$L78981:

; 501  : 			};
; 502  : 		if (T.PixelToMicronY > 0)

	fld	DWORD PTR _Spec$[esp+40]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H

; 503  : 		{  T.Win.Ymin = Spec.OffY;

	mov	eax, DWORD PTR _Spec$[esp+24]
	jne	SHORT $L78982

; 504  : 			T.Win.Ymax = Spec.OffY + Spec.WinHeight;

	mov	ecx, DWORD PTR _Spec$[esp+32]
	mov	DWORD PTR -8+[esp+16], eax
	mov	DWORD PTR -8+[esp+20], ebx
	add	eax, ecx
	fild	QWORD PTR -8+[esp+16]
	mov	DWORD PTR -8+[esp+16], eax
	mov	DWORD PTR -8+[esp+20], ebx
	fstp	DWORD PTR [edx+964]
	fild	QWORD PTR -8+[esp+16]
	fstp	DWORD PTR [edx+968]

; 505  : 			}
; 506  : 		else

	jmp	SHORT $L78983
$L78982:

; 507  : 		{	T.Win.Ymax = Spec.OffY;
; 508  : 			T.Win.Ymin = Spec.OffY + Spec.WinHeight;

	mov	ecx, DWORD PTR _Spec$[esp+32]
	mov	DWORD PTR -8+[esp+16], eax
	mov	DWORD PTR -8+[esp+20], ebx
	add	eax, ecx
	fild	QWORD PTR -8+[esp+16]
	mov	DWORD PTR -8+[esp+16], eax
	mov	DWORD PTR -8+[esp+20], ebx
	fstp	DWORD PTR [edx+968]
	fild	QWORD PTR -8+[esp+16]
	fstp	DWORD PTR [edx+964]
$L78983:

; 509  : 			};
; 510  : 		T.Win.Xmin *= T.PixelToMicronX;

	fld	DWORD PTR _Spec$[esp+36]
	fmul	DWORD PTR [edx+956]

; 511  : 		T.Win.Xmax *= T.PixelToMicronX;
; 512  : 		T.Win.Ymin *= T.PixelToMicronY;
; 513  : 		T.Win.Ymax *= T.PixelToMicronY;
; 514  : 		T.DxCell = ((T.Win.Xmax - T.Win.Xmin)/(float)(T.CellNumX));
; 515  : 		T.DyCell = ((T.Win.Ymax - T.Win.Ymin)/(float)(T.CellNumY));
; 516  : 		T.ViewCenterX = Spec.Width * Spec.PixelToMicronX * 0.5;

	mov	eax, DWORD PTR _Spec$[esp+12]
	mov	DWORD PTR -8+[esp+20], ebx

; 517  : 		T.ViewCenterY = Spec.Height * Spec.PixelToMicronY * 0.5;

	mov	ecx, DWORD PTR _Spec$[esp+16]
	fst	DWORD PTR [edx+956]
	fld	DWORD PTR _Spec$[esp+36]
	fmul	DWORD PTR [edx+960]
	fst	DWORD PTR [edx+960]
	fld	DWORD PTR _Spec$[esp+40]
	fmul	DWORD PTR [edx+964]
	fst	DWORD PTR -8+[esp+16]
	fstp	DWORD PTR [edx+964]
	fld	DWORD PTR _Spec$[esp+40]
	fmul	DWORD PTR [edx+968]
	fst	DWORD PTR 8+[esp+12]
	fstp	DWORD PTR [edx+968]
	fsub	ST(0), ST(1)
	fidiv	DWORD PTR [edx+148]
	fstp	DWORD PTR [edx+972]
	fstp	ST(0)
	fld	DWORD PTR 8+[esp+12]
	fsub	DWORD PTR -8+[esp+16]
	fidiv	DWORD PTR [edx+152]
	mov	DWORD PTR -8+[esp+16], eax
	fstp	DWORD PTR [edx+976]
	fild	QWORD PTR -8+[esp+16]
	mov	DWORD PTR -8+[esp+16], ecx
	mov	DWORD PTR -8+[esp+20], ebx

; 518  : 		if (!ResetDeltaHisto()) return S_FALSE;

	mov	ecx, edx
	fmul	DWORD PTR _Spec$[esp+36]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fstp	DWORD PTR [edx+1068]
	fild	QWORD PTR -8+[esp+16]
	fmul	DWORD PTR _Spec$[esp+40]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fstp	DWORD PTR [edx+1072]
	call	?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ ; CSmartTrackerClass::ResetDeltaHisto
	neg	al
	sbb	eax, eax
	pop	ebp
	inc	eax
	pop	ebx

; 522  : }

	add	esp, 8
	ret	36					; 00000024H
$L78979:
	pop	ebp

; 519  : 		return S_OK;
; 520  : 		};
; 521  : 	return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	pop	ebx

; 522  : }

	add	esp, 8
	ret	36					; 00000024H
?SetCameraSpec@CSmartTrackerClass@@UAGJUCameraSpec@@@Z ENDP ; CSmartTrackerClass::SetCameraSpec
_TEXT	ENDS
PUBLIC	?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z ; CSmartTrackerClass::GetCameraSpec
;	COMDAT ?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z
_TEXT	SEGMENT
_pSpec$ = 12
_this$ = 8
?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z PROC NEAR ; CSmartTrackerClass::GetCameraSpec, COMDAT

; 526  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 527  : 
; 528  : 	// TODO: Add your implementation code here
; 529  : 	*pSpec = CamSpec;

	mov	eax, DWORD PTR _this$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pSpec$[esp+4]
	lea	esi, DWORD PTR [eax+104]
	mov	ecx, 8
	rep movsd
	pop	edi

; 530  : 	return S_OK;

	xor	eax, eax
	pop	esi

; 531  : }

	ret	8
?GetCameraSpec@CSmartTrackerClass@@UAGJPAUCameraSpec@@@Z ENDP ; CSmartTrackerClass::GetCameraSpec
_TEXT	ENDS
PUBLIC	?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z ; CSmartTrackerClass::PutClusters
PUBLIC	??_C@_0L@GFNK@Debug?5Info?$AA@			; `string'
PUBLIC	??_C@_09IOG@Here?5?9?5A?$CB?$AA@		; `string'
PUBLIC	??_C@_09DDBJ@Here?5?9?5B?$CB?$AA@		; `string'
PUBLIC	??_C@_09CFLD@Here?5?9?5C?$CB?$AA@		; `string'
PUBLIC	__real@8@00000000000000000000
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	__real@4@3ffe8000000000000000
EXTRN	__imp__MessageBoxA@16:NEAR
EXTRN	__imp__floor:NEAR
EXTRN	__ftol:NEAR
;	COMDAT ??_C@_0L@GFNK@Debug?5Info?$AA@
; File D:\SySal2\SmartTracker8\SmartTrackerClass.cpp
_DATA	SEGMENT
??_C@_0L@GFNK@Debug?5Info?$AA@ DB 'Debug Info', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09IOG@Here?5?9?5A?$CB?$AA@
_DATA	SEGMENT
??_C@_09IOG@Here?5?9?5A?$CB?$AA@ DB 'Here - A!', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DDBJ@Here?5?9?5B?$CB?$AA@
_DATA	SEGMENT
??_C@_09DDBJ@Here?5?9?5B?$CB?$AA@ DB 'Here - B!', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09CFLD@Here?5?9?5C?$CB?$AA@
_DATA	SEGMENT
??_C@_09CFLD@Here?5?9?5C?$CB?$AA@ DB 'Here - C!', 00H	; `string'
_DATA	ENDS
;	COMDAT __real@8@00000000000000000000
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT __real@4@3ffe8000000000000000
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT ?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z
_TEXT	SEGMENT
_pClusters$ = 12
_CountOfClusters$ = 16
_Z$ = 20
_this$ = 8
_Nc$ = -196
_Icell$ = -200
_PCell$ = -196
_PGrainEnd$ = -212
_PixMin$ = -24
_PixMax$ = -20
_PixelToMicronX$ = -88
_PixelToMicronY$ = -80
_CellsInLayer$ = -188
_CellSpace$ = -92
_Layer$ = -120
_CellOverflow$ = -36
_CurrentGCounter$ = -212
_MaxGrains$ = -52
_CurrDispX$ = -96
_CurrDispY$ = -100
_CurrDispSigmaX$ = -116
_CurrDispSigmaY$ = -124
_CX$ = -112
_CY$ = -128
_DX$ = -216
_DY$ = -152
_L0X$ = -48
_L1X$ = -32
_L0Y$ = -136
_L1Y$ = -72
_AvgLX$ = -16
_AvgLY$ = -8
_pX$ = -60
_pY$ = -104
_pDX$ = -56
_pDY$ = -148
_pReplicas$ = -164
_ReplicaCount$ = -200
_ReplicaRadius$ = -108
_DeltaBins$ = -180
_MaxHisto$ = -212
_rv$79085 = -216
_SumXPx$79089 = -88
_DenX$79090 = -136
_SumPy$79091 = -176
_SumY$79092 = -80
_SumY2$79093 = -144
_SumYPy$79094 = -160
_uy$79133 = -208
_uy$79137 = -208
_uy$79152 = -208
_Icl$80516 = -184
$T80520 = -184
$T80521 = -216
$T80529 = -148
$T80530 = -164
?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z PROC NEAR ; CSmartTrackerClass::PutClusters, COMDAT

; 534  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi

; 535  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 536  : 
; 537  : 	// TODO: Add your implementation code here
; 538  : 	int Nc;
; 539  : 	int Icell;
; 540  : 	IntCluster *PClus;
; 541  : 	Cell *PCell;
; 542  : 	IntGrain *PGrain, *PGrainEnd;
; 543  : 	int PixMin = T.PixMin;

	mov	esi, DWORD PTR _this$[ebp]
	push	edi

; 544  : 	int PixMax = T.PixMax;
; 545  : 	float PixelToMicronX = T.PixelToMicronX;
; 546  : 	float PixelToMicronY = T.PixelToMicronY;
; 547  : 	float PixelToMicronXY = fabs(PixelToMicronX * PixelToMicronY);
; 548  : 	float PixelToMicronX3Y = PixelToMicronXY * PixelToMicronX * PixelToMicronX;
; 549  : 	float PixelToMicronY3X = PixelToMicronXY * PixelToMicronY * PixelToMicronY;
; 550  : 	float PixelToMicronX2Y2 = PixelToMicronXY * PixelToMicronXY;
; 551  : 	int CellsInLayer = T.CellsInLayer;
; 552  : 	Cell *CellSpace = T.CellSpace;
; 553  : 	int Layer = T.Layer;
; 554  : 	int CellOverflow = T.CellOverflow;
; 555  : 	int CurrentGCounter = T.NumGrains;
; 556  : 	int MaxGrains = T.MaxGrains;
; 557  : 	float CurrDispX = 0.0f;

	mov	DWORD PTR _CurrDispX$[esp+232], 0

; 558  : 	float CurrDispY = 0.0f;

	mov	DWORD PTR _CurrDispY$[esp+232], 0
	mov	ecx, DWORD PTR [esi+160]
	mov	eax, DWORD PTR [esi+156]
	mov	DWORD PTR _PixMax$[esp+232], ecx
	mov	ecx, DWORD PTR [esi+144]
	mov	DWORD PTR _CellOverflow$[esp+232], ecx
	mov	ecx, DWORD PTR [esi+988]
	mov	DWORD PTR _CurrentGCounter$[esp+232], ecx
	mov	ecx, DWORD PTR [esi+136]
	mov	DWORD PTR _MaxGrains$[esp+232], ecx

; 559  : 	float CurrDispSigmaX = 0.0f;
; 560  : 	float CurrDispSigmaY = 0.0f;
; 561  : 	float DispX = T.DispX;
; 562  : 	float DispY = T.DispY;
; 563  : 	float CX, CY, DX, DY;
; 564  : 	double L0X = 0.0, L1X = 0.0, L0Y = 0.0, L1Y = 0.0;
; 565  : 	double AvgLX = 0.0, AvgLY = 0.0;
; 566  : 	float *pX = T.pX;

	mov	ecx, DWORD PTR [esi+1048]
	mov	DWORD PTR _pX$[esp+232], ecx

; 567  : 	float *pY = T.pY;
; 568  : 	float *pDX = T.pDX;

	mov	ecx, DWORD PTR [esi+1056]
	mov	edx, DWORD PTR [esi+980]
	mov	DWORD PTR _pDX$[esp+232], ecx

; 569  : 	float *pDY = T.pDY;

	mov	ecx, DWORD PTR [esi+1060]
	mov	ebx, DWORD PTR [esi+992]
	mov	edi, DWORD PTR [esi+1052]
	mov	DWORD PTR _pDY$[esp+232], ecx

; 570  : 	IntCluster **pReplicas = T.pReplicas;

	mov	ecx, DWORD PTR [esi+1064]
	mov	DWORD PTR _PixMin$[esp+232], eax
	mov	eax, DWORD PTR [esi+984]
	mov	DWORD PTR _pReplicas$[esp+232], ecx

; 571  : 	int ReplicaCount = 0;
; 572  : 	int DividerCount;
; 573  : 	float ReplicaRadius = T.ReplicaRadius;

	mov	ecx, DWORD PTR [esi+908]
	mov	DWORD PTR _PixelToMicronX$[esp+232], edx
	mov	edx, DWORD PTR [esi+952]
	mov	DWORD PTR _ReplicaRadius$[esp+232], ecx

; 574  : 
; 575  : 	if (!OkToRun) return S_FALSE;

	mov	cl, BYTE PTR [esi+1076]
	mov	DWORD PTR _PixelToMicronY$[esp+232], eax
	mov	eax, DWORD PTR [esi+948]
	mov	DWORD PTR _CellsInLayer$[esp+232], edx
	test	cl, cl
	mov	DWORD PTR _CellSpace$[esp+232], eax
	mov	DWORD PTR _Layer$[esp+232], ebx
	mov	DWORD PTR _CurrDispSigmaX$[esp+232], 0
	mov	DWORD PTR _CurrDispSigmaY$[esp+232], 0
	mov	DWORD PTR _L0X$[esp+232], 0
	mov	DWORD PTR _L0X$[esp+236], 0
	mov	DWORD PTR _L1X$[esp+232], 0
	mov	DWORD PTR _L1X$[esp+236], 0
	mov	DWORD PTR _L0Y$[esp+232], 0
	mov	DWORD PTR _L0Y$[esp+236], 0
	mov	DWORD PTR _L1Y$[esp+232], 0
	mov	DWORD PTR _L1Y$[esp+236], 0
	mov	DWORD PTR _AvgLX$[esp+232], 0
	mov	DWORD PTR _AvgLX$[esp+236], 0
	mov	DWORD PTR _AvgLY$[esp+232], 0
	mov	DWORD PTR _AvgLY$[esp+236], 0
	mov	DWORD PTR _pY$[esp+232], edi
	mov	DWORD PTR _ReplicaCount$[esp+232], 0
	jne	SHORT $L79045
	mov	eax, 1

; 869  : 	return S_OK;
; 870  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L79045:

; 576  : 
; 577  : 	if (Layer >= T.LayerNum) return S_FALSE;

	cmp	ebx, DWORD PTR [esi+140]
	jl	SHORT $L79047
	mov	eax, 1

; 869  : 	return S_OK;
; 870  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L79047:

; 578  : 	T.ZLayer[Layer] = Z;

	mov	ecx, DWORD PTR [esi+940]
	fld	DWORD PTR _Z$[ebp]

; 579  : 	for (Icell = 0; Icell < CellsInLayer; Icell++)

	test	edx, edx
	fstp	DWORD PTR [ecx+ebx*4]
	jle	SHORT $L79051
	mov	ecx, ebx
	imul	ecx, edx
	lea	eax, DWORD PTR [eax+ecx*8]
$L79049:

; 580  : 	{	((Cell *)CellSpace)[Layer*CellsInLayer+Icell].FirstC = 0;

	mov	DWORD PTR [eax], 0

; 581  : 		((Cell *)CellSpace)[Layer*CellsInLayer+Icell].Free = 0;

	mov	DWORD PTR [eax+4], 0
	add	eax, 8
	dec	edx
	jne	SHORT $L79049
$L79051:

; 582  : 		};
; 583  : 
; 584  : 	static int run = 0;
; 585  : 	run++;

	mov	edx, DWORD PTR _?run@?7??PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z@4HA

; 586  : 
; 587  : 	int DeltaBins = T.DeltaBinsX * T.DeltaBinsY;
; 588  : 	int MaxHisto, MaxBin;
; 589  : 	for (Nc = 0; Nc < DeltaBins; T.pDeltaHisto2d[Nc++] = 0);

	xor	eax, eax
	inc	edx
	mov	DWORD PTR _?run@?7??PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z@4HA, edx
	mov	edx, DWORD PTR [esi+1032]
	imul	edx, DWORD PTR [esi+1036]
	test	edx, edx
	mov	DWORD PTR _DeltaBins$[esp+232], edx
	jle	SHORT $L79061
$L79059:
	mov	ecx, DWORD PTR [esi+1040]
	inc	eax
	cmp	eax, edx
	mov	DWORD PTR [ecx+eax*4-4], 0
	jl	SHORT $L79059
$L79061:

; 590  : 
; 591  : /*	FILE *fsmtg = fopen("c:\\acq\\smt8g.txt", "a+t");
; 592  : 	FILE *fsmtd = fopen("c:\\acq\\smt8d.txt", "a+t");
; 593  : */
; 594  : 
; 595  : 	if (T.ReplicaRadius > 0.0f && Layer > 0)

	fld	DWORD PTR [esi+908]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L79062
	test	ebx, ebx
	jle	$L79062

; 596  : 	{
; 597  : 		for (Nc = DividerCount = 0; (Nc < CountOfClusters) && (CurrentGCounter < MaxGrains); Nc++)

	mov	eax, DWORD PTR _CountOfClusters$[ebp]
	mov	DWORD PTR _Nc$[esp+232], 0
	test	eax, eax
	jle	$L79065
	mov	eax, DWORD PTR _pClusters$[ebp]
	lea	ebx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _pX$[esp+232]
	sub	eax, edi
	mov	DWORD PTR -192+[esp+232], ebx
	mov	DWORD PTR -176+[esp+232], eax
	mov	eax, DWORD PTR _pDX$[esp+232]
	sub	eax, edi
	mov	DWORD PTR -160+[esp+232], eax
	mov	eax, DWORD PTR _pDY$[esp+232]
	sub	eax, edi
	mov	DWORD PTR -144+[esp+232], eax
	mov	eax, DWORD PTR _pReplicas$[esp+232]
	sub	eax, edi
	mov	DWORD PTR -208+[esp+232], eax
$L79063:
	mov	ecx, DWORD PTR _CurrentGCounter$[esp+232]
	mov	eax, DWORD PTR _MaxGrains$[esp+232]
	cmp	ecx, eax
	jge	$L79065

; 598  : 		{	
; 599  : 			PClus = (IntCluster *)(pClusters + Nc);
; 600  : 			if ((PClus->Area >= PixMin) && (PClus->Area <= PixMax))

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR _PixMin$[esp+232]
	lea	edx, DWORD PTR [ebx-4]
	cmp	eax, ecx
	mov	DWORD PTR -152+[esp+232], edx
	jl	$L79064
	cmp	eax, DWORD PTR _PixMax$[esp+232]
	jg	$L79064

; 601  : 			{	
; 602  : 				Icell = GetCell(PClus->X *= PixelToMicronX, PClus->Y *= PixelToMicronY);

	fld	DWORD PTR _PixelToMicronY$[esp+232]
	fmul	DWORD PTR [ebx]
	mov	eax, edx
	fst	DWORD PTR [ebx]
	fstp	DWORD PTR $T80521[esp+232]
	fld	DWORD PTR _PixelToMicronX$[esp+232]
	fmul	DWORD PTR [eax]
	fst	DWORD PTR [eax]
	fst	DWORD PTR $T80520[esp+232]
	fcomp	DWORD PTR [esi+956]
	fnstsw	ax
	test	ah, 1
	jne	$L79064
	fld	DWORD PTR $T80520[esp+232]
	fcomp	DWORD PTR [esi+960]
	fnstsw	ax
	test	ah, 1
	je	$L79064
	fld	DWORD PTR $T80521[esp+232]
	fcomp	DWORD PTR [esi+964]
	fnstsw	ax
	test	ah, 1
	jne	$L79064
	fld	DWORD PTR $T80521[esp+232]
	fcomp	DWORD PTR [esi+968]
	fnstsw	ax
	test	ah, 1
	je	$L79064
	fld	DWORD PTR $T80521[esp+232]
	fsub	DWORD PTR [esi+964]
	fdiv	DWORD PTR [esi+976]
	call	__ftol
	imul	eax, DWORD PTR [esi+148]
	fld	DWORD PTR $T80520[esp+232]
	fsub	DWORD PTR [esi+956]
	fdiv	DWORD PTR [esi+972]
	mov	DWORD PTR -216+[esp+232], eax
	call	__ftol
	mov	ecx, DWORD PTR -216+[esp+232]
	add	ecx, eax
	mov	DWORD PTR _Icl$80516[esp+232], ecx
	js	$L79064
	mov	eax, ecx
	mov	ecx, DWORD PTR [esi+952]
	cmp	eax, ecx
	jge	$L79064

; 603  : 				if (Icell >= 0)
; 604  : 				{	
; 605  : 					PCell = (Cell *)(CellSpace+(Layer*CellsInLayer+Icell));

	mov	ecx, DWORD PTR _Layer$[esp+232]
	mov	edx, DWORD PTR _CellsInLayer$[esp+232]
	imul	ecx, edx
	add	ecx, eax
	mov	eax, DWORD PTR _CellSpace$[esp+232]

; 606  : 					PCell->Free++;
; 607  : 					CurrentGCounter++;
; 608  : 					PClus->NextFree = PCell->FirstC;
; 609  : 					PCell->FirstC = PClus;
; 610  : 					PCell -= CellsInLayer;

	neg	edx
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR [eax+4]
	inc	ecx
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _CurrentGCounter$[esp+232]
	inc	ecx
	mov	DWORD PTR _CurrentGCounter$[esp+232], ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebx+8], ecx
	mov	ecx, DWORD PTR -152+[esp+232]
	mov	DWORD PTR [eax], ecx
	lea	eax, DWORD PTR [eax+edx*8]

; 611  : 					CX = PClus->X/* + DispX*/;

	mov	edx, DWORD PTR [ecx]

; 612  : 					CY = PClus->Y/* + DispY*/;

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _CY$[esp+232], ecx

; 613  : 					IntGrain *pRep = PCell->FirstG;

	mov	ecx, DWORD PTR [eax]

; 614  : 					IntGrain *pEnd = pRep + PCell->Free;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _CX$[esp+232], edx
	lea	edx, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]

; 615  : 					while (pRep < pEnd)

	cmp	ecx, edx
	jae	$L79064
$L79073:

; 616  : 					{
; 617  : 						if (fabs(DX = (pRep->Xcm - CX)) < ReplicaRadius && fabs(DY = (pRep->Ycm - CY)) < ReplicaRadius) 

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _CX$[esp+232]
	fst	DWORD PTR _DX$[esp+232]
	fabs
	fld	DWORD PTR _ReplicaRadius$[esp+232]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79075
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _CY$[esp+232]
	fld	ST(0)
	fabs
	fld	DWORD PTR _ReplicaRadius$[esp+232]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L80544
	fstp	ST(0)
$L79075:

; 633  : 							break;
; 634  : 							}
; 635  : 						pRep++;

	add	ecx, 20					; 00000014H
	cmp	ecx, edx
	jb	SHORT $L79073

; 616  : 					{
; 617  : 						if (fabs(DX = (pRep->Xcm - CX)) < ReplicaRadius && fabs(DY = (pRep->Ycm - CY)) < ReplicaRadius) 

	jmp	$L79064
$L80544:

; 618  : 						{
; 619  : 							pX[ReplicaCount] = CX;

	fld	DWORD PTR _CX$[esp+232]
	mov	eax, DWORD PTR -176+[esp+232]

; 620  : 							pY[ReplicaCount] = CY;

	mov	ecx, DWORD PTR _CY$[esp+232]

; 621  : 							pDX[ReplicaCount] = DX;

	mov	edx, DWORD PTR -160+[esp+232]

; 622  : 							pDY[ReplicaCount] = DY;
; 623  : 							pReplicas[ReplicaCount] = PClus;
; 624  : 							CurrDispX += DX;
; 625  : 							CurrDispSigmaX += DX * DX;
; 626  : 							CurrDispY += DY;
; 627  : 							CurrDispSigmaY += DY * DY;
; 628  : 							T.pDeltaHisto2d[((int)floor(DY / T.DeltaDY + 0.5) + T.DeltaBinsY / 2) * T.DeltaBinsX + ((int)floor(DX / T.DeltaDX + 0.5) + T.DeltaBinsX / 2)]++;

	sub	esp, 8
	fstp	DWORD PTR [eax+edi]
	fld	DWORD PTR _DX$[esp+240]
	mov	eax, DWORD PTR -144+[esp+240]
	mov	DWORD PTR [edi], ecx
	fstp	DWORD PTR [edx+edi]
	mov	edx, DWORD PTR -208+[esp+240]
	mov	ecx, DWORD PTR -152+[esp+240]
	fld	ST(0)
	fstp	DWORD PTR [eax+edi]
	fld	DWORD PTR _DX$[esp+240]
	fadd	DWORD PTR _CurrDispX$[esp+240]
	mov	DWORD PTR [edx+edi], ecx
	fstp	DWORD PTR _CurrDispX$[esp+240]
	fld	DWORD PTR _DX$[esp+240]
	fmul	DWORD PTR _DX$[esp+240]
	fadd	DWORD PTR _CurrDispSigmaX$[esp+240]
	fstp	DWORD PTR _CurrDispSigmaX$[esp+240]
	fld	ST(0)
	fadd	DWORD PTR _CurrDispY$[esp+240]
	fstp	DWORD PTR _CurrDispY$[esp+240]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fadd	DWORD PTR _CurrDispSigmaY$[esp+240]
	fstp	DWORD PTR _CurrDispSigmaY$[esp+240]
	fdiv	DWORD PTR [esi+1028]
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	call	__ftol
	fld	DWORD PTR _DX$[esp+240]
	fdiv	DWORD PTR [esi+1024]
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+1036]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ebx, eax
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	imul	ebx, DWORD PTR [esi+1032]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	add	esp, 8
	call	__ftol
	add	ebx, eax
	mov	eax, DWORD PTR [esi+1032]
	cdq
	sub	eax, edx

; 629  : /*							
; 630  : 							fprintf(fsmtg, "%d %d %d %f %f %f %f\n", run, Layer, ReplicaCount, PClus->X, PClus->Y, DX, DY);
; 631  : */							
; 632  : 							ReplicaCount++;								

	mov	ecx, DWORD PTR _ReplicaCount$[esp+232]
	sar	eax, 1
	add	ebx, eax
	mov	eax, DWORD PTR [esi+1040]
	mov	edx, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR -192+[esp+232]
	inc	edx
	inc	ecx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR _ReplicaCount$[esp+232], ecx
	add	edi, 4
$L79064:
	mov	eax, DWORD PTR _Nc$[esp+232]
	mov	ecx, DWORD PTR _CountOfClusters$[ebp]
	mov	edx, DWORD PTR _DeltaBins$[esp+232]
	inc	eax
	add	ebx, 40					; 00000028H
	cmp	eax, ecx
	mov	DWORD PTR _Nc$[esp+232], eax
	mov	DWORD PTR -192+[esp+232], ebx
	jl	$L79063
$L79065:

; 636  : 						}						
; 637  : 					};
; 638  : 				};
; 639  : 			};
; 640  : 		MaxBin = DeltaBins / 2 + T.DeltaBinsX / 2;
; 641  : 		for (Nc = MaxHisto = MaxBin = 0; Nc < DeltaBins; Nc++)

	xor	edi, edi
	xor	ecx, ecx
	cmp	edx, edi
	mov	DWORD PTR _MaxHisto$[esp+232], edi
	jle	$L79114

; 642  : 			if (T.pDeltaHisto2d[Nc] > MaxHisto)

	mov	eax, DWORD PTR [esi+1040]
	mov	ebx, eax
$L79078:
	mov	edx, DWORD PTR [ebx]
	cmp	edx, DWORD PTR _MaxHisto$[esp+232]
	jle	SHORT $L79079

; 643  : 			{
; 644  : 				MaxHisto = T.pDeltaHisto2d[Nc];

	mov	DWORD PTR _MaxHisto$[esp+232], edx

; 645  : 				MaxBin = Nc;

	mov	ecx, edi
$L79079:
	mov	edx, DWORD PTR _DeltaBins$[esp+232]
	inc	edi
	add	ebx, 4
	cmp	edi, edx
	jl	SHORT $L79078

; 646  : 				};
; 647  : 
; 648  : 		if (MaxHisto)

	mov	edx, DWORD PTR _MaxHisto$[esp+232]
	test	edx, edx
	je	$L79114

; 649  : 			if ((MaxHisto = T.pDeltaHisto2d[MaxBin] + T.pDeltaHisto2d[MaxBin + 1] + T.pDeltaHisto2d[MaxBin - 1] + 
; 650  : 				T.pDeltaHisto2d[MaxBin + T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin + 1 + T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin - 1 + T.DeltaBinsX] + 
; 651  : 				T.pDeltaHisto2d[MaxBin - T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin + 1 - T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin - 1 - T.DeltaBinsX]) >= T.MinReplicas)

	mov	edi, DWORD PTR [esi+1032]
	mov	edx, ecx
	sub	edx, edi
	lea	ebx, DWORD PTR [edi+ecx]
	mov	DWORD PTR -192+[esp+232], edx
	mov	edx, DWORD PTR [eax+edx*4-4]
	mov	ebx, DWORD PTR [eax+ebx*4-4]
	mov	DWORD PTR -176+[esp+232], edx
	add	edx, ebx
	mov	DWORD PTR -160+[esp+232], ebx
	mov	DWORD PTR -116+[esp+232], edx
	mov	edx, DWORD PTR -192+[esp+232]
	mov	edx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR -124+[esp+232], edx
	lea	edx, DWORD PTR [edi+ecx]
	mov	ebx, DWORD PTR [eax+edx*4+4]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR -128+[esp+232], edx
	mov	edx, DWORD PTR -192+[esp+232]
	mov	DWORD PTR -144+[esp+232], ebx
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR -192+[esp+232], edx
	mov	edx, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR -180+[esp+232], edx
	mov	edx, DWORD PTR [eax+ecx*4+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR -108+[esp+232], edx
	mov	DWORD PTR -112+[esp+232], eax
	add	eax, edx
	mov	edx, DWORD PTR -180+[esp+232]
	add	eax, edx
	mov	edx, DWORD PTR -192+[esp+232]
	add	eax, edx
	mov	edx, DWORD PTR -128+[esp+232]
	add	eax, edx
	mov	edx, DWORD PTR -124+[esp+232]
	add	eax, ebx
	mov	ebx, DWORD PTR -116+[esp+232]
	add	eax, edx
	mov	edx, DWORD PTR [esi+912]
	add	eax, ebx
	cmp	eax, edx
	mov	DWORD PTR _MaxHisto$[esp+232], eax
	jl	$L79114

; 652  : 		{
; 653  : 			DX = ((MaxBin % T.DeltaBinsX) - T.DeltaBinsX / 2) * T.DeltaDX;

	mov	eax, ecx
	cdq
	idiv	edi
	mov	eax, edi
	mov	ebx, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ebx, eax

; 654  : 			DY = ((MaxBin / T.DeltaBinsX) - T.DeltaBinsY / 2) * T.DeltaDY;

	mov	eax, ecx
	cdq
	idiv	edi
	mov	DWORD PTR -208+[esp+232], ebx

; 655  : 			CurrDispX = (DX * (T.pDeltaHisto2d[MaxBin] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX]) + 
; 656  : 				(DX + T.DeltaDX) * (T.pDeltaHisto2d[MaxBin + 1] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX + 1] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX + 1]) + 
; 657  : 				(DX - T.DeltaDX) * (T.pDeltaHisto2d[MaxBin - 1] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX - 1] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX - 1])) / MaxHisto;

	mov	edi, DWORD PTR -180+[esp+232]
	fild	DWORD PTR -208+[esp+232]
	fmul	DWORD PTR [esi+1024]
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+1036]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR -108+[esp+232]
	sar	eax, 1
	sub	ecx, eax
	mov	eax, DWORD PTR -124+[esp+232]
	mov	DWORD PTR -208+[esp+232], ecx
	mov	ecx, DWORD PTR -144+[esp+232]
	fild	DWORD PTR -208+[esp+232]
	add	edx, ecx
	add	edx, eax
	fmul	DWORD PTR [esi+1028]
	mov	DWORD PTR -208+[esp+232], edx
	mov	edx, DWORD PTR -116+[esp+232]
	add	edi, edx
	mov	edx, DWORD PTR -112+[esp+232]
	fstp	DWORD PTR _DY$[esp+232]
	fild	DWORD PTR _MaxHisto$[esp+232]
	fstp	DWORD PTR -184+[esp+232]
	fild	DWORD PTR -208+[esp+232]
	fld	ST(1)
	fadd	DWORD PTR [esi+1024]
	mov	DWORD PTR -208+[esp+232], edi
	mov	edi, DWORD PTR -192+[esp+232]
	fmulp	ST(1), ST(0)
	fild	DWORD PTR -208+[esp+232]
	fld	ST(2)
	fsub	DWORD PTR [esi+1024]
	lea	ebx, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR -128+[esp+232]
	add	ebx, edx

; 658  : 
; 659  : 			CurrDispY = (DY * (T.pDeltaHisto2d[MaxBin] + T.pDeltaHisto2d[MaxBin + 1] + T.pDeltaHisto2d[MaxBin - 1]) + 
; 660  : 				(DY + T.DeltaDY) * (T.pDeltaHisto2d[MaxBin + T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX + 1] + T.pDeltaHisto2d[MaxBin + T.DeltaBinsX - 1]) + 
; 661  : 				(DY - T.DeltaDY) * (T.pDeltaHisto2d[MaxBin - T.DeltaBinsX] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX + 1] + T.pDeltaHisto2d[MaxBin - T.DeltaBinsX - 1])) / MaxHisto;

	add	edx, ecx
	fmulp	ST(1), ST(0)
	mov	DWORD PTR -208+[esp+232], ebx
	mov	ebx, DWORD PTR -160+[esp+232]
	add	edx, ebx
	add	edi, eax
	faddp	ST(1), ST(0)
	fild	DWORD PTR -208+[esp+232]
	mov	DWORD PTR -208+[esp+232], edx
	mov	edx, DWORD PTR -176+[esp+232]
	add	edi, edx
	mov	eax, DWORD PTR -112+[esp+232]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR -184+[esp+232]
	fstp	DWORD PTR _CurrDispX$[esp+232]
	fstp	ST(0)
	fild	DWORD PTR -208+[esp+232]
	fld	DWORD PTR _DY$[esp+232]
	fadd	DWORD PTR [esi+1028]
	mov	DWORD PTR -208+[esp+232], edi
	fmulp	ST(1), ST(0)
	fild	DWORD PTR -208+[esp+232]
	fld	DWORD PTR _DY$[esp+232]
	fsub	DWORD PTR [esi+1028]
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR -108+[esp+232]

; 662  : 
; 663  : 			int rsp, rv;
; 664  : 			double SumPx = 0.0, SumX = 0.0, SumX2 = 0.0, SumXPx = 0.0, DenX = 0.0;
; 665  : 			double SumPy = 0.0, SumY = 0.0, SumY2 = 0.0, SumYPy = 0.0, DenY = 0.0;

	mov	DWORD PTR _SumPy$79091[esp+232], 0
	add	eax, ecx
	mov	ecx, DWORD PTR -180+[esp+232]
	add	eax, ecx
	mov	DWORD PTR _SumPy$79091[esp+236], 0
	mov	DWORD PTR -208+[esp+232], eax

; 666  : 			double V, W;
; 667  : 			for (rsp = rv = 0; rsp < ReplicaCount; rsp++)

	mov	eax, DWORD PTR _ReplicaCount$[esp+232]
	fild	DWORD PTR -208+[esp+232]
	test	eax, eax
	mov	DWORD PTR _SumY2$79093[esp+232], 0
	mov	DWORD PTR _SumY2$79093[esp+236], 0
	fmul	DWORD PTR _DY$[esp+232]
	mov	DWORD PTR _SumYPy$79094[esp+232], 0
	mov	DWORD PTR _SumYPy$79094[esp+236], 0
	mov	DWORD PTR _rv$79085[esp+232], 0
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR -184+[esp+232]
	fstp	DWORD PTR _CurrDispY$[esp+232]
	fld	QWORD PTR __real@8@00000000000000000000
	fld	QWORD PTR __real@8@00000000000000000000
	fld	QWORD PTR __real@8@00000000000000000000
	fld	QWORD PTR __real@8@00000000000000000000
	fst	QWORD PTR _SumXPx$79089[esp+232]
	fld	QWORD PTR __real@8@00000000000000000000
	fst	QWORD PTR _SumY$79092[esp+232]
	jle	$L80566
	mov	ecx, DWORD PTR _pDX$[esp+232]
	mov	eax, DWORD PTR _pY$[esp+232]
	mov	ebx, DWORD PTR _pX$[esp+232]
	mov	edi, DWORD PTR _pDY$[esp+232]
	sub	eax, ecx
	sub	ebx, ecx
	mov	DWORD PTR -208+[esp+232], eax
	mov	eax, DWORD PTR _ReplicaCount$[esp+232]
	mov	edx, ecx
	sub	edi, ecx
	mov	DWORD PTR -192+[esp+232], eax
$L79098:

; 668  : 			{
; 669  : 				if (fabs(pDX[rsp] - CurrDispX) < T.DeltaDX && fabs(pDY[rsp] - CurrDispY) < T.DeltaDY)

	fld	DWORD PTR [edx]
	fsub	DWORD PTR _CurrDispX$[esp+232]
	fabs
	fld	DWORD PTR [esi+1024]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79099
	fld	DWORD PTR [edi+edx]
	fsub	DWORD PTR _CurrDispY$[esp+232]
	fabs
	fld	DWORD PTR [esi+1028]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79099

; 670  : 				{
; 671  : 					rv++;
; 672  : 					V = pX[rsp];

	fld	DWORD PTR [ebx+edx]

; 673  : 					W = pDX[rsp];

	fld	DWORD PTR [edx]

; 674  : 					SumX += V;

	fld	ST(1)
	faddp	ST(6), ST(0)

; 675  : 					SumX2 += V * V;

	fld	ST(1)
	fmul	ST(0), ST(2)
	mov	eax, DWORD PTR _rv$79085[esp+232]
	inc	eax
	faddp	ST(5), ST(0)
	mov	DWORD PTR _rv$79085[esp+232], eax

; 676  : 					SumPx += W;
; 677  : 					SumXPx += V * W;
; 678  : 					V = pY[rsp];

	mov	eax, DWORD PTR -208+[esp+232]
	fld	ST(0)
	faddp	ST(7), ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(3), ST(0)
	fstp	ST(0)
	fld	DWORD PTR [eax+edx]

; 679  : 					W = pDY[rsp];

	fld	DWORD PTR [edi+edx]

; 680  : 					SumY += V;

	fld	ST(1)
	faddp	ST(3), ST(0)

; 681  : 					SumY2 += V * V;

	fld	ST(1)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR _SumY2$79093[esp+232]
	fstp	QWORD PTR _SumY2$79093[esp+232]

; 682  : 					SumPy += W;

	fld	ST(0)
	fadd	QWORD PTR _SumPy$79091[esp+232]
	fstp	QWORD PTR _SumPy$79091[esp+232]

; 683  : 					SumYPy += V * W;

	fmul	ST(0), ST(1)
	fadd	QWORD PTR _SumYPy$79094[esp+232]
	fstp	QWORD PTR _SumYPy$79094[esp+232]
	fstp	ST(0)
$L79099:
	mov	eax, DWORD PTR -192+[esp+232]
	add	edx, 4
	dec	eax
	mov	DWORD PTR -192+[esp+232], eax
	jne	$L79098
	fst	QWORD PTR _SumY$79092[esp+232]
	fxch	ST(1)
	fst	QWORD PTR _SumXPx$79089[esp+232]
	fxch	ST(1)
	fstp	ST(0)
$L79100:

; 684  : 					}
; 685  : 				}
; 686  : 			DenX = 1. / (rv * SumX2 - SumX * SumX);

	fild	DWORD PTR _rv$79085[esp+232]

; 687  : 			L0X = (SumPx * SumX2 - SumX * SumXPx) * DenX;
; 688  : 			L1X = (rv * SumXPx - SumX * SumPx) * DenX;
; 689  : 			DenY = 1. / (rv * SumY2 - SumY * SumY);
; 690  : 			L0Y = (SumPy * SumY2 - SumY * SumYPy) * DenY;
; 691  : 			L1Y = (rv * SumYPy - SumY * SumPy) * DenY;
; 692  : 
; 693  : 			SumPx = 0.0; SumX = 0.0; SumX2 = 0.0; SumXPx = 0.0; DenX = 0.0;
; 694  : 			SumPy = 0.0; SumY = 0.0; SumY2 = 0.0; SumYPy = 0.0; DenY = 0.0;
; 695  : 			for (rsp = rv = 0; rsp < ReplicaCount; rsp++)

	mov	eax, DWORD PTR _ReplicaCount$[esp+232]
	mov	DWORD PTR _rv$79085[esp+232], 0
	test	eax, eax
	fst	QWORD PTR -208+[esp+232]
	fmul	ST(0), ST(2)
	fld	ST(3)
	fmul	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fdivr	QWORD PTR __real@8@3fff8000000000000000
	fstp	QWORD PTR _DenX$79090[esp+232]
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR _DenX$79090[esp+232]
	fstp	QWORD PTR _L0X$[esp+232]
	fld	QWORD PTR -208+[esp+232]
	fmul	QWORD PTR _SumXPx$79089[esp+232]
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR _DenX$79090[esp+232]
	fstp	QWORD PTR _L1X$[esp+232]
	fstp	ST(0)
	fld	QWORD PTR _SumY$79092[esp+232]
	fld	QWORD PTR -208+[esp+232]
	fmul	QWORD PTR _SumY2$79093[esp+232]
	fld	ST(1)
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fdivr	QWORD PTR __real@8@3fff8000000000000000
	fld	QWORD PTR _SumY2$79093[esp+232]
	fmul	QWORD PTR _SumPy$79091[esp+232]
	fld	QWORD PTR _SumYPy$79094[esp+232]
	fmul	ST(0), ST(3)
	mov	DWORD PTR _SumY2$79093[esp+232], 0
	mov	DWORD PTR _SumY2$79093[esp+236], 0
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _L0Y$[esp+232]
	fld	QWORD PTR -208+[esp+232]
	fmul	QWORD PTR _SumYPy$79094[esp+232]
	fxch	ST(2)
	fmul	QWORD PTR _SumPy$79091[esp+232]
	mov	DWORD PTR _SumPy$79091[esp+232], 0
	mov	DWORD PTR _SumPy$79091[esp+236], 0
	mov	DWORD PTR _SumYPy$79094[esp+232], 0
	mov	DWORD PTR _SumYPy$79094[esp+236], 0
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _L1Y$[esp+232]
	fstp	ST(0)
	fld	QWORD PTR __real@8@00000000000000000000
	fld	QWORD PTR __real@8@00000000000000000000
	fld	QWORD PTR __real@8@00000000000000000000
	fld	QWORD PTR __real@8@00000000000000000000
	fst	QWORD PTR _SumXPx$79089[esp+232]
	fld	QWORD PTR __real@8@00000000000000000000
	fst	QWORD PTR _SumY$79092[esp+232]
	jle	$L80564

; 696  : 			{
; 697  : 				if (fabs(pDX[rsp] - (pX[rsp] * L1X + L0X)) < T.DeltaDX && fabs(pDY[rsp] - (pY[rsp] * L1Y + L0Y)) < T.DeltaDY)
; 698  : 				{
; 699  : 					rv++;
; 700  : 					V = pX[rsp];
; 701  : 					W = pDX[rsp];
; 702  : 					SumX += V;
; 703  : 					SumX2 += V * V;
; 704  : 					SumPx += W;
; 705  : 					SumXPx += V * W;
; 706  : 					V = pY[rsp];
; 707  : 					W = pDY[rsp];
; 708  : 					SumY += V;
; 709  : 					SumY2 += V * V;
; 710  : 					SumPy += W;
; 711  : 					SumYPy += V * W;
; 712  : 					}
; 713  : 				else pReplicas[rsp] = 0;

	mov	ebx, DWORD PTR _pX$[esp+232]
	mov	edx, DWORD PTR _pY$[esp+232]
	mov	edi, DWORD PTR _pDY$[esp+232]
	mov	eax, DWORD PTR _pReplicas$[esp+232]
	sub	ebx, ecx
	sub	edx, ecx
	sub	edi, ecx
	sub	eax, ecx
	mov	DWORD PTR -208+[esp+232], eax
	mov	eax, DWORD PTR _ReplicaCount$[esp+232]
	mov	DWORD PTR -104+[esp+232], eax
$L79102:
	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+ebx]
	fmul	QWORD PTR _L1X$[esp+232]
	fadd	QWORD PTR _L0X$[esp+232]
	fsubp	ST(1), ST(0)
	fabs
	fld	DWORD PTR [esi+1024]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L79105
	fld	DWORD PTR [ecx+edi]
	fld	DWORD PTR [ecx+edx]
	fmul	QWORD PTR _L1Y$[esp+232]
	fadd	QWORD PTR _L0Y$[esp+232]
	fsubp	ST(1), ST(0)
	fabs
	fld	DWORD PTR [esi+1028]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79105
	fld	DWORD PTR [ecx+ebx]
	fld	DWORD PTR [ecx]
	fld	ST(1)
	faddp	ST(6), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	mov	eax, DWORD PTR _rv$79085[esp+232]
	inc	eax
	faddp	ST(5), ST(0)
	mov	DWORD PTR _rv$79085[esp+232], eax
	fld	ST(0)
	faddp	ST(7), ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(3), ST(0)
	fstp	ST(0)
	fld	DWORD PTR [ecx+edx]
	fld	DWORD PTR [ecx+edi]
	fld	ST(1)
	faddp	ST(3), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR _SumY2$79093[esp+232]
	fstp	QWORD PTR _SumY2$79093[esp+232]
	fld	ST(0)
	fadd	QWORD PTR _SumPy$79091[esp+232]
	fstp	QWORD PTR _SumPy$79091[esp+232]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _SumYPy$79094[esp+232]
	fstp	QWORD PTR _SumYPy$79094[esp+232]
	fstp	ST(0)
	jmp	SHORT $L79103
$L80566:

; 662  : 
; 663  : 			int rsp, rv;
; 664  : 			double SumPx = 0.0, SumX = 0.0, SumX2 = 0.0, SumXPx = 0.0, DenX = 0.0;
; 665  : 			double SumPy = 0.0, SumY = 0.0, SumY2 = 0.0, SumYPy = 0.0, DenY = 0.0;

	mov	ecx, DWORD PTR _pDX$[esp+232]

; 666  : 			double V, W;
; 667  : 			for (rsp = rv = 0; rsp < ReplicaCount; rsp++)

	fstp	ST(0)
	jmp	$L79100
$L79105:

; 696  : 			{
; 697  : 				if (fabs(pDX[rsp] - (pX[rsp] * L1X + L0X)) < T.DeltaDX && fabs(pDY[rsp] - (pY[rsp] * L1Y + L0Y)) < T.DeltaDY)
; 698  : 				{
; 699  : 					rv++;
; 700  : 					V = pX[rsp];
; 701  : 					W = pDX[rsp];
; 702  : 					SumX += V;
; 703  : 					SumX2 += V * V;
; 704  : 					SumPx += W;
; 705  : 					SumXPx += V * W;
; 706  : 					V = pY[rsp];
; 707  : 					W = pDY[rsp];
; 708  : 					SumY += V;
; 709  : 					SumY2 += V * V;
; 710  : 					SumPy += W;
; 711  : 					SumYPy += V * W;
; 712  : 					}
; 713  : 				else pReplicas[rsp] = 0;

	mov	eax, DWORD PTR -208+[esp+232]
	mov	DWORD PTR [eax+ecx], 0
$L79103:
	mov	eax, DWORD PTR -104+[esp+232]
	add	ecx, 4
	dec	eax
	mov	DWORD PTR -104+[esp+232], eax
	jne	$L79102
	fst	QWORD PTR _SumY$79092[esp+232]
	fxch	ST(1)
	fst	QWORD PTR _SumXPx$79089[esp+232]
	fxch	ST(1)
$L80564:
	fstp	ST(0)

; 714  : 				}
; 715  : 			DenX = 1. / (rv * SumX2 - SumX * SumX);

	fild	DWORD PTR _rv$79085[esp+232]

; 716  : 			L0X = (SumPx * SumX2 - SumX * SumXPx) * DenX;
; 717  : 			L1X = (rv * SumXPx - SumX * SumPx) * DenX;
; 718  : 			DenY = 1. / (rv * SumY2 - SumY * SumY);
; 719  : 			L0Y = (SumPy * SumY2 - SumY * SumYPy) * DenY;
; 720  : 			L1Y = (rv * SumYPy - SumY * SumPy) * DenY;
; 721  : 			AvgLX = L0X + L1X * T.ViewCenterX;
; 722  : 			AvgLY = L0Y + L1Y * T.ViewCenterY;
; 723  : 			L1X += 1.0;
; 724  : 			L1Y += 1.0;
; 725  : 			for (rsp = 0; rsp < ReplicaCount; rsp++)

	mov	edx, DWORD PTR _ReplicaCount$[esp+232]
	test	edx, edx
	fst	QWORD PTR -208+[esp+232]
	fmul	ST(0), ST(2)
	fld	ST(3)
	fmul	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fdivr	QWORD PTR __real@8@3fff8000000000000000
	fstp	QWORD PTR _DenX$79090[esp+232]
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR _DenX$79090[esp+232]
	fstp	QWORD PTR _L0X$[esp+232]
	fld	QWORD PTR -208+[esp+232]
	fmul	QWORD PTR _SumXPx$79089[esp+232]
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR _DenX$79090[esp+232]
	fstp	ST(1)
	fld	QWORD PTR _SumY$79092[esp+232]
	fld	QWORD PTR -208+[esp+232]
	fmul	QWORD PTR _SumY2$79093[esp+232]
	fld	ST(1)
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fdivr	QWORD PTR __real@8@3fff8000000000000000
	fld	QWORD PTR _SumY2$79093[esp+232]
	fmul	QWORD PTR _SumPy$79091[esp+232]
	fld	QWORD PTR _SumYPy$79094[esp+232]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _L0Y$[esp+232]
	fld	QWORD PTR -208+[esp+232]
	fmul	QWORD PTR _SumYPy$79094[esp+232]
	fxch	ST(2)
	fmul	QWORD PTR _SumPy$79091[esp+232]
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _L1Y$[esp+232]
	fstp	ST(0)
	fld	DWORD PTR [esi+1068]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _L0X$[esp+232]
	fstp	QWORD PTR _AvgLX$[esp+232]
	fld	DWORD PTR [esi+1072]
	fmul	QWORD PTR _L1Y$[esp+232]
	fadd	QWORD PTR _L0Y$[esp+232]
	fstp	QWORD PTR _AvgLY$[esp+232]
	fadd	QWORD PTR __real@8@3fff8000000000000000
	fstp	QWORD PTR _L1X$[esp+232]
	fld	QWORD PTR _L1Y$[esp+232]
	fadd	QWORD PTR __real@8@3fff8000000000000000
	fstp	QWORD PTR _L1Y$[esp+232]
	jle	SHORT $L79109

; 714  : 				}
; 715  : 			DenX = 1. / (rv * SumX2 - SumX * SumX);

	mov	ecx, DWORD PTR _pReplicas$[esp+232]
$L79107:

; 726  : 				if (pReplicas[rsp]) 

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $L79108

; 727  : 					pReplicas[rsp]->Area = -pReplicas[rsp]->Area;

	mov	edi, DWORD PTR [eax+8]
	neg	edi
	mov	DWORD PTR [eax+8], edi
$L79108:
	add	ecx, 4
	dec	edx
	jne	SHORT $L79107
$L79109:

; 728  : /*
; 729  : 			T.DispX = (DispX += CurrDispX);
; 730  : 			T.DispY = (DispY += CurrDispY);
; 731  : */
; 732  : /*
; 733  : 			fprintf(fsmtd, "%d %d %f %f %d %d %f %f %f %f\n", run, Layer, CurrDispX, CurrDispY, MaxHisto, MaxBin, DX, DY, T.DeltaDX, T.DeltaDY);
; 734  : */				
; 735  : /*
; 736  : 			fprintf(fsmtd, "%d %d %f %f %f %d %d %f %f %f %f\n", run, Layer, Z - T.ZLayer[Layer - 1], CurrDispX, CurrDispY, MaxHisto, MaxBin, L0X, L1X, L0Y, L1Y);
; 737  : */				
; 738  : 
; 739  : 			CurrDispSigmaX = T.DeltaDX * 0.5f;

	fld	DWORD PTR [esi+1024]
	fmul	DWORD PTR __real@4@3ffe8000000000000000

; 740  : 			CurrDispSigmaY = T.DeltaDY * 0.5f;
; 741  : 			T.ShadowSigmaMeasures++;

	mov	eax, DWORD PTR [esi+1020]
	inc	eax

; 742  : 			T.ShadowSigmaXAccumulator += CurrDispSigmaX;

	fadd	DWORD PTR [esi+1004]
	mov	DWORD PTR [esi+1020], eax
	fstp	DWORD PTR [esi+1004]
	fld	DWORD PTR [esi+1028]
	fmul	DWORD PTR __real@4@3ffe8000000000000000

; 743  : 			T.ShadowSigmaYAccumulator += CurrDispSigmaY;

	fadd	DWORD PTR [esi+1008]
	fstp	DWORD PTR [esi+1008]

; 744  : 			}
; 745  : 		}
; 746  : 	else

	jmp	$L79114
$L79062:

; 747  : 	{
; 748  : 		for (Nc = 0; (Nc < CountOfClusters) && (CurrentGCounter < MaxGrains); Nc++)

	mov	eax, DWORD PTR _CountOfClusters$[ebp]
	mov	DWORD PTR _Nc$[esp+232], 0
	test	eax, eax
	jle	$L79114
	mov	ecx, DWORD PTR _pClusters$[ebp]
	lea	ebx, DWORD PTR [ecx+4]
$L79112:
	mov	edx, DWORD PTR _MaxGrains$[esp+232]
	mov	eax, DWORD PTR _CurrentGCounter$[esp+232]
	cmp	eax, edx
	jge	$L79114

; 749  : 		{	
; 750  : 			PClus = (IntCluster *)(pClusters + Nc);
; 751  : 			if ((PClus->Area >= PixMin) && (PClus->Area <= PixMax))

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR _PixMin$[esp+232]
	cmp	eax, ecx
	jl	$L79113
	cmp	eax, DWORD PTR _PixMax$[esp+232]
	jg	$L79113

; 752  : 			{	
; 753  : 				Icell = GetCell(PClus->X *= PixelToMicronX, PClus->Y *= PixelToMicronY);

	fld	DWORD PTR _PixelToMicronY$[esp+232]
	fmul	DWORD PTR [ebx]
	fst	DWORD PTR [ebx]
	fstp	DWORD PTR $T80530[esp+232]
	fld	DWORD PTR _PixelToMicronX$[esp+232]
	fmul	DWORD PTR [ebx-4]
	fst	DWORD PTR [ebx-4]
	fst	DWORD PTR $T80529[esp+232]
	fcomp	DWORD PTR [esi+956]
	fnstsw	ax
	test	ah, 1
	jne	$L79113
	fld	DWORD PTR $T80529[esp+232]
	fcomp	DWORD PTR [esi+960]
	fnstsw	ax
	test	ah, 1
	je	$L79113
	fld	DWORD PTR $T80530[esp+232]
	fcomp	DWORD PTR [esi+964]
	fnstsw	ax
	test	ah, 1
	jne	$L79113
	fld	DWORD PTR $T80530[esp+232]
	fcomp	DWORD PTR [esi+968]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79113
	fld	DWORD PTR $T80530[esp+232]
	fsub	DWORD PTR [esi+964]
	fdiv	DWORD PTR [esi+976]
	call	__ftol
	fld	DWORD PTR $T80529[esp+232]
	fsub	DWORD PTR [esi+956]
	mov	edi, eax
	imul	edi, DWORD PTR [esi+148]
	fdiv	DWORD PTR [esi+972]
	call	__ftol
	add	edi, eax
	js	SHORT $L79113
	cmp	edi, DWORD PTR [esi+952]
	jge	SHORT $L79113

; 754  : 				if (Icell >= 0)
; 755  : 				{	
; 756  : 					PCell = (Cell *)(CellSpace+(Layer*CellsInLayer+Icell));

	mov	eax, DWORD PTR _Layer$[esp+232]
	mov	ecx, DWORD PTR _CellSpace$[esp+232]
	imul	eax, DWORD PTR _CellsInLayer$[esp+232]
	add	eax, edi

; 757  : 					PCell->Free++;

	mov	edx, DWORD PTR [ecx+eax*8+4]
	lea	eax, DWORD PTR [ecx+eax*8]

; 758  : 					CurrentGCounter++;

	mov	ecx, DWORD PTR _CurrentGCounter$[esp+232]
	inc	edx
	inc	ecx
	mov	DWORD PTR [eax+4], edx

; 759  : 					PClus->NextFree = PCell->FirstC;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _CurrentGCounter$[esp+232], ecx

; 760  : 					PCell->FirstC = PClus;

	lea	ecx, DWORD PTR [ebx-4]
	mov	DWORD PTR [ebx+8], edx
	mov	DWORD PTR [eax], ecx
$L79113:
	mov	eax, DWORD PTR _Nc$[esp+232]
	mov	ecx, DWORD PTR _CountOfClusters$[ebp]
	inc	eax
	add	ebx, 40					; 00000028H
	cmp	eax, ecx
	mov	DWORD PTR _Nc$[esp+232], eax
	jl	$L79112
$L79114:

; 761  : 					};
; 762  : 				};
; 763  : 			};
; 764  : 		};
; 765  : 
; 766  : /*	fclose(fsmtg);
; 767  : 	fclose(fsmtd);
; 768  : */
; 769  : 	T.LayerGrains[Layer] = PGrain = T.GrainSpace + T.NumGrains;

	mov	eax, DWORD PTR [esi+988]
	mov	ecx, DWORD PTR [esi+936]
	mov	edx, DWORD PTR [esi+944]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edi, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _Layer$[esp+232]

; 770  : 	PGrainEnd = T.GrainSpace + MaxGrains;

	mov	eax, DWORD PTR _MaxGrains$[esp+232]
	mov	DWORD PTR [edx+ecx*4], edi
	mov	edx, DWORD PTR [esi+936]

; 771  : 
; 772  : 	if (T.ReplicaRadius > 0.0f && Layer > 0)

	fld	DWORD PTR [esi+908]
	fcomp	DWORD PTR __real@4@00000000000000000000
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _PGrainEnd$[esp+232], eax
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L79119
	test	ecx, ecx
	jle	$L79119

; 773  : 	{
; 774  : 		for (Icell = 0; (Icell < CellsInLayer) && (PGrain < PGrainEnd); Icell ++)

	mov	eax, DWORD PTR _CellsInLayer$[esp+232]
	mov	DWORD PTR _Icell$[esp+232], 0
	test	eax, eax
	jle	$L79143
$L79120:
	cmp	edi, DWORD PTR _PGrainEnd$[esp+232]
	jae	$L80556

; 775  : 		{	
; 776  : 			PCell = (Cell *)(CellSpace+(Layer*CellsInLayer+Icell));

	mov	ecx, DWORD PTR _Layer$[esp+232]
	mov	edx, DWORD PTR _Icell$[esp+232]
	imul	ecx, DWORD PTR _CellsInLayer$[esp+232]
	add	ecx, edx
	mov	edx, DWORD PTR _CellSpace$[esp+232]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _PCell$[esp+232], eax

; 777  : 			if (PCell->Free)

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$L79139

; 778  : 			{	
; 779  : 				if (PCell->Free < CellOverflow)

	mov	ecx, DWORD PTR _CellOverflow$[esp+232]
	cmp	eax, ecx

; 780  : 				{	
; 781  : 					PClus = PCell->FirstC;

	mov	eax, DWORD PTR _PCell$[esp+232]
	jge	$L79125
	mov	ebx, DWORD PTR [eax]

; 782  : 					PCell->FirstG = PGrain;

	mov	DWORD PTR [eax], edi
$L79126:

; 783  : 					do
; 784  : 					{	
; 785  : //						PGrain->Xcm = PClus->X + DispX;
; 786  : //						PGrain->Ycm = PClus->Y + DispY;
; 787  : 						if (PClus->Area < 0)

	mov	eax, DWORD PTR [ebx+8]

; 788  : 						{
; 789  : 
; 790  : 							PGrain->Xcm = PClus->X * L1X + L0X;

	fld	DWORD PTR [ebx]
	test	eax, eax
	jge	SHORT $L79129
	fmul	QWORD PTR _L1X$[esp+232]
	fadd	QWORD PTR _L0X$[esp+232]
	fstp	DWORD PTR [edi]

; 791  : 							PGrain->Ycm = PClus->Y * L1Y + L0Y;

	fld	DWORD PTR [ebx+4]
	fmul	QWORD PTR _L1Y$[esp+232]
	fadd	QWORD PTR _L0Y$[esp+232]
	fstp	DWORD PTR [edi+4]

; 792  : 							PGrain->Area = -PClus->Area;

	mov	eax, DWORD PTR [ebx+8]
	neg	eax

; 793  : 							if (PGrain->Area <= 0)

	test	eax, eax
	mov	DWORD PTR [edi+8], eax
	jg	SHORT $L79135

; 794  : 							{
; 795  : 								::MessageBox(0, "Here - A!", "Debug Info", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0L@GFNK@Debug?5Info?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09IOG@Here?5?9?5A?$CB?$AA@ ; `string'
	push	0
	call	DWORD PTR __imp__MessageBoxA@16

; 796  : 								volatile uy = 0;

	mov	DWORD PTR _uy$79133[esp+232], 0

; 797  : 								uy = 1;

	mov	DWORD PTR _uy$79133[esp+232], 1

; 798  : 								}
; 799  : 							}
; 800  : 						else

	jmp	SHORT $L79135
$L79129:

; 801  : 						{
; 802  : 							PGrain->Xcm = PClus->X + AvgLX;

	fadd	QWORD PTR _AvgLX$[esp+232]
	fstp	DWORD PTR [edi]

; 803  : 							PGrain->Ycm = PClus->Y + AvgLY;

	fld	DWORD PTR [ebx+4]
	fadd	QWORD PTR _AvgLY$[esp+232]
	fstp	DWORD PTR [edi+4]

; 804  : 							PGrain->Area = PClus->Area;

	mov	eax, DWORD PTR [ebx+8]

; 805  : 							if (PGrain->Area <= 0)

	test	eax, eax
	mov	DWORD PTR [edi+8], eax
	jg	SHORT $L79135

; 806  : 							{
; 807  : 								::MessageBox(0, "Here - B!", "Debug Info", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0L@GFNK@Debug?5Info?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09DDBJ@Here?5?9?5B?$CB?$AA@ ; `string'
	push	0
	call	DWORD PTR __imp__MessageBoxA@16

; 808  : 								volatile uy = 0;

	mov	DWORD PTR _uy$79137[esp+232], 0

; 809  : 								uy = 1;

	mov	DWORD PTR _uy$79137[esp+232], 1
$L79135:

; 810  : 								}
; 811  : 							}
; 812  : 						PClus = PClus->NextFree;
; 813  : 						}
; 814  : 					while (((++PGrain) < PGrainEnd) && (PClus));

	mov	eax, DWORD PTR _PGrainEnd$[esp+232]
	mov	ebx, DWORD PTR [ebx+12]
	add	edi, 20					; 00000014H
	cmp	edi, eax
	jae	SHORT $L79139
	test	ebx, ebx
	jne	$L79126

; 815  : 					}
; 816  : 				else

	jmp	SHORT $L79139
$L79125:

; 817  : 				{	
; 818  : 					PCell->Free = 0;

	mov	DWORD PTR [eax+4], 0

; 819  : 					PCell->FirstG = 0;

	mov	DWORD PTR [eax], 0
$L79139:

; 820  : 					};
; 821  : 				};
; 822  : 			T.NumGrains += PCell->Free;

	mov	eax, DWORD PTR _PCell$[esp+232]
	mov	ebx, DWORD PTR [esi+988]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _Icell$[esp+232]
	add	ebx, ecx
	mov	ecx, DWORD PTR _CellsInLayer$[esp+232]
	inc	eax
	mov	DWORD PTR [esi+988], ebx
	cmp	eax, ecx
	mov	DWORD PTR _Icell$[esp+232], eax
	jl	$L79120

; 823  : 			};		
; 824  : 		}
; 825  : 	else

	jmp	$L79143
$L79119:

; 826  : 	{
; 827  : 		for (Icell = 0; (Icell < CellsInLayer) && (PGrain < PGrainEnd); Icell ++)

	mov	eax, DWORD PTR _CellsInLayer$[esp+232]
	mov	DWORD PTR _Icell$[esp+232], 0
	test	eax, eax
	jle	$L79143
$L79141:
	cmp	edi, DWORD PTR _PGrainEnd$[esp+232]
	jae	$L80556

; 828  : 		{	
; 829  : 			PCell = (Cell *)(CellSpace+(Layer*CellsInLayer+Icell));

	mov	edx, DWORD PTR _Layer$[esp+232]
	mov	ebx, DWORD PTR _Icell$[esp+232]
	imul	edx, DWORD PTR _CellsInLayer$[esp+232]
	mov	eax, DWORD PTR _CellSpace$[esp+232]
	add	edx, ebx
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _PCell$[esp+232], ecx

; 830  : 			if (PCell->Free)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $L79154

; 831  : 			{	
; 832  : 				if (PCell->Free < CellOverflow)

	cmp	eax, DWORD PTR _CellOverflow$[esp+232]
	jge	SHORT $L79146

; 833  : 				{	
; 834  : 					PClus = PCell->FirstC;

	mov	ebx, DWORD PTR [ecx]

; 835  : 					PCell->FirstG = PGrain;

	mov	DWORD PTR [ecx], edi
$L79147:

; 836  : 					do
; 837  : 					{	
; 838  : 						PGrain->Xcm = PClus->X;

	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR [edi], edx

; 839  : 						PGrain->Ycm = PClus->Y;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi+4], eax

; 840  : 						PGrain->Area = PClus->Area;

	mov	eax, DWORD PTR [ebx+8]

; 841  : 						if (PGrain->Area <= 0)

	test	eax, eax
	mov	DWORD PTR [edi+8], eax
	jg	SHORT $L79150

; 842  : 						{
; 843  : 							::MessageBox(0, "Here - C!", "Debug Info", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0L@GFNK@Debug?5Info?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09CFLD@Here?5?9?5C?$CB?$AA@ ; `string'
	push	0
	call	DWORD PTR __imp__MessageBoxA@16

; 844  : 							volatile uy = 0;

	mov	DWORD PTR _uy$79152[esp+232], 0

; 845  : 							uy = 1;

	mov	DWORD PTR _uy$79152[esp+232], 1
	mov	ecx, DWORD PTR _PCell$[esp+232]
$L79150:

; 846  : 							}
; 847  : 						PClus = PClus->NextFree;
; 848  : 						}
; 849  : 					while (((++PGrain) < PGrainEnd) && (PClus));

	mov	eax, DWORD PTR _PGrainEnd$[esp+232]
	mov	ebx, DWORD PTR [ebx+12]
	add	edi, 20					; 00000014H
	cmp	edi, eax
	jae	SHORT $L79154
	test	ebx, ebx
	jne	SHORT $L79147

; 850  : 					}
; 851  : 				else

	jmp	SHORT $L79154
$L79146:

; 852  : 				{	
; 853  : 					PCell->Free = 0;

	mov	DWORD PTR [ecx+4], 0

; 854  : 					PCell->FirstG = 0;

	mov	DWORD PTR [ecx], 0
$L79154:

; 855  : 					};
; 856  : 				};
; 857  : 			T.NumGrains += PCell->Free;

	mov	ecx, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [esi+988]
	mov	eax, DWORD PTR _Icell$[esp+232]
	add	ebx, ecx
	mov	ecx, DWORD PTR _CellsInLayer$[esp+232]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR [esi+988], ebx
	mov	DWORD PTR _Icell$[esp+232], eax
	jl	$L79141
$L79143:

; 858  : 			};
; 859  : 		}
; 860  : /*
; 861  : 	{
; 862  : 		FILE *f = fopen("c:\\acq\\tk.txt", "at");
; 863  : 		fprintf(f, "%d %f %f %d %f %f\n", T.Layer, T.DispX, T.DispY, ReplicaCount, CurrDispSigmaX, CurrDispSigmaY);
; 864  : 		fclose(f);
; 865  : 		}
; 866  : */
; 867  : 	if (PGrain >= PGrainEnd) return S_FALSE;

	cmp	edi, DWORD PTR _PGrainEnd$[esp+232]
	jb	SHORT $L79155
$L80556:
	mov	eax, 1

; 869  : 	return S_OK;
; 870  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L79155:

; 868  : 	T.Layer++;

	mov	eax, DWORD PTR [esi+992]

; 869  : 	return S_OK;
; 870  : }

	pop	edi
	inc	eax
	mov	DWORD PTR [esi+992], eax
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PutClusters@CSmartTrackerClass@@UAGJPAUCluster@@HM@Z ENDP ; CSmartTrackerClass::PutClusters
_TEXT	ENDS
PUBLIC	?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z ; CSmartTrackerClass::GetTracks
PUBLIC	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
PUBLIC	?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z ; CSmartTrackerClass::InsertNewTrack
PUBLIC	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z ; CSmartTrackerClass::FinalizeTracks
PUBLIC	__real@4@4002a000000000000000
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z	; Cell::FindGrain
EXTRN	__imp__hypot:NEAR
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
;	COMDAT __real@4@4002a000000000000000
; File D:\SySal2\SmartTracker8\SmartTrackerClass.cpp
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z
_TEXT	SEGMENT
_pSpace$ = 12
_pMaxNumber$ = 16
_StartLayer$ = 20
_EndLayer$ = 24
_this$ = 8
_nx$ = -172
_ny$ = -220
_itr$ = -144
_NTracks$ = -164
_ZLayer$ = -260
_tz$ = -228
_CellsInLayer$ = -88
_CellSpace$ = -252
_MaxSlope$ = -100
_iix$ = -132
_minix$ = -160
_maxix$ = -208
_miniy$ = -224
_maxiy$ = -156
_Slope2$ = -152
_SlopeX$ = -288
_SlopeY$ = -284
_ExpX$ = -256
_ExpY$ = -292
_DirX$ = -268
_DirY$ = -280
_dirtol$ = -272
_ir$ = -192
_idz$ = -180
_pTempGrains$ = -264
_avgdz$ = -176
_tsl$ = -116
_tinf$ = -92
_td$ = -104
_tr$79214 = -64
_tp$79217 = -212
_bp$79218 = -108
_pT$79230 = -248
_pTE$79231 = -112
_gt$79235 = -84
_pB$79243 = -232
_pBE$79244 = -96
_gb$79248 = -20
_pTrg$79258 = -292
_seqlength$79262 = -276
_topv$79271 = -244
_bottomv$79272 = -204
?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z PROC NEAR ; CSmartTrackerClass::GetTracks, COMDAT

; 873  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 292				; 00000124H
	push	ebx

; 874  : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 875  : 
; 876  : 	// TODO: Add your implementation code here
; 877  : 
; 878  : 	int nx, ny;
; 879  : 	int lay;
; 880  : 	int itr, ibr;
; 881  : 	int NTracks = 0;
; 882  : 	float *ZLayer = T.ZLayer;

	mov	ebx, DWORD PTR _this$[ebp]
	push	esi
	push	edi

; 883  : 	float tz;
; 884  : 	int CellsInLayer = T.CellsInLayer;

	mov	eax, DWORD PTR [ebx+952]

; 885  : 	Cell *CellSpace = T.CellSpace;

	mov	ecx, DWORD PTR [ebx+948]
	mov	edi, DWORD PTR [ebx+940]
	mov	DWORD PTR _CellsInLayer$[esp+304], eax

; 886  : 	float MaxSlope = T.MaxSlope;
; 887  : 	float MinSlope = T.MinSlope;
; 888  : 
; 889  : 	int ix, iy, iix, iiy, eix, eiy;
; 890  : 	int minix, maxix, miniy, maxiy;
; 891  : 	float Slope2;
; 892  : 	float SlopeX, SlopeY, ExpX, ExpY, DirX, DirY;
; 893  : 	float dirtol;
; 894  : 	int it, ib, ir;
; 895  : 	float idz;
; 896  : 
; 897  : 	nx = T.CellNumX;

	mov	eax, DWORD PTR [ebx+148]
	mov	edx, DWORD PTR [ebx+896]
	mov	DWORD PTR _CellSpace$[esp+304], ecx

; 898  : 	ny = T.CellNumY;

	mov	ecx, DWORD PTR [ebx+152]
	mov	DWORD PTR _nx$[esp+304], eax

; 899  : 
; 900  : 	if (*pMaxNumber <= 0)

	mov	eax, DWORD PTR _pMaxNumber$[ebp]
	mov	DWORD PTR _ny$[esp+304], ecx
	mov	DWORD PTR _NTracks$[esp+304], 0
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ZLayer$[esp+304], edi
	test	ecx, ecx
	mov	DWORD PTR _MaxSlope$[esp+304], edx
	jg	SHORT $L79199

; 901  : 	{
; 902  : 		*pMaxNumber = 0;

	mov	DWORD PTR [eax], 0

; 1051 : 	return S_OK;

	xor	eax, eax

; 1052 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L79199:

; 903  : 		return S_OK;
; 904  : 		}
; 905  : 
; 906  : 	if (EndLayer >= T.Layer) EndLayer = T.Layer - 1;

	mov	eax, DWORD PTR [ebx+992]
	mov	esi, DWORD PTR _EndLayer$[ebp]
	cmp	esi, eax
	jl	SHORT $L79201
	dec	eax
	mov	DWORD PTR _EndLayer$[ebp], eax
	mov	esi, eax
$L79201:

; 907  : 
; 908  : 	IntGrain **pTempGrains = (IntGrain **)malloc(sizeof(IntGrain *) * (EndLayer + 1));

	lea	eax, DWORD PTR [esi+1]
	lea	edx, DWORD PTR [eax*4]
	push	edx
	call	DWORD PTR __imp__malloc
	mov	DWORD PTR _pTempGrains$[esp+308], eax

; 909  : 
; 910  : 	float avgdz = (ZLayer[StartLayer] - ZLayer[EndLayer]) / (EndLayer - StartLayer);

	mov	eax, DWORD PTR _StartLayer$[ebp]

; 911  : 			
; 912  : 	float tsl = 10.0f * (T.NptMinV - T.NptMin01) / (T.NptMin01 - T.NptMinH);
; 913  : 	float tinf = (float)(T.NptMinH);
; 914  : 	float td = (float)(T.NptMinV - T.NptMinH);
; 915  : 
; 916  : 	for (itr = 0; itr < T.TrialCount; itr++)

	mov	ecx, DWORD PTR [ebx+172]
	add	esp, 4
	fld	DWORD PTR [edi+eax*4]
	fsub	DWORD PTR [edi+esi*4]
	sub	esi, eax
	mov	DWORD PTR _itr$[esp+304], 0
	mov	DWORD PTR -216+[esp+304], esi
	fidiv	DWORD PTR -216+[esp+304]
	test	ecx, ecx
	fstp	DWORD PTR _avgdz$[esp+304]
	fld	DWORD PTR [ebx+880]
	fsub	DWORD PTR [ebx+888]
	fmul	DWORD PTR __real@4@4002a000000000000000
	fld	DWORD PTR [ebx+888]
	fsub	DWORD PTR [ebx+884]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _tsl$[esp+304]
	fld	DWORD PTR [ebx+884]
	fstp	DWORD PTR _tinf$[esp+304]
	fld	DWORD PTR [ebx+880]
	fsub	DWORD PTR [ebx+884]
	fstp	DWORD PTR _td$[esp+304]
	jle	$L79213
	lea	esi, DWORD PTR [ebx+176]
	mov	DWORD PTR -216+[esp+304], esi
	jmp	SHORT $L79211
$L80656:

; 907  : 
; 908  : 	IntGrain **pTempGrains = (IntGrain **)malloc(sizeof(IntGrain *) * (EndLayer + 1));

	mov	eax, DWORD PTR _StartLayer$[ebp]
$L79211:

; 917  : 	{
; 918  : 		Trial tr = T.Trials[itr];

	mov	ecx, 11					; 0000000bH
	lea	edi, DWORD PTR _tr$79214[esp+304]
	rep movsd

; 919  : 		if (tr.TopLayer < StartLayer || tr.BottomLayer > EndLayer) continue;

	mov	ecx, DWORD PTR _tr$79214[esp+304]
	cmp	ecx, eax
	jl	$L79212
	mov	edx, DWORD PTR _tr$79214[esp+308]
	mov	eax, DWORD PTR _EndLayer$[ebp]
	cmp	edx, eax
	jg	$L79212

; 920  : 		Cell *tp = CellsInLayer * tr.TopLayer + CellSpace;

	mov	esi, DWORD PTR _CellsInLayer$[esp+304]
	mov	edi, ecx
	imul	edi, esi
	mov	eax, DWORD PTR _CellSpace$[esp+304]
	lea	edi, DWORD PTR [eax+edi*8]
	mov	DWORD PTR _tp$79217[esp+304], edi

; 921  : 		Cell *bp = CellsInLayer * tr.BottomLayer + CellSpace;

	mov	edi, edx
	imul	edi, esi

; 922  : 		tz = ZLayer[tr.TopLayer];

	mov	esi, DWORD PTR _ZLayer$[esp+304]
	lea	eax, DWORD PTR [eax+edi*8]
	fld	DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _bp$79218[esp+304], eax
	fst	DWORD PTR _tz$[esp+304]

; 923  : 		idz = 1.0f / (tz - ZLayer[tr.BottomLayer]);

	fsub	DWORD PTR [esi+edx*4]

; 924  : 
; 925  : 		for (ix = 0; ix < nx; ix++)

	mov	edx, DWORD PTR _nx$[esp+304]
	test	edx, edx
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _idz$[esp+304]
	jle	$L79212
	mov	edi, DWORD PTR _tp$79217[esp+304]
	mov	eax, 1
	mov	DWORD PTR -124+[esp+304], eax
	mov	DWORD PTR -212+[esp+304], edi
$L79219:

; 926  : 		{
; 927  : 			minix = ix - 1; if (minix < 0) minix = 0;

	lea	ecx, DWORD PTR [eax-2]
	test	ecx, ecx
	mov	DWORD PTR _minix$[esp+304], ecx
	jge	SHORT $L79222
	mov	DWORD PTR _minix$[esp+304], 0
$L79222:

; 928  : 			maxix = ix + 1; if (maxix >= nx) maxix = nx - 1;

	cmp	eax, edx
	mov	DWORD PTR _maxix$[esp+304], eax
	jl	SHORT $L79223
	lea	ecx, DWORD PTR [edx-1]
	mov	DWORD PTR _maxix$[esp+304], ecx
$L79223:

; 929  : 			for (iy = 0; iy < ny; iy++)

	mov	esi, DWORD PTR _ny$[esp+304]
	test	esi, esi
	jle	$L79220
	mov	ecx, 1
	mov	DWORD PTR -140+[esp+304], edi
	mov	DWORD PTR -128+[esp+304], ecx
$L79224:

; 930  : 			{
; 931  : 				miniy = iy - 1; if (miniy < 0) miniy = 0;

	lea	eax, DWORD PTR [ecx-2]
	test	eax, eax
	mov	DWORD PTR _miniy$[esp+304], eax
	jge	SHORT $L79227
	mov	DWORD PTR _miniy$[esp+304], 0
	mov	eax, DWORD PTR _miniy$[esp+304]
$L79227:

; 932  : 				maxiy = iy + 1; if (maxiy >= ny) maxiy = ny - 1;

	cmp	ecx, esi
	mov	DWORD PTR _maxiy$[esp+304], ecx
	jl	SHORT $L79228
	dec	esi
	mov	DWORD PTR _maxiy$[esp+304], esi
$L79228:

; 933  : 				Cell &ct = tp[iy * nx + ix];
; 934  : 				IntGrain *pT = ct.FirstG;

	mov	esi, DWORD PTR [edi]

; 935  : 				IntGrain *pTE = ct.FirstG + ct.Free;

	mov	edi, DWORD PTR [edi+4]
	mov	DWORD PTR _pT$79230[esp+304], esi
	lea	edi, DWORD PTR [edi+edi*4]
	lea	edi, DWORD PTR [esi+edi*4]

; 936  : 				for (;pT < pTE; pT++)

	cmp	esi, edi
	mov	DWORD PTR _pTE$79231[esp+304], edi
	jae	$L80653
	jmp	SHORT $L79232
$L80652:
	mov	esi, DWORD PTR _pT$79230[esp+304]
$L79232:

; 937  : 				{
; 938  : 					IntGrain gt = *pT;

	mov	ecx, 5
	lea	edi, DWORD PTR _gt$79235[esp+304]
	rep movsd

; 939  : 					for (iix = minix; iix <= maxix; iix++)

	mov	ecx, DWORD PTR _minix$[esp+304]
	mov	edi, DWORD PTR _maxix$[esp+304]
	mov	esi, ecx
	mov	DWORD PTR _iix$[esp+304], ecx
	cmp	esi, edi
	jg	$L79233
$L79236:

; 940  : 						for (iiy = miniy; iiy <= maxiy; iiy++)

	mov	esi, DWORD PTR _maxiy$[esp+304]
	cmp	eax, esi
	jg	$L79237
	imul	eax, edx
	mov	edi, DWORD PTR _miniy$[esp+304]
	add	eax, ecx
	mov	ecx, DWORD PTR _bp$79218[esp+304]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, esi
	sub	eax, edi
	mov	DWORD PTR -136+[esp+304], ecx
	inc	eax
	mov	DWORD PTR -120+[esp+304], eax
$L79239:

; 941  : 						{
; 942  : 							Cell &cb = bp[iiy * nx + iix];
; 943  : 							IntGrain *pB = cb.FirstG;
; 944  : 							IntGrain *pBE = cb.FirstG + cb.Free;

	mov	edi, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR _pB$79243[esp+304], esi
	lea	edi, DWORD PTR [edi+edi*4]
	lea	edi, DWORD PTR [esi+edi*4]

; 945  : 							for (;pB < pBE; pB++)

	cmp	esi, edi
	mov	DWORD PTR _pBE$79244[esp+304], edi
	jae	$L79240
	jmp	SHORT $L79245
$L80635:
	mov	esi, DWORD PTR _pB$79243[esp+304]
$L79245:

; 946  : 							{
; 947  : 								IntGrain gb = *pB;
; 948  : 								SlopeX = idz * (gt.Xcm - gb.Xcm);

	fld	DWORD PTR _gt$79235[esp+304]
	mov	ecx, 5
	lea	edi, DWORD PTR _gb$79248[esp+304]
	rep movsd
	fsub	DWORD PTR _gb$79248[esp+304]
	fmul	DWORD PTR _idz$[esp+304]
	fst	DWORD PTR _SlopeX$[esp+304]

; 949  : 								SlopeY = idz * (gt.Ycm - gb.Ycm);

	fld	DWORD PTR _gt$79235[esp+308]
	fsub	DWORD PTR _gb$79248[esp+308]
	fmul	DWORD PTR _idz$[esp+304]
	fst	DWORD PTR _SlopeY$[esp+304]

; 950  : 								Slope2 = hypot(SlopeX, SlopeY);

	fstp	QWORD PTR -152+[esp+304]
	mov	esi, DWORD PTR -152+[esp+308]
	mov	edi, DWORD PTR -152+[esp+304]
	fstp	QWORD PTR -192+[esp+304]
	mov	edx, DWORD PTR -192+[esp+308]
	mov	eax, DWORD PTR -192+[esp+304]
	push	esi
	push	edi
	push	edx
	push	eax
	call	DWORD PTR __imp__hypot
	fst	DWORD PTR _Slope2$[esp+320]

; 951  : 								if (Slope2 < MaxSlope)

	fcomp	DWORD PTR _MaxSlope$[esp+320]
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 1
	je	$L79246

; 952  : 								{
; 953  : 									GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);

	mov	ecx, DWORD PTR -192+[esp+308]
	mov	edx, DWORD PTR -192+[esp+304]
	push	esi
	push	edi
	push	ecx
	push	edx
	call	DWORD PTR __imp__hypot
	fcom	DWORD PTR __real@4@00000000000000000000
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L80583
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR _DirX$[esp+304], 1065353216	; 3f800000H
	fstp	ST(0)
	mov	DWORD PTR _DirY$[esp+304], 0
	mov	DWORD PTR _dirtol$[esp+304], eax
	jmp	SHORT $L80584
$L80583:
	fld	DWORD PTR _SlopeX$[esp+304]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirX$[esp+304]
	fld	DWORD PTR _SlopeY$[esp+304]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirY$[esp+304]
	fmul	DWORD PTR [ebx+168]
	fmul	DWORD PTR _avgdz$[esp+304]
	fadd	DWORD PTR [ebx+164]
	fstp	DWORD PTR _dirtol$[esp+304]
$L80584:

; 954  : 									for (ir = 0; ir < tr.TriggerCount; ir++)

	mov	eax, DWORD PTR _tr$79214[esp+312]
	mov	DWORD PTR _ir$[esp+304], 0
	test	eax, eax
	jle	$L79246
	lea	ecx, DWORD PTR _tr$79214[esp+316]
	mov	DWORD PTR -168+[esp+304], ecx
$L79250:

; 955  : 									{
; 956  : 										int TriggerLayer = tr.Triggers[ir];

	mov	edx, DWORD PTR -168+[esp+304]

; 957  : 										float ldz = (tz - ZLayer[TriggerLayer]) * idz;

	mov	eax, DWORD PTR _ZLayer$[esp+304]
	fld	DWORD PTR _tz$[esp+304]
	mov	esi, DWORD PTR [edx]
	fsub	DWORD PTR [eax+esi*4]
	fmul	DWORD PTR _idz$[esp+304]

; 958  : 										float cdz = 1.0f - ldz;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	ST(0), ST(1)

; 959  : 										ExpX = ldz * gb.Xcm + cdz * gt.Xcm;

	fld	ST(1)
	fmul	DWORD PTR _gb$79248[esp+304]
	fld	ST(1)
	fmul	DWORD PTR _gt$79235[esp+304]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ExpX$[esp+304]

; 960  : 										ExpY = ldz * gb.Ycm + cdz * gt.Ycm;

	fxch	ST(1)
	fmul	DWORD PTR _gb$79248[esp+308]
	fxch	ST(1)
	fmul	DWORD PTR _gt$79235[esp+308]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ExpY$[esp+304]

; 961  : 										eix = (int)((ExpX - T.Win.Xmin) / T.DxCell);

	fld	DWORD PTR _ExpX$[esp+304]
	fsub	DWORD PTR [ebx+956]
	fdiv	DWORD PTR [ebx+972]
	call	__ftol

; 962  : 										eiy = (int)((ExpY - T.Win.Ymin) / T.DyCell);

	fld	DWORD PTR _ExpY$[esp+304]
	fsub	DWORD PTR [ebx+964]
	mov	edi, eax
	fdiv	DWORD PTR [ebx+976]
	call	__ftol

; 963  : 										IntGrain *pTrg = CellSpace[(TriggerLayer * ny + eiy) * nx + eix].FindGrain(ExpX, ExpY, DirX, DirY, dirtol, T.AlignTol);

	mov	ecx, DWORD PTR [ebx+164]
	mov	edx, DWORD PTR _dirtol$[esp+304]
	push	ecx
	mov	ecx, DWORD PTR _DirY$[esp+308]
	push	edx
	mov	edx, DWORD PTR _DirX$[esp+312]
	push	ecx
	mov	ecx, DWORD PTR _ExpY$[esp+316]
	push	edx
	push	ecx
	mov	ecx, esi
	mov	edx, DWORD PTR _ExpX$[esp+324]
	imul	ecx, DWORD PTR _ny$[esp+324]
	add	ecx, eax
	push	edx
	imul	ecx, DWORD PTR _nx$[esp+328]
	mov	edx, DWORD PTR _CellSpace$[esp+328]
	add	ecx, edi
	lea	ecx, DWORD PTR [edx+ecx*8]
	call	?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z ; Cell::FindGrain

; 964  : 										if (pTrg)

	test	eax, eax
	mov	DWORD PTR _pTrg$79258[esp+304], eax
	je	$L79251

; 965  : 										{
; 966  : 											memset(pTempGrains, 0, T.Layer * sizeof(Grain *));

	mov	ecx, DWORD PTR [ebx+992]
	mov	edi, DWORD PTR _pTempGrains$[esp+304]
	shl	ecx, 2
	mov	edx, ecx
	xor	eax, eax
	shr	ecx, 2
	rep stosd
	mov	ecx, edx

; 967  : 											float dz;
; 968  : 											int seqlength = 3;
; 969  : 
; 970  : 											pTempGrains[tr.TopLayer] = pT;
; 971  : 											pTempGrains[tr.BottomLayer] = pB;

	mov	edx, DWORD PTR _tr$79214[esp+308]
	and	ecx, 3
	mov	DWORD PTR _seqlength$79262[esp+304], 3
	rep stosb
	mov	ecx, DWORD PTR _pTempGrains$[esp+304]
	mov	edi, DWORD PTR _tr$79214[esp+304]
	mov	eax, DWORD PTR _pT$79230[esp+304]
	mov	DWORD PTR [ecx+edi*4], eax
	mov	eax, DWORD PTR _pB$79243[esp+304]
	mov	DWORD PTR [ecx+edx*4], eax

; 972  : 											pTempGrains[TriggerLayer] = pTrg;

	mov	edx, DWORD PTR _pTrg$79258[esp+304]

; 973  : 
; 974  : 											for (lay = tr.TopLayer + 1; lay < TriggerLayer; lay++)

	inc	edi
	mov	DWORD PTR [ecx+esi*4], edx
	cmp	edi, esi
	jge	$L79265
	lea	eax, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR -256+[esp+304], eax
	mov	eax, DWORD PTR _ZLayer$[esp+304]
	sub	eax, ecx
	mov	DWORD PTR -292+[esp+304], eax
	jmp	SHORT $L79263
$L80644:
	mov	eax, DWORD PTR -292+[esp+304]
$L79263:

; 975  : 											{
; 976  : 												dz = ZLayer[lay] - tz;
; 977  : 												ExpX = dz * SlopeX + gt.Xcm;
; 978  : 												ExpY = dz * SlopeY + gt.Ycm;
; 979  : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol)) seqlength++;

	mov	edx, DWORD PTR _dirtol$[esp+304]
	mov	ecx, DWORD PTR -256+[esp+304]
	push	0
	push	0
	fld	DWORD PTR [eax+ecx]
	fsub	DWORD PTR _tz$[esp+312]
	push	0
	push	0
	push	edx

; 1051 : 	return S_OK;

	mov	edx, DWORD PTR [ebx+952]
	mov	eax, DWORD PTR _DirY$[esp+324]
	imul	edx, edi
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+324]
	fadd	DWORD PTR _gt$79235[esp+328]
	mov	ecx, DWORD PTR _DirX$[esp+324]
	push	eax
	mov	eax, DWORD PTR _CellSpace$[esp+328]
	push	ecx
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	mov	ecx, ebx
	fmul	DWORD PTR _SlopeX$[esp+344]
	fadd	DWORD PTR _gt$79235[esp+344]
	fstp	DWORD PTR [esp]
	call	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
	mov	edx, DWORD PTR -256+[esp+304]
	test	eax, eax
	mov	DWORD PTR [edx], eax
	je	SHORT $L79264
	inc	DWORD PTR _seqlength$79262[esp+304]
$L79264:
	mov	ecx, DWORD PTR -256+[esp+304]
	inc	edi
	add	ecx, 4
	cmp	edi, esi
	mov	DWORD PTR -256+[esp+304], ecx
	jl	SHORT $L80644

; 973  : 
; 974  : 											for (lay = tr.TopLayer + 1; lay < TriggerLayer; lay++)

	mov	ecx, DWORD PTR _pTempGrains$[esp+304]
$L79265:

; 980  : 												};
; 981  : 											for (lay = TriggerLayer + 1; lay < tr.BottomLayer; lay++)

	mov	eax, DWORD PTR _tr$79214[esp+308]
	lea	edi, DWORD PTR [esi+1]
	cmp	edi, eax
	jge	$L79269
	mov	eax, DWORD PTR _ZLayer$[esp+304]
	lea	esi, DWORD PTR [ecx+edi*4]
	sub	eax, ecx
	mov	DWORD PTR -292+[esp+304], eax
	jmp	SHORT $L79267
$L80647:
	mov	eax, DWORD PTR -292+[esp+304]
$L79267:

; 982  : 											{
; 983  : 												dz = ZLayer[lay] - tz;

	fld	DWORD PTR [esi+eax]

; 984  : 												ExpX = dz * SlopeX + gt.Xcm;
; 985  : 												ExpY = dz * SlopeY + gt.Ycm;
; 986  : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol)) seqlength++;

	mov	eax, DWORD PTR _dirtol$[esp+304]
	push	0
	push	0
	push	0
	fsub	DWORD PTR _tz$[esp+316]
	push	0
	push	eax

; 1051 : 	return S_OK;

	mov	eax, DWORD PTR [ebx+952]
	mov	ecx, DWORD PTR _DirY$[esp+324]
	imul	eax, edi
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+324]
	fadd	DWORD PTR _gt$79235[esp+328]
	mov	edx, DWORD PTR _DirX$[esp+324]
	push	ecx
	mov	ecx, DWORD PTR _CellSpace$[esp+328]
	push	edx
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	mov	ecx, ebx
	fmul	DWORD PTR _SlopeX$[esp+344]
	fadd	DWORD PTR _gt$79235[esp+344]
	fstp	DWORD PTR [esp]
	call	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L79268
	inc	DWORD PTR _seqlength$79262[esp+304]
$L79268:
	mov	eax, DWORD PTR _tr$79214[esp+308]
	inc	edi
	add	esi, 4
	cmp	edi, eax
	jl	SHORT $L80647

; 980  : 												};
; 981  : 											for (lay = TriggerLayer + 1; lay < tr.BottomLayer; lay++)

	mov	ecx, DWORD PTR _pTempGrains$[esp+304]
$L79269:

; 987  : 												};
; 988  : 											Vector topv, bottomv;
; 989  : 											topv.X = pT->Xcm;

	mov	eax, DWORD PTR _pT$79230[esp+304]
	mov	edx, DWORD PTR [eax]

; 990  : 											topv.Y = pT->Ycm;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _topv$79271[esp+304], edx

; 991  : 											topv.Z = tz;

	mov	edx, DWORD PTR _tz$[esp+304]
	mov	DWORD PTR _topv$79271[esp+308], eax

; 992  : 											bottomv.X = pB->Xcm;

	mov	eax, DWORD PTR _pB$79243[esp+304]
	mov	DWORD PTR _topv$79271[esp+312], edx
	mov	edx, DWORD PTR [eax]

; 993  : 											bottomv.Y = pB->Ycm;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _bottomv$79272[esp+304], edx

; 994  : 											bottomv.Z = ZLayer[tr.BottomLayer];

	mov	edx, DWORD PTR _ZLayer$[esp+304]
	mov	DWORD PTR _bottomv$79272[esp+308], eax
	mov	eax, DWORD PTR _tr$79214[esp+308]
	fld	DWORD PTR [edx+eax*4]

; 995  : 											for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)

	mov	edx, DWORD PTR _tr$79214[esp+304]
	fstp	DWORD PTR _bottomv$79272[esp+312]
	lea	edi, DWORD PTR [edx-1]
	test	edi, edi
	jl	$L79276
	mov	eax, DWORD PTR _ZLayer$[esp+304]
	sub	ecx, eax
	lea	esi, DWORD PTR [eax+edi*4]
	mov	DWORD PTR -292+[esp+304], ecx
$L79274:

; 996  : 											{
; 997  : 												dz = (bottomv.Z - topv.Z);

	fld	DWORD PTR _bottomv$79272[esp+312]
	fsub	DWORD PTR _topv$79271[esp+312]

; 998  : 												SlopeX = (bottomv.X - topv.X) / dz;

	fld	DWORD PTR _bottomv$79272[esp+304]
	fsub	DWORD PTR _topv$79271[esp+304]

; 999  : 												SlopeY = (bottomv.Y - topv.Y) / dz;
; 1000 : 												GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);

	sub	esp, 8
	fdiv	ST(0), ST(1)
	sub	esp, 8
	fstp	DWORD PTR _SlopeX$[esp+320]
	fld	DWORD PTR _bottomv$79272[esp+324]
	fsub	DWORD PTR _topv$79271[esp+324]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _SlopeY$[esp+320]
	fstp	ST(0)
	fld	DWORD PTR _SlopeY$[esp+320]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR _SlopeX$[esp+320]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__hypot
	fcom	DWORD PTR __real@4@00000000000000000000
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L80595
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR _DirX$[esp+304], 1065353216	; 3f800000H
	fstp	ST(0)
	mov	DWORD PTR _DirY$[esp+304], 0
	mov	DWORD PTR _dirtol$[esp+304], eax
	jmp	SHORT $L80596
$L80595:
	fld	DWORD PTR _SlopeX$[esp+304]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirX$[esp+304]
	fld	DWORD PTR _SlopeY$[esp+304]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirY$[esp+304]
	fmul	DWORD PTR [ebx+168]
	fmul	DWORD PTR _avgdz$[esp+304]
	fadd	DWORD PTR [ebx+164]
	fstp	DWORD PTR _dirtol$[esp+304]
$L80596:

; 1001 : 												dz = ZLayer[lay] - topv.Z;
; 1002 : 												ExpX = dz * SlopeX + topv.X;
; 1003 : 												ExpY = dz * SlopeY + topv.Y;
; 1004 : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol))

	mov	ecx, DWORD PTR _dirtol$[esp+304]
	push	0
	fld	DWORD PTR [esi]
	push	0
	push	0
	fsub	DWORD PTR _topv$79271[esp+324]
	push	0
	push	ecx

; 1051 : 	return S_OK;

	mov	ecx, DWORD PTR [ebx+952]
	mov	edx, DWORD PTR _DirY$[esp+324]
	imul	ecx, edi
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+324]
	fadd	DWORD PTR _topv$79271[esp+328]
	mov	eax, DWORD PTR _DirX$[esp+324]
	push	edx
	mov	edx, DWORD PTR _CellSpace$[esp+328]
	push	eax
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	mov	ecx, ebx
	fmul	DWORD PTR _SlopeX$[esp+344]
	fadd	DWORD PTR _topv$79271[esp+344]
	fstp	DWORD PTR [esp]
	call	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
	mov	ecx, DWORD PTR -292+[esp+304]
	test	eax, eax
	mov	DWORD PTR [ecx+esi], eax
	je	SHORT $L79275
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _topv$79271[esp+308], eax
	mov	eax, DWORD PTR _seqlength$79262[esp+304]
	mov	DWORD PTR _topv$79271[esp+304], edx
	inc	eax
	mov	DWORD PTR _topv$79271[esp+312], ecx
	mov	DWORD PTR _seqlength$79262[esp+304], eax
$L79275:
	dec	edi
	sub	esi, 4
	test	edi, edi
	jge	$L79274

; 995  : 											for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)

	mov	ecx, DWORD PTR _pTempGrains$[esp+304]
$L79276:

; 1005 : 												{
; 1006 : 													topv.X = pTempGrains[lay]->Xcm;
; 1007 : 													topv.Y = pTempGrains[lay]->Ycm;
; 1008 : 													topv.Z = ZLayer[lay];
; 1009 : 													seqlength++;
; 1010 : 													}
; 1011 : 												};
; 1012 : 											for (lay = (int)tr.BottomLayer + 1; lay <= EndLayer; lay++)

	mov	edx, DWORD PTR _tr$79214[esp+308]
	mov	eax, DWORD PTR _EndLayer$[ebp]
	lea	edi, DWORD PTR [edx+1]
	cmp	edi, eax
	jg	$L79281
	mov	eax, DWORD PTR _ZLayer$[esp+304]
	sub	ecx, eax
	lea	esi, DWORD PTR [eax+edi*4]
	mov	DWORD PTR -292+[esp+304], ecx
$L79279:

; 1013 : 											{
; 1014 : 												dz = (bottomv.Z - topv.Z);

	fld	DWORD PTR _bottomv$79272[esp+312]
	fsub	DWORD PTR _topv$79271[esp+312]

; 1015 : 												SlopeX = (bottomv.X - topv.X) / dz;

	fld	DWORD PTR _bottomv$79272[esp+304]
	fsub	DWORD PTR _topv$79271[esp+304]

; 1016 : 												SlopeY = (bottomv.Y - topv.Y) / dz;
; 1017 : 												GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);

	sub	esp, 8
	fdiv	ST(0), ST(1)
	sub	esp, 8
	fstp	DWORD PTR _SlopeX$[esp+320]
	fld	DWORD PTR _bottomv$79272[esp+324]
	fsub	DWORD PTR _topv$79271[esp+324]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _SlopeY$[esp+320]
	fstp	ST(0)
	fld	DWORD PTR _SlopeY$[esp+320]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR _SlopeX$[esp+320]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__hypot
	fcom	DWORD PTR __real@4@00000000000000000000
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L80601
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR _DirX$[esp+304], 1065353216	; 3f800000H
	fstp	ST(0)
	mov	DWORD PTR _DirY$[esp+304], 0
	mov	DWORD PTR _dirtol$[esp+304], eax
	jmp	SHORT $L80602
$L80601:
	fld	DWORD PTR _SlopeX$[esp+304]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirX$[esp+304]
	fld	DWORD PTR _SlopeY$[esp+304]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _DirY$[esp+304]
	fmul	DWORD PTR [ebx+168]
	fmul	DWORD PTR _avgdz$[esp+304]
	fadd	DWORD PTR [ebx+164]
	fstp	DWORD PTR _dirtol$[esp+304]
$L80602:

; 1018 : 												dz = ZLayer[lay] - topv.Z;
; 1019 : 												ExpX = dz * SlopeX + topv.X;
; 1020 : 												ExpY = dz * SlopeY + topv.Y;
; 1021 : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol))

	mov	ecx, DWORD PTR _dirtol$[esp+304]
	push	0
	fld	DWORD PTR [esi]
	push	0
	push	0
	fsub	DWORD PTR _topv$79271[esp+324]
	push	0
	push	ecx

; 1051 : 	return S_OK;

	mov	ecx, DWORD PTR [ebx+952]
	mov	edx, DWORD PTR _DirY$[esp+324]
	imul	ecx, edi
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+324]
	fadd	DWORD PTR _topv$79271[esp+328]
	mov	eax, DWORD PTR _DirX$[esp+324]
	push	edx
	mov	edx, DWORD PTR _CellSpace$[esp+328]
	push	eax
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	mov	ecx, ebx
	fmul	DWORD PTR _SlopeX$[esp+344]
	fadd	DWORD PTR _topv$79271[esp+344]
	fstp	DWORD PTR [esp]
	call	?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ; CSmartTrackerClass::FindGrain
	mov	ecx, DWORD PTR -292+[esp+304]
	test	eax, eax
	mov	DWORD PTR [esi+ecx], eax
	je	SHORT $L79280
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _bottomv$79272[esp+308], eax
	mov	eax, DWORD PTR _seqlength$79262[esp+304]
	mov	DWORD PTR _bottomv$79272[esp+304], edx
	inc	eax
	mov	DWORD PTR _bottomv$79272[esp+312], ecx
	mov	DWORD PTR _seqlength$79262[esp+304], eax
$L79280:
	mov	eax, DWORD PTR _EndLayer$[ebp]
	inc	edi
	add	esi, 4
	cmp	edi, eax
	jle	$L79279

; 1005 : 												{
; 1006 : 													topv.X = pTempGrains[lay]->Xcm;
; 1007 : 													topv.Y = pTempGrains[lay]->Ycm;
; 1008 : 													topv.Z = ZLayer[lay];
; 1009 : 													seqlength++;
; 1010 : 													}
; 1011 : 												};
; 1012 : 											for (lay = (int)tr.BottomLayer + 1; lay <= EndLayer; lay++)

	mov	ecx, DWORD PTR _pTempGrains$[esp+304]
$L79281:

; 1022 : 												{
; 1023 : 													bottomv.X = pTempGrains[lay]->Xcm;
; 1024 : 													bottomv.Y = pTempGrains[lay]->Ycm;
; 1025 : 													bottomv.Z = ZLayer[lay];
; 1026 : 													seqlength++;
; 1027 : 													}
; 1028 : 												};
; 1029 : 											if ((float)seqlength > (tinf + td / (1.0f + tsl * Slope2)))

	fild	DWORD PTR _seqlength$79262[esp+304]
	fld	DWORD PTR _Slope2$[esp+304]
	fmul	DWORD PTR _tsl$[esp+304]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fdivr	DWORD PTR _td$[esp+304]
	fadd	DWORD PTR _tinf$[esp+304]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L80616
$L79251:

; 954  : 									for (ir = 0; ir < tr.TriggerCount; ir++)

	mov	eax, DWORD PTR _ir$[esp+304]
	mov	edx, DWORD PTR -168+[esp+304]
	mov	ecx, DWORD PTR _tr$79214[esp+312]
	inc	eax
	add	edx, 4
	cmp	eax, ecx
	mov	DWORD PTR _ir$[esp+304], eax
	mov	DWORD PTR -168+[esp+304], edx
	jl	$L79250

; 1022 : 												{
; 1023 : 													bottomv.X = pTempGrains[lay]->Xcm;
; 1024 : 													bottomv.Y = pTempGrains[lay]->Ycm;
; 1025 : 													bottomv.Z = ZLayer[lay];
; 1026 : 													seqlength++;
; 1027 : 													}
; 1028 : 												};
; 1029 : 											if ((float)seqlength > (tinf + td / (1.0f + tsl * Slope2)))

	jmp	SHORT $L79246
$L80616:

; 1030 : 											{
; 1031 : 												InsertNewTrack(pTempGrains, EndLayer + 1, seqlength, pSpace, NTracks);

	mov	esi, DWORD PTR _pSpace$[ebp]
	mov	eax, DWORD PTR _seqlength$79262[esp+304]
	lea	edx, DWORD PTR _NTracks$[esp+304]
	push	edx
	mov	edx, DWORD PTR _EndLayer$[ebp]
	push	esi
	push	eax
	lea	eax, DWORD PTR [edx+1]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z ; CSmartTrackerClass::InsertNewTrack

; 1032 : 												if (NTracks >= *pMaxNumber)

	mov	edi, DWORD PTR _pMaxNumber$[ebp]
	mov	eax, DWORD PTR _NTracks$[esp+304]
	cmp	eax, DWORD PTR [edi]
	jl	SHORT $L79246

; 1033 : 												{
; 1034 : 													*pMaxNumber = FinalizeTracks(NTracks, pSpace);

	push	esi
	push	eax
	mov	ecx, ebx
	call	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z ; CSmartTrackerClass::FinalizeTracks
	mov	DWORD PTR [edi], eax

; 1035 : 													free(pTempGrains);

	mov	eax, DWORD PTR _pTempGrains$[esp+304]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$L79246:
	mov	eax, DWORD PTR _pB$79243[esp+304]
	mov	ecx, DWORD PTR _pBE$79244[esp+304]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	mov	DWORD PTR _pB$79243[esp+304], eax
	jb	$L80635
	mov	edx, DWORD PTR _nx$[esp+304]
	mov	ecx, DWORD PTR -136+[esp+304]
	mov	eax, DWORD PTR -120+[esp+304]
$L79240:
	lea	esi, DWORD PTR [edx*8]
	add	ecx, esi
	dec	eax
	mov	DWORD PTR -136+[esp+304], ecx
	mov	DWORD PTR -120+[esp+304], eax
	jne	$L79239
	mov	ecx, DWORD PTR _iix$[esp+304]
	mov	eax, DWORD PTR _miniy$[esp+304]
$L79237:
	mov	esi, DWORD PTR _maxix$[esp+304]
	inc	ecx
	cmp	ecx, esi
	mov	DWORD PTR _iix$[esp+304], ecx
	jle	$L79236
$L79233:

; 936  : 				for (;pT < pTE; pT++)

	mov	ecx, DWORD PTR _pT$79230[esp+304]
	mov	esi, DWORD PTR _pTE$79231[esp+304]
	add	ecx, 20					; 00000014H
	cmp	ecx, esi
	mov	DWORD PTR _pT$79230[esp+304], ecx
	jb	$L80652
	mov	ecx, DWORD PTR -128+[esp+304]
$L80653:

; 929  : 			for (iy = 0; iy < ny; iy++)

	mov	edi, DWORD PTR -140+[esp+304]

; 936  : 				for (;pT < pTE; pT++)

	mov	esi, DWORD PTR _ny$[esp+304]
	inc	ecx
	lea	eax, DWORD PTR [edx*8]
	add	edi, eax
	mov	DWORD PTR -128+[esp+304], ecx
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR -140+[esp+304], edi
	cmp	eax, esi
	jl	$L79224

; 929  : 			for (iy = 0; iy < ny; iy++)

	mov	eax, DWORD PTR -124+[esp+304]
$L79220:

; 924  : 
; 925  : 		for (ix = 0; ix < nx; ix++)

	mov	edi, DWORD PTR -212+[esp+304]
	inc	eax
	add	edi, 8
	mov	DWORD PTR -124+[esp+304], eax
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR -212+[esp+304], edi
	cmp	ecx, edx
	jl	$L79219
$L79212:

; 911  : 			
; 912  : 	float tsl = 10.0f * (T.NptMinV - T.NptMin01) / (T.NptMin01 - T.NptMinH);
; 913  : 	float tinf = (float)(T.NptMinH);
; 914  : 	float td = (float)(T.NptMinV - T.NptMinH);
; 915  : 
; 916  : 	for (itr = 0; itr < T.TrialCount; itr++)

	mov	eax, DWORD PTR _itr$[esp+304]
	mov	esi, DWORD PTR -216+[esp+304]
	mov	ecx, DWORD PTR [ebx+172]
	inc	eax
	add	esi, 44					; 0000002cH
	cmp	eax, ecx
	mov	DWORD PTR _itr$[esp+304], eax
	mov	DWORD PTR -216+[esp+304], esi
	jl	$L80656
$L79213:

; 1036 : 													}
; 1037 : 												break;
; 1038 : 												}
; 1039 : 											}
; 1040 : 										}
; 1041 : 									}
; 1042 : 								}
; 1043 : 							}
; 1044 : 					}
; 1045 : 				}
; 1046 : 			}
; 1047 : 		}
; 1048 : 
; 1049 : 	*pMaxNumber = FinalizeTracks(NTracks, pSpace);

	mov	edx, DWORD PTR _pSpace$[ebp]
	mov	eax, DWORD PTR _NTracks$[esp+304]
	push	edx
	push	eax
	mov	ecx, ebx
	call	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z ; CSmartTrackerClass::FinalizeTracks
	mov	ecx, DWORD PTR _pMaxNumber$[ebp]

; 1050 : 	free(pTempGrains);

	mov	edx, DWORD PTR _pTempGrains$[esp+304]
	push	edx
	mov	DWORD PTR [ecx], eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 1051 : 	return S_OK;

	xor	eax, eax

; 1052 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetTracks@CSmartTrackerClass@@UAGJPAUTrack@@PAHHH@Z ENDP ; CSmartTrackerClass::GetTracks
_TEXT	ENDS
PUBLIC	?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z ; CSmartTrackerClass::GetClusters
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT ??_R0H@8
; File D:\SySal2\SmartTracker8\SmartTrackerClass.cpp
_DATA	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
_DATA	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T80665	DD	019930520H
	DD	02H
	DD	FLAT:$T80672
	DD	01H
	DD	FLAT:$T80673
	DD	2 DUP(00H)
	ORG $+4
$T80672	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T80673	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T80674
	ORG $+4
$T80674	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L80663
xdata$x	ENDS
;	COMDAT ?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z
_TEXT	SEGMENT
_Layer$ = 12
_pSpace$ = 16
_pMaxNumber$ = 20
_pZ$ = 24
_this$ = 8
_MaxNumber$ = -20
_i$ = 12
_ccount$ = 24
_pCells$ = -28
_TCell$79308 = -36
$T80660 = -24
__$EHRec$ = -16
?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z PROC NEAR ; CSmartTrackerClass::GetClusters, COMDAT

; 1055 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80670
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi

; 1056 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1057 : 
; 1058 : 	// TODO: Add your implementation code here	
; 1059 : 	if (!OkToRun) return S_FALSE;	

	mov	edi, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	BYTE PTR [edi+1076], cl
	jne	SHORT $L79294
	mov	eax, 1

; 1085 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L79294:

; 1060 : 	if (Layer < 0 || Layer >= T.LayerNum) return E_INVALIDARG;

	mov	eax, DWORD PTR _Layer$[ebp]
	cmp	eax, ecx
	jl	$L79297
	cmp	eax, DWORD PTR [edi+140]
	jge	$L79297

; 1061 : 	int MaxNumber = *pMaxNumber;

	mov	edx, DWORD PTR _pMaxNumber$[ebp]

; 1062 : 	*pZ = T.ZLayer[Layer];
; 1063 : 	int i, j, ccount = 0;

	xor	ebx, ebx

; 1064 : 	Cell *pCells = T.CellSpace;
; 1065 : 	try
; 1066 : 	{

	mov	DWORD PTR __$EHRec$[ebp+12], ecx
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _MaxNumber$[ebp], edx
	mov	edx, DWORD PTR [edi+940]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _pZ$[ebp]
	mov	DWORD PTR _ccount$[ebp], ebx
	mov	DWORD PTR [edx], eax
	mov	esi, DWORD PTR [edi+948]

; 1067 : 		for (i = 0; i < T.CellsInLayer; i++)

	mov	eax, DWORD PTR _pSpace$[ebp]
	xor	edx, edx
	mov	DWORD PTR _pCells$[ebp], esi
	mov	DWORD PTR _i$[ebp], edx
$L79305:
	cmp	edx, DWORD PTR [edi+952]
	jge	SHORT $L79307

; 1068 : 		{
; 1069 : 			Cell TCell = pCells[i];

	mov	edi, DWORD PTR [esi+edx*8]
	mov	esi, DWORD PTR [esi+edx*8+4]
	mov	DWORD PTR _TCell$79308[ebp+4], esi

; 1070 : 			for (j = 0; j < TCell.Free; j++)

	xor	esi, esi
$L79309:
	cmp	esi, DWORD PTR _TCell$79308[ebp+4]
	jge	SHORT $L79306

; 1071 : 			{
; 1072 : 				pSpace->X = TCell.FirstG[j].Xcm;

	lea	edx, DWORD PTR [esi+esi*4]

; 1073 : 				pSpace->Y = TCell.FirstG[j].Ycm;
; 1074 : 				pSpace->Area = 0;
; 1075 : 				pSpace->GrayLevel = 0;
; 1076 : 				pSpace->Inertia.IXX = pSpace->Inertia.IYY = pSpace->Inertia.IXY = 0;
; 1077 : 				pSpace++;

	add	eax, 40					; 00000028H
	mov	ebx, DWORD PTR [edi+edx*4]
	lea	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [eax-40], ebx

; 1078 : 				if (ccount >= MaxNumber) throw ccount;

	mov	ebx, DWORD PTR _ccount$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax-20], ecx
	mov	DWORD PTR [eax-36], edx
	mov	edx, DWORD PTR _MaxNumber$[ebp]
	mov	DWORD PTR [eax-12], ecx
	mov	DWORD PTR [eax-28], ecx
	mov	DWORD PTR [eax-32], ecx
	mov	DWORD PTR [eax-4], ecx
	mov	DWORD PTR [eax-16], ecx
	mov	DWORD PTR [eax-8], ecx
	mov	DWORD PTR [eax-24], ecx
	cmp	ebx, edx
	jl	SHORT $L79310
	lea	eax, DWORD PTR $T80660[ebp]
	push	OFFSET FLAT:__TI1H
	push	eax
	mov	DWORD PTR $T80660[ebp], ebx
	call	__CxxThrowException@8
$L80663:

; 1079 : 				};
; 1080 : 			}
; 1081 : 		}
; 1082 : 	catch (...) {};

	mov	eax, $L80668
	ret	0
$L79310:
	mov	edx, DWORD PTR _i$[ebp]
	inc	esi
	jmp	SHORT $L79309
$L79306:

; 1067 : 		for (i = 0; i < T.CellsInLayer; i++)

	mov	esi, DWORD PTR _pCells$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $L79305
$L80668:
	mov	ebx, DWORD PTR _ccount$[ebp]
$L79307:

; 1083 : 	*pMaxNumber = ccount;

	mov	ecx, DWORD PTR _pMaxNumber$[ebp]

; 1084 : 	return S_OK;

	xor	eax, eax
	mov	DWORD PTR [ecx], ebx

; 1085 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L79297:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	eax, -2147024809			; 80070057H
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L80671:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80670:
	mov	eax, OFFSET FLAT:$T80665
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClusters@CSmartTrackerClass@@UAGJHPAUCluster@@PAHPAM@Z ENDP ; CSmartTrackerClass::GetClusters
PUBLIC	?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z	; CSmartTrackerClass::PresetSlope
;	COMDAT ?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z
_TEXT	SEGMENT
?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z PROC NEAR	; CSmartTrackerClass::PresetSlope, COMDAT

; 1089 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1090 : 
; 1091 : 	// TODO: Add your implementation code here
; 1092 : 
; 1093 : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 1094 : }

	ret	20					; 00000014H
?PresetSlope@CSmartTrackerClass@@UAGJMMMM@Z ENDP	; CSmartTrackerClass::PresetSlope
_TEXT	ENDS
PUBLIC	?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z ; CSmartTrackerClass::EnableSlopePresetting
;	COMDAT ?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z
_TEXT	SEGMENT
_SlPresEnable$ = 12
?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z PROC NEAR ; CSmartTrackerClass::EnableSlopePresetting, COMDAT

; 1098 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1099 : 
; 1100 : 	// TODO: Add your implementation code here
; 1101 : 	if (SlPresEnable) return E_INVALIDARG;

	mov	al, BYTE PTR _SlPresEnable$[esp-4]
	neg	al
	sbb	eax, eax
	and	eax, -2147024809			; 80070057H

; 1102 : 	return S_OK;
; 1103 : }

	ret	8
?EnableSlopePresetting@CSmartTrackerClass@@UAGJE@Z ENDP	; CSmartTrackerClass::EnableSlopePresetting
_TEXT	ENDS
PUBLIC	?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z ; CSmartTrackerClass::GetSlopePresetStatus
;	COMDAT ?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z
_TEXT	SEGMENT
_pSlPresEnable$ = 12
?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z PROC NEAR ; CSmartTrackerClass::GetSlopePresetStatus, COMDAT

; 1107 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1108 : 
; 1109 : 	// TODO: Add your implementation code here
; 1110 : 	*pSlPresEnable = false;

	mov	eax, DWORD PTR _pSlPresEnable$[esp-4]
	mov	BYTE PTR [eax], 0

; 1111 : 	return S_OK;

	xor	eax, eax

; 1112 : }

	ret	8
?GetSlopePresetStatus@CSmartTrackerClass@@UAGJPAE@Z ENDP ; CSmartTrackerClass::GetSlopePresetStatus
_TEXT	ENDS
PUBLIC	?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z ; CSmartTrackerClass::GetFlatTracks
;	COMDAT ?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z
_TEXT	SEGMENT
_pMaxNumber$ = 16
?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z PROC NEAR ; CSmartTrackerClass::GetFlatTracks, COMDAT

; 1116 : 	*pMaxNumber = 0;

	mov	eax, DWORD PTR _pMaxNumber$[esp-4]
	mov	DWORD PTR [eax], 0

; 1117 : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 1118 : 	};

	ret	24					; 00000018H
?GetFlatTracks@CSmartTrackerClass@@UAGJPAUFlatTrack@@PAHHHH@Z ENDP ; CSmartTrackerClass::GetFlatTracks
_TEXT	ENDS
PUBLIC	?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z ; CSmartTrackerClass::GetFlatStrips
;	COMDAT ?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z
_TEXT	SEGMENT
_pMaxNumber$ = 20
?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z PROC NEAR ; CSmartTrackerClass::GetFlatStrips, COMDAT

; 1122 : 	*pMaxNumber = 0;

	mov	eax, DWORD PTR _pMaxNumber$[esp-4]
	mov	DWORD PTR [eax], 0

; 1123 : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 1124 : 	};

	ret	20					; 00000014H
?GetFlatStrips@CSmartTrackerClass@@UAGJHPAUFlatStrip@@PAHPAM@Z ENDP ; CSmartTrackerClass::GetFlatStrips
_TEXT	ENDS
PUBLIC	?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z ; CSmartTrackerClass::GetDirAndTol
;	COMDAT ?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z
_TEXT	SEGMENT
_SlopeX$ = 8
_SlopeY$ = 12
_avgdz$ = 16
_pDirX$ = 20
_pDirY$ = 24
_pdirtol$ = 28
?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z PROC NEAR ; CSmartTrackerClass::GetDirAndTol, COMDAT

; 1132 : 	float slope2 = (float)hypot(SlopeX, SlopeY);

	fld	DWORD PTR _SlopeY$[esp-4]
	push	esi
	mov	esi, ecx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _SlopeX$[esp+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__hypot

; 1133 : 	if (slope2 <= 0.0f)

	fcom	DWORD PTR __real@4@00000000000000000000
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L79369

; 1134 : 	{
; 1135 : 		*pDirX = 1.0f;

	mov	eax, DWORD PTR _pDirX$[esp]

; 1136 : 		*pDirY = 0.0f;

	mov	ecx, DWORD PTR _pDirY$[esp]
	fstp	ST(0)
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 1137 : 		*pdirtol = T.AlignTol;					

	mov	eax, DWORD PTR _pdirtol$[esp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [esi+164]
	mov	DWORD PTR [eax], edx
	pop	esi

; 1144 : 	}
; 1145 : };

	ret	24					; 00000018H
$L79369:

; 1138 : 	}
; 1139 : 	else
; 1140 : 	{
; 1141 : 		*pDirX = SlopeX / slope2;

	fld	DWORD PTR _SlopeX$[esp]
	fdiv	ST(0), ST(1)
	mov	ecx, DWORD PTR _pDirX$[esp]

; 1142 : 		*pDirY = SlopeY / slope2;

	mov	edx, DWORD PTR _pDirY$[esp]

; 1143 : 		*pdirtol = T.AlignTol + avgdz * slope2 * T.LongitTolMultiplier;

	mov	eax, DWORD PTR _pdirtol$[esp]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR _SlopeY$[esp]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR [edx]
	fmul	DWORD PTR [esi+168]
	fmul	DWORD PTR _avgdz$[esp]
	fadd	DWORD PTR [esi+164]
	pop	esi
	fstp	DWORD PTR [eax]

; 1144 : 	}
; 1145 : };

	ret	24					; 00000018H
?GetDirAndTol@CSmartTrackerClass@@IAEXMMMPAM00@Z ENDP	; CSmartTrackerClass::GetDirAndTol
_TEXT	ENDS
PUBLIC	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
;	COMDAT ?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z
_TEXT	SEGMENT
_expx$ = 8
_expy$ = 12
_pCellLayer$ = 16
_dirx$ = 20
_diry$ = 24
_dirtol$ = 28
_pTopShadow$ = 32
_pBottomShadow$ = 36
_xshadowtol$ = 40
_yshadowtol$ = 44
_fix$ = -12
_fiy$ = -16
_eix$ = -8
_eiy$ = -4
?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z PROC NEAR ; CSmartTrackerClass::FindGrain, COMDAT

; 1166 : {

	sub	esp, 16					; 00000010H

; 1167 : 	float fix, fiy;
; 1168 : 	int eix = (int)(fix = ((expx - T.Win.Xmin) / T.DxCell));

	fld	DWORD PTR _expx$[esp+12]
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	fsub	DWORD PTR [esi+956]
	fdiv	DWORD PTR [esi+972]
	fst	DWORD PTR _fix$[esp+32]
	call	__ftol
	mov	ebx, eax

; 1169 : 	if (eix < 0 || eix >= T.CellNumX) return 0;

	test	ebx, ebx
	mov	DWORD PTR _eix$[esp+32], ebx
	jl	$L79402
	mov	ebp, DWORD PTR [esi+148]
	cmp	ebx, ebp
	jge	$L79402

; 1170 : 	int eiy = (int)(fiy = ((expy - T.Win.Ymin) / T.DyCell));

	fld	DWORD PTR _expy$[esp+28]
	fsub	DWORD PTR [esi+964]
	fdiv	DWORD PTR [esi+976]
	fst	DWORD PTR _fiy$[esp+32]
	call	__ftol
	mov	edi, eax

; 1171 : 	if (eiy >= 0 && eiy < T.CellNumY)

	test	edi, edi
	mov	DWORD PTR _eiy$[esp+32], edi
	jl	$L79402
	cmp	edi, DWORD PTR [esi+152]
	jge	$L79402

; 1172 : 	{
; 1173 : 		IntGrain *pNew = pCellLayer[eiy * T.CellNumX + eix].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	mov	eax, DWORD PTR _yshadowtol$[esp+28]
	mov	ecx, DWORD PTR _xshadowtol$[esp+28]
	mov	edx, DWORD PTR _pBottomShadow$[esp+28]
	imul	ebp, edi
	push	eax
	mov	eax, DWORD PTR _pTopShadow$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [esi+164]
	push	edx
	mov	edx, DWORD PTR _dirtol$[esp+40]
	push	eax
	mov	eax, DWORD PTR _diry$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _dirx$[esp+48]
	push	edx
	mov	edx, DWORD PTR _expy$[esp+52]
	push	eax
	mov	eax, DWORD PTR _expx$[esp+56]
	push	ecx
	mov	ecx, DWORD PTR _pCellLayer$[esp+60]
	add	ebp, ebx
	push	edx
	push	eax
	lea	ecx, DWORD PTR [ecx+ebp*8]
	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow

; 1174 : 		if (pNew) return pNew;

	test	eax, eax
	jne	$L79383

; 1175 : 		fix -= (0.5f + eix);

	fild	DWORD PTR _eix$[esp+32]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	fsubr	DWORD PTR _fix$[esp+32]

; 1176 : 		fiy -= (0.5f + eiy);

	fild	DWORD PTR _eiy$[esp+32]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	fsubr	DWORD PTR _fiy$[esp+32]
	fstp	DWORD PTR _fiy$[esp+32]

; 1177 : 		if (fabs(fix) >= fabs(fiy))

	fld	ST(0)
	fabs
	fld	DWORD PTR _fiy$[esp+32]
	fabs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L79395

; 1178 : 		{
; 1179 : 			if (fix < 0.0f && eix > 0)

	fcom	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79396
	test	ebx, ebx
	jle	SHORT $L79396

; 1180 : 				return pCellLayer[eiy * T.CellNumX + eix - 1].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	imul	edi, DWORD PTR [esi+148]
	fstp	ST(0)
	mov	edx, DWORD PTR _yshadowtol$[esp+28]
	mov	eax, DWORD PTR _xshadowtol$[esp+28]
	mov	ecx, DWORD PTR _pBottomShadow$[esp+28]
	push	edx
	mov	edx, DWORD PTR _pTopShadow$[esp+32]
	push	eax
	mov	eax, DWORD PTR [esi+164]
	push	ecx
	mov	ecx, DWORD PTR _dirtol$[esp+40]
	push	edx
	mov	edx, DWORD PTR _diry$[esp+44]
	push	eax
	mov	eax, DWORD PTR _dirx$[esp+48]
	push	ecx
	mov	ecx, DWORD PTR _expy$[esp+52]
	push	edx
	mov	edx, DWORD PTR _expx$[esp+56]
	push	eax
	mov	eax, DWORD PTR _pCellLayer$[esp+60]
	add	edi, ebx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [eax+edi*8-8]
	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1190 : 			}
; 1191 : 		}
; 1192 : 	return 0;
; 1193 : 	}

	add	esp, 16					; 00000010H
	ret	40					; 00000028H
$L79396:

; 1181 : 			else if (fix > 0.0f && eix < (T.CellNumX - 1))

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L79402
	mov	eax, DWORD PTR [esi+148]
	lea	ecx, DWORD PTR [eax-1]
	cmp	ebx, ecx
	jge	$L79402

; 1182 : 				return pCellLayer[eiy * T.CellNumX + eix + 1].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	mov	edx, DWORD PTR _yshadowtol$[esp+28]
	mov	ecx, DWORD PTR _xshadowtol$[esp+28]
	push	edx
	mov	edx, DWORD PTR _pBottomShadow$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR _pTopShadow$[esp+36]
	imul	eax, edi
	push	edx
	mov	edx, DWORD PTR [esi+164]
	push	ecx
	mov	ecx, DWORD PTR _dirtol$[esp+44]
	push	edx
	mov	edx, DWORD PTR _diry$[esp+48]
	push	ecx
	mov	ecx, DWORD PTR _dirx$[esp+52]
	push	edx
	mov	edx, DWORD PTR _expy$[esp+56]
	push	ecx
	mov	ecx, DWORD PTR _expx$[esp+60]
	push	edx
	mov	edx, DWORD PTR _pCellLayer$[esp+64]
	add	eax, ebx
	push	ecx
	lea	ecx, DWORD PTR [edx+eax*8+8]
	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1190 : 			}
; 1191 : 		}
; 1192 : 	return 0;
; 1193 : 	}

	add	esp, 16					; 00000010H
	ret	40					; 00000028H
$L79395:

; 1177 : 		if (fabs(fix) >= fabs(fiy))

	fstp	ST(0)

; 1183 : 			}
; 1184 : 		else
; 1185 : 		{
; 1186 : 			if (fiy < 0.0f && eiy > 0)

	fld	DWORD PTR _fiy$[esp+32]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79400
	test	edi, edi
	jle	SHORT $L79400

; 1187 : 				return pCellLayer[(eiy - 1) * T.CellNumX + eix].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	mov	eax, DWORD PTR _yshadowtol$[esp+28]
	mov	ecx, DWORD PTR _xshadowtol$[esp+28]
	mov	edx, DWORD PTR _pBottomShadow$[esp+28]
	dec	edi
	imul	edi, DWORD PTR [esi+148]
	push	eax
	mov	eax, DWORD PTR _pTopShadow$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [esi+164]
	push	edx
	mov	edx, DWORD PTR _dirtol$[esp+40]
	push	eax
	mov	eax, DWORD PTR _diry$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _dirx$[esp+48]
	push	edx
	mov	edx, DWORD PTR _expy$[esp+52]
	push	eax
	mov	eax, DWORD PTR _expx$[esp+56]
	push	ecx
	mov	ecx, DWORD PTR _pCellLayer$[esp+60]
	add	edi, ebx
	push	edx
	push	eax
	lea	ecx, DWORD PTR [ecx+edi*8]
	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1190 : 			}
; 1191 : 		}
; 1192 : 	return 0;
; 1193 : 	}

	add	esp, 16					; 00000010H
	ret	40					; 00000028H
$L79400:

; 1188 : 			else if (fiy > 0.0f && eiy < (T.CellNumX - 1))

	fld	DWORD PTR _fiy$[esp+32]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79402
	mov	eax, DWORD PTR [esi+148]
	lea	edx, DWORD PTR [eax-1]
	cmp	edi, edx
	jge	SHORT $L79402

; 1189 : 				return pCellLayer[(eiy + 1) * T.CellNumX + eix].FindGrainNoShadow(expx, expy, dirx, diry, dirtol, T.AlignTol, pTopShadow, pBottomShadow, xshadowtol, yshadowtol);

	mov	ecx, DWORD PTR _yshadowtol$[esp+28]
	mov	edx, DWORD PTR _xshadowtol$[esp+28]
	inc	edi
	push	ecx
	mov	ecx, DWORD PTR _pBottomShadow$[esp+32]
	imul	edi, eax
	push	edx
	mov	edx, DWORD PTR _pTopShadow$[esp+36]
	mov	eax, DWORD PTR _pCellLayer$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [esi+164]
	push	edx
	mov	edx, DWORD PTR _dirtol$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _diry$[esp+48]
	push	edx
	mov	edx, DWORD PTR _dirx$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR _expy$[esp+56]
	push	edx
	mov	edx, DWORD PTR _expx$[esp+60]
	add	edi, ebx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [eax+edi*8]
	call	?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ; Cell::FindGrainNoShadow
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1190 : 			}
; 1191 : 		}
; 1192 : 	return 0;
; 1193 : 	}

	add	esp, 16					; 00000010H
	ret	40					; 00000028H
$L79402:

; 1169 : 	if (eix < 0 || eix >= T.CellNumX) return 0;

	xor	eax, eax
$L79383:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1190 : 			}
; 1191 : 		}
; 1192 : 	return 0;
; 1193 : 	}

	add	esp, 16					; 00000010H
	ret	40					; 00000028H
?FindGrain@CSmartTrackerClass@@IAEPAUIntGrain@@MMPAUCell@@MMMPAU2@1MM@Z ENDP ; CSmartTrackerClass::FindGrain
_TEXT	ENDS
PUBLIC	?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z ; CSmartTrackerClass::FindGrains
PUBLIC	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains
;	COMDAT ?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z
_TEXT	SEGMENT
_expx$ = 8
_expy$ = 12
_pCellLayer$ = 16
_dirx$ = 20
_diry$ = 24
_dirtol$ = 28
_pGrainDest$ = 32
_maxmult$ = 36
_pOut$ = -64
_Dist$ = -128
_fix$ = -144
_fiy$ = -148
_eix$ = -140
_eiy$ = -136
?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z PROC NEAR ; CSmartTrackerClass::FindGrains, COMDAT

; 1196 : {

	sub	esp, 148				; 00000094H
	push	ebx
	push	ebp

; 1197 : 
; 1198 : #define MAXMULT 16
; 1199 : 
; 1200 : 	IntGrain *pOut[MAXMULT];
; 1201 : 	float Dist[MAXMULT];
; 1202 : 	if (maxmult > MAXMULT) maxmult = MAXMULT;

	mov	ebp, DWORD PTR _maxmult$[esp+152]
	push	esi
	cmp	ebp, 16					; 00000010H
	push	edi
	mov	esi, ecx
	jle	SHORT $L79416
	mov	ebp, 16					; 00000010H
$L79416:

; 1203 : 	int i;
; 1204 : 	for (i = 0; i < maxmult; Dist[i++] = T.AlignTol);

	test	ebp, ebp
	jle	SHORT $L79418
	mov	eax, DWORD PTR [esi+164]
	mov	ecx, ebp
	lea	edi, DWORD PTR _Dist$[esp+164]
	mov	DWORD PTR -144+[esp+164], eax
	rep stosd
$L79418:

; 1205 : 	float fix, fiy;
; 1206 : 	int eix = (int)(fix = ((expx - T.Win.Xmin) / T.DxCell));

	fld	DWORD PTR _expx$[esp+160]
	fsub	DWORD PTR [esi+956]
	fdiv	DWORD PTR [esi+972]
	fst	DWORD PTR _fix$[esp+164]
	call	__ftol
	mov	ebx, eax

; 1207 : 	if (eix < 0 || eix >= T.CellNumX) return 0;

	test	ebx, ebx
	mov	DWORD PTR _eix$[esp+164], ebx
	jl	$L79426
	mov	eax, DWORD PTR [esi+148]
	cmp	ebx, eax
	mov	DWORD PTR -132+[esp+164], eax
	jge	$L79426

; 1208 : 	int eiy = (int)(fiy = ((expy - T.Win.Ymin) / T.DyCell));

	fld	DWORD PTR _expy$[esp+160]
	fsub	DWORD PTR [esi+964]
	fdiv	DWORD PTR [esi+976]
	fst	DWORD PTR _fiy$[esp+164]
	call	__ftol
	mov	edi, eax

; 1209 : 	if (eiy >= 0 && eiy < T.CellNumY)

	test	edi, edi
	mov	DWORD PTR _eiy$[esp+164], edi
	jl	$L79437
	cmp	edi, DWORD PTR [esi+152]
	jge	$L79437

; 1210 : 	{
; 1211 : 		pCellLayer[eiy * T.CellNumX + eix].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	mov	eax, DWORD PTR [esi+164]
	lea	ecx, DWORD PTR _Dist$[esp+164]
	push	ebp
	lea	edx, DWORD PTR _pOut$[esp+168]
	push	ecx
	mov	ecx, DWORD PTR _dirtol$[esp+168]
	push	edx
	mov	edx, DWORD PTR _diry$[esp+172]
	push	eax
	mov	eax, DWORD PTR _dirx$[esp+176]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR -132+[esp+192]
	mov	ecx, DWORD PTR _expy$[esp+188]
	imul	eax, edi
	mov	edx, DWORD PTR _expx$[esp+188]
	push	ecx
	mov	ecx, DWORD PTR _pCellLayer$[esp+192]
	add	eax, ebx
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*8]
	call	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains

; 1212 : 		fix -= (0.5f + eix);

	fild	DWORD PTR _eix$[esp+164]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	fsubr	DWORD PTR _fix$[esp+164]

; 1213 : 		fiy -= (0.5f + eiy);

	fild	DWORD PTR _eiy$[esp+164]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	fsubr	DWORD PTR _fiy$[esp+164]
	fstp	DWORD PTR _fiy$[esp+164]

; 1214 : 		if (fabs(fix) >= fabs(fiy))

	fld	ST(0)
	fabs
	fld	DWORD PTR _fiy$[esp+164]
	fabs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L79430

; 1215 : 		{
; 1216 : 			if (fix < 0.0f && eix > 0)

	fcom	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79431
	test	ebx, ebx
	jle	SHORT $L79431

; 1217 : 				pCellLayer[eiy * T.CellNumX + eix - 1].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	mov	ecx, DWORD PTR [esi+164]
	lea	edx, DWORD PTR _Dist$[esp+164]
	push	ebp
	lea	eax, DWORD PTR _pOut$[esp+168]
	push	edx
	mov	edx, DWORD PTR _dirtol$[esp+168]
	push	eax
	mov	eax, DWORD PTR _diry$[esp+172]
	push	ecx
	mov	ecx, DWORD PTR _dirx$[esp+176]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+148]
	mov	edx, DWORD PTR _expy$[esp+188]
	imul	ecx, edi
	fstp	ST(0)
	mov	eax, DWORD PTR _expx$[esp+188]
	push	edx
	mov	edx, DWORD PTR _pCellLayer$[esp+192]
	add	ecx, ebx
	push	eax
	lea	ecx, DWORD PTR [edx+ecx*8-8]

; 1218 : 			else if (fix > 0.0f && eix < (T.CellNumX - 1))

	jmp	$L80697
$L79431:
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L79437
	mov	eax, DWORD PTR [esi+148]
	lea	ecx, DWORD PTR [eax-1]
	cmp	ebx, ecx
	jge	$L79437

; 1219 : 				pCellLayer[eiy * T.CellNumX + eix + 1].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	lea	edx, DWORD PTR _Dist$[esp+164]
	push	ebp
	imul	eax, edi
	push	edx
	mov	edx, DWORD PTR [esi+164]
	lea	ecx, DWORD PTR _pOut$[esp+172]
	add	eax, ebx
	push	ecx
	mov	ecx, DWORD PTR _dirtol$[esp+172]
	push	edx
	mov	edx, DWORD PTR _diry$[esp+176]
	push	ecx
	mov	ecx, DWORD PTR _dirx$[esp+180]
	push	edx
	mov	edx, DWORD PTR _expy$[esp+184]
	push	ecx
	mov	ecx, DWORD PTR _expx$[esp+188]
	push	edx
	mov	edx, DWORD PTR _pCellLayer$[esp+192]
	push	ecx
	lea	ecx, DWORD PTR [edx+eax*8+8]

; 1220 : 			}
; 1221 : 		else

	jmp	$L80697
$L79430:

; 1214 : 		if (fabs(fix) >= fabs(fiy))

	fstp	ST(0)

; 1222 : 		{
; 1223 : 			if (fiy < 0.0f && eiy > 0)

	fld	DWORD PTR _fiy$[esp+164]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79435
	test	edi, edi
	jle	SHORT $L79435

; 1224 : 				pCellLayer[(eiy - 1) * T.CellNumX + eix].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	mov	edx, DWORD PTR [esi+164]
	lea	eax, DWORD PTR _Dist$[esp+164]
	push	ebp
	lea	ecx, DWORD PTR _pOut$[esp+168]
	push	eax
	mov	eax, DWORD PTR _dirtol$[esp+168]
	push	ecx
	mov	ecx, DWORD PTR _diry$[esp+172]
	push	edx
	mov	edx, DWORD PTR _dirx$[esp+176]
	push	eax
	mov	eax, DWORD PTR _expy$[esp+180]
	push	ecx
	mov	ecx, DWORD PTR _expx$[esp+184]
	push	edx
	dec	edi
	imul	edi, DWORD PTR [esi+148]
	push	eax
	push	ecx

; 1225 : 			else if (fiy > 0.0f && eiy < (T.CellNumX - 1))

	jmp	SHORT $L80698
$L79435:
	fld	DWORD PTR _fiy$[esp+164]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79437
	mov	eax, DWORD PTR [esi+148]
	lea	ecx, DWORD PTR [eax-1]
	cmp	edi, ecx
	jge	SHORT $L79437

; 1226 : 				pCellLayer[(eiy + 1) * T.CellNumX + eix].FindGrains(expx, expy, dirx, diry, dirtol, T.AlignTol, pOut, Dist, maxmult);

	lea	edx, DWORD PTR _Dist$[esp+164]
	push	ebp
	lea	ecx, DWORD PTR _pOut$[esp+168]
	push	edx
	mov	edx, DWORD PTR [esi+164]
	push	ecx
	mov	ecx, DWORD PTR _dirtol$[esp+172]
	push	edx
	mov	edx, DWORD PTR _diry$[esp+176]
	push	ecx
	mov	ecx, DWORD PTR _dirx$[esp+180]
	push	edx
	mov	edx, DWORD PTR _expy$[esp+184]
	push	ecx
	mov	ecx, DWORD PTR _expx$[esp+188]
	inc	edi
	push	edx
	push	ecx
	imul	edi, eax
$L80698:
	mov	edx, DWORD PTR _pCellLayer$[esp+196]
	add	edi, ebx
	lea	ecx, DWORD PTR [edx+edi*8]
$L80697:
	call	?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ; Cell::FindGrains
$L79437:

; 1227 : 			}
; 1228 : 		}
; 1229 : 	for (i = 0; i < maxmult && Dist[i] < T.AlignTol; i++) pGrainDest[i] = pOut[i];

	xor	ecx, ecx
	test	ebp, ebp
	jle	SHORT $L79440
	mov	edx, DWORD PTR _pGrainDest$[esp+160]
$L79438:
	fld	DWORD PTR _Dist$[esp+ecx*4+164]
	fcomp	DWORD PTR [esi+164]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79440
	mov	eax, DWORD PTR _pOut$[esp+ecx*4+164]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	ecx
	cmp	ecx, ebp
	jl	SHORT $L79438
$L79440:
	pop	edi
	pop	esi
	pop	ebp

; 1230 : 	return i;	

	mov	eax, ecx
	pop	ebx

; 1231 : 	}

	add	esp, 148				; 00000094H
	ret	32					; 00000020H
$L79426:
	pop	edi
	pop	esi
	pop	ebp

; 1207 : 	if (eix < 0 || eix >= T.CellNumX) return 0;

	xor	eax, eax
	pop	ebx

; 1231 : 	}

	add	esp, 148				; 00000094H
	ret	32					; 00000020H
?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z ENDP ; CSmartTrackerClass::FindGrains
_TEXT	ENDS
PUBLIC	?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z ; CSmartTrackerClass::PartialGetTracks2
;	COMDAT ?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z
_TEXT	SEGMENT
_AR$ = 8
_ny$ = -224
_bx$ = -208
_wx$ = -232
_lay$ = -240
_itr$ = -184
_ZLayer$ = -192
_tz$ = -136
_CellsInLayer$ = -124
_CellSpace$ = -188
_MaxSlope$ = -216
_MaxSlope2$ = -112
_iix$ = -168
_minix$ = -148
_maxix$ = -200
_miniy$ = -204
_maxiy$ = -196
_SlopeS$ = -268
_SlopeX$ = -236
_SlopeY$ = -228
_DirX$ = -180
_DirY$ = -128
_dirtol$ = -176
_ifound$ = -156
_idz$ = -144
_EndLayer$ = -264
_StartLayer$ = -132
_pTempGrains$ = -212
_avgdz$ = -88
_tsl$ = -92
_tinf$ = -116
_td$ = -120
_tr$79526 = -44
_tp$79529 = -220
_bp$79530 = -96
_pT$79542 = -248
_pTE$79543 = -100
_gt$79547 = -84
_pB$79555 = -164
_pBE$79556 = -108
_gb$79560 = -64
_seqlength$79570 = -260
_j$79580 = -268
?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z PROC NEAR ; CSmartTrackerClass::PartialGetTracks2, COMDAT

; 1234 : {

	sub	esp, 268				; 0000010cH
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi

; 1235 : 	int nx, ny, bx, wx;
; 1236 : 	int lay;
; 1237 : 	int itr, ibr;
; 1238 : 	int NTracks = 0;
; 1239 : 	float *ZLayer = T.ZLayer;

	mov	eax, DWORD PTR [ebp+940]

; 1240 : 	float tz;
; 1241 : 	int CellsInLayer = T.CellsInLayer;
; 1242 : 	Cell *CellSpace = T.CellSpace;
; 1243 : 	float MaxSlope = T.MaxSlope;
; 1244 : 	float MinSlope = T.MinSlope;
; 1245 : 	float MaxSlope2 = MaxSlope * MaxSlope;
; 1246 : 	float aligntol2 = T.AlignTol * T.AlignTol;
; 1247 : 	int TimeLimit = AR.TimeLimit;
; 1248 : 
; 1249 : 	int ix, iy, iix, iiy, eix, eiy;
; 1250 : 	int minix, maxix, miniy, maxiy;
; 1251 : 	float Slope2, SlopeS, ISlopeS;
; 1252 : 	float SlopeX, SlopeY, ExpX, ExpY, DirX, DirY;
; 1253 : 	float ShadowXTol, ShadowYTol;
; 1254 : 	float CurrDeltaX, CurrDeltaY;
; 1255 : 	float avgds2;
; 1256 : 	float dirtol;
; 1257 : 	int it, ib, ir, ifound;
; 1258 : 	float idz;
; 1259 : 
; 1260 : 	ShadowXTol = T.DiscardShadowSigma * T.ShadowSigmaX;
; 1261 : 	ShadowYTol = T.DiscardShadowSigma * T.ShadowSigmaY;
; 1262 : 
; 1263 : 	bx = T.CellNumX / T.Processors * AR.ThreadIndex;

	mov	esi, DWORD PTR [ebp+900]
	mov	DWORD PTR _ZLayer$[esp+284], eax
	mov	eax, DWORD PTR [ebp+148]
	mov	DWORD PTR -252+[esp+284], eax
	mov	ecx, DWORD PTR [ebp+896]
	cdq
	idiv	esi
	mov	edx, DWORD PTR _AR$[esp+280]
	mov	DWORD PTR _MaxSlope$[esp+284], ecx
	fld	DWORD PTR _MaxSlope$[esp+284]
	mov	ecx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [ebp+952]
	fmul	DWORD PTR _MaxSlope$[esp+284]
	mov	edx, ecx
	mov	edi, DWORD PTR [ebp+948]
	mov	DWORD PTR _CellsInLayer$[esp+284], ebx
	mov	DWORD PTR _CellSpace$[esp+284], edi
	fstp	DWORD PTR _MaxSlope2$[esp+284]
	imul	edx, eax

; 1264 : 	nx = T.CellNumX;
; 1265 : 	wx = (AR.ThreadIndex == T.Processors - 1) ? T.CellNumX : (T.CellNumX / T.Processors * (AR.ThreadIndex + 1));

	dec	esi
	mov	DWORD PTR _bx$[esp+284], edx
	cmp	ecx, esi
	jne	SHORT $L80701
	mov	esi, DWORD PTR -252+[esp+284]
	mov	DWORD PTR _wx$[esp+284], esi
	jmp	SHORT $L80702
$L80701:
	inc	ecx
	imul	ecx, eax
	mov	DWORD PTR _wx$[esp+284], ecx
	mov	esi, ecx
$L80702:

; 1266 : 	ny = T.CellNumY;
; 1267 : 
; 1268 : 	for (lay = 0; lay < T.Layer; lay++)

	mov	ecx, DWORD PTR [ebp+992]
	mov	eax, DWORD PTR [ebp+152]
	test	ecx, ecx
	mov	DWORD PTR _ny$[esp+284], eax
	mov	DWORD PTR _lay$[esp+284], 0
	jle	$L79494
	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR -248+[esp+284], edi
	mov	DWORD PTR -256+[esp+284], ecx
$L79492:

; 1271 : 		for (iy = 0; iy < ny; iy++)

	test	eax, eax
	mov	ebx, edi
	jle	SHORT $L79493

; 1269 : 	{		
; 1270 : 		Cell *pCellsL = CellSpace + lay * CellsInLayer;

	mov	DWORD PTR -244+[esp+284], eax
$L79496:

; 1272 : 		{
; 1273 : 			Cell *pCellsR = pCellsL + bx;

	mov	edx, DWORD PTR _bx$[esp+284]

; 1274 : 			for (ix = bx; ix < wx; ix++)

	mov	eax, DWORD PTR _bx$[esp+284]
	cmp	eax, esi
	lea	edx, DWORD PTR [ebx+edx*8]
	jge	SHORT $L79502

; 1272 : 		{
; 1273 : 			Cell *pCellsR = pCellsL + bx;

	sub	esi, eax
$L79500:

; 1275 : 			{
; 1276 : 				IntGrain *pG = pCellsR->FirstG;
; 1277 : 				IntGrain *pGEnd = pG + pCellsR->Free;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [eax+ecx*4]

; 1278 : 				while (pG < pGEnd)

	cmp	eax, ecx
	jae	SHORT $L79507
$L79506:

; 1279 : 				{
; 1280 : 					pG->pTrack2 = 0;

	xor	edi, edi
	mov	DWORD PTR [eax+16], edi

; 1281 : 					pG->TrackLength = 0;

	mov	DWORD PTR [eax+12], edi

; 1282 : 					pG++;

	add	eax, 20					; 00000014H
	cmp	eax, ecx
	jb	SHORT $L79506
$L79507:

; 1283 : 					}
; 1284 : 				pCellsR++;

	add	edx, 8
	dec	esi
	jne	SHORT $L79500

; 1274 : 			for (ix = bx; ix < wx; ix++)

	mov	esi, DWORD PTR _wx$[esp+284]
$L79502:

; 1271 : 		for (iy = 0; iy < ny; iy++)

	mov	eax, DWORD PTR -244+[esp+284]

; 1285 : 				}
; 1286 : 			pCellsL += nx;

	mov	edx, DWORD PTR -252+[esp+284]
	dec	eax
	lea	ebx, DWORD PTR [ebx+edx*8]
	mov	DWORD PTR -244+[esp+284], eax
	jne	SHORT $L79496
	mov	eax, DWORD PTR _ny$[esp+284]
	mov	edi, DWORD PTR -248+[esp+284]
$L79493:
	mov	ecx, DWORD PTR _lay$[esp+284]
	mov	ebx, DWORD PTR -256+[esp+284]
	mov	edx, DWORD PTR [ebp+992]
	inc	ecx
	add	edi, ebx
	cmp	ecx, edx
	mov	DWORD PTR _lay$[esp+284], ecx
	mov	DWORD PTR -248+[esp+284], edi
	jl	SHORT $L79492
$L79494:

; 1287 : 			}
; 1288 : 		}
; 1289 : 
; 1290 : 	AR.Found = 0;

	mov	eax, DWORD PTR _AR$[esp+280]

; 1291 : 	if (AR.MaxTracks <= 0) return S_OK;

	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], 0
	test	ecx, ecx
	jle	$L80743

; 1292 : 
; 1293 : 	int EndLayer = AR.EndLayer;

	mov	esi, DWORD PTR [eax+32]

; 1294 : 	int StartLayer = AR.StartLayer;

	mov	ebx, DWORD PTR [eax+28]

; 1295 : 	if (EndLayer >= T.Layer) EndLayer = T.Layer - 1;

	mov	eax, DWORD PTR [ebp+992]
	mov	DWORD PTR _EndLayer$[esp+284], esi
	cmp	esi, eax
	mov	DWORD PTR _StartLayer$[esp+284], ebx
	jl	SHORT $L79512
	dec	eax
	mov	DWORD PTR _EndLayer$[esp+284], eax
	mov	esi, eax
$L79512:

; 1296 : 
; 1297 : 	IntGrain **pTempGrains = (IntGrain **)malloc(sizeof(IntGrain *) * (EndLayer + 1) * T.InitialMultiplicity);

	lea	eax, DWORD PTR [esi+1]
	imul	eax, DWORD PTR [ebp+928]
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp__malloc

; 1298 : 
; 1299 : 	float avgdz = (ZLayer[StartLayer] - ZLayer[EndLayer]) / (EndLayer - StartLayer);

	mov	ecx, DWORD PTR _ZLayer$[esp+288]
	mov	DWORD PTR _pTempGrains$[esp+288], eax
	add	esp, 4
	fld	DWORD PTR [ecx+ebx*4]
	fsub	DWORD PTR [ecx+esi*4]
	lea	eax, DWORD PTR [ecx+ebx*4]
	sub	esi, ebx
	mov	DWORD PTR -256+[esp+284], esi
	mov	DWORD PTR -104+[esp+284], eax
	fidiv	DWORD PTR -256+[esp+284]
	fstp	DWORD PTR _avgdz$[esp+284]

; 1300 : 	float avgdz2 = avgdz * avgdz;
; 1301 : 			
; 1302 : 	float tsl = (T.NptMin01 == T.NptMinH) ? 0.0 : (10.0f * (T.NptMinV - T.NptMin01) / (T.NptMin01 - T.NptMinH));

	fld	DWORD PTR [ebp+888]
	fcomp	DWORD PTR [ebp+884]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L80703
	fld	QWORD PTR __real@8@00000000000000000000
	jmp	SHORT $L80704
$L80703:
	fld	DWORD PTR [ebp+880]
	fsub	DWORD PTR [ebp+888]
	fmul	DWORD PTR __real@4@4002a000000000000000
	fld	DWORD PTR [ebp+888]
	fsub	DWORD PTR [ebp+884]
	fdivp	ST(1), ST(0)
$L80704:
	fstp	DWORD PTR _tsl$[esp+284]

; 1303 : 	float tinf = (float)(T.NptMinH);

	fld	DWORD PTR [ebp+884]

; 1304 : 	float td = (float)(T.NptMinV - T.NptMinH);
; 1305 : 
; 1306 : 	for (itr = 0; itr < T.TrialCount; itr++)

	mov	ecx, DWORD PTR [ebp+172]
	xor	eax, eax
	fstp	DWORD PTR _tinf$[esp+284]
	fld	DWORD PTR [ebp+880]
	fsub	DWORD PTR [ebp+884]
	cmp	ecx, eax
	mov	DWORD PTR _itr$[esp+284], eax
	fstp	DWORD PTR _td$[esp+284]
	jle	$L79525
	lea	esi, DWORD PTR [ebp+176]
	mov	DWORD PTR -244+[esp+284], eax
	mov	DWORD PTR -256+[esp+284], esi
$L79523:

; 1307 : 	{
; 1308 : 		Trial tr = T.Trials[itr];

	mov	ecx, 11					; 0000000bH
	lea	edi, DWORD PTR _tr$79526[esp+284]
	rep movsd

; 1309 : 		if (tr.TopLayer < StartLayer || tr.BottomLayer > EndLayer) continue;

	mov	eax, DWORD PTR _tr$79526[esp+284]
	cmp	eax, ebx
	jl	$L79524
	mov	ecx, DWORD PTR _tr$79526[esp+288]
	mov	edx, DWORD PTR _EndLayer$[esp+284]
	cmp	ecx, edx
	jg	$L79524

; 1310 : 		Cell *tp = CellsInLayer * tr.TopLayer + CellSpace;

	mov	edx, DWORD PTR _CellsInLayer$[esp+284]
	mov	edi, eax
	imul	edi, edx
	mov	esi, DWORD PTR _CellSpace$[esp+284]
	lea	edi, DWORD PTR [esi+edi*8]
	mov	DWORD PTR _tp$79529[esp+284], edi

; 1311 : 		Cell *bp = CellsInLayer * tr.BottomLayer + CellSpace;

	mov	edi, ecx
	imul	edi, edx
	lea	edx, DWORD PTR [esi+edi*8]
	mov	DWORD PTR _bp$79530[esp+284], edx

; 1312 : 		tz = ZLayer[tr.TopLayer];

	mov	edx, DWORD PTR _ZLayer$[esp+284]
	fld	DWORD PTR [edx+eax*4]

; 1313 : 		idz = 1.0f / (tz - ZLayer[tr.BottomLayer]);
; 1314 : 
; 1315 : 		for (ix = bx; ix < wx; ix++)

	mov	eax, DWORD PTR _bx$[esp+284]
	fst	DWORD PTR _tz$[esp+284]
	fsub	DWORD PTR [edx+ecx*4]
	cmp	eax, DWORD PTR _wx$[esp+284]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _idz$[esp+284]
	jge	$L79524
	mov	edx, DWORD PTR _tp$79529[esp+284]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR -240+[esp+284], ecx
	lea	edi, DWORD PTR [edx+eax*8]
	mov	DWORD PTR -220+[esp+284], edi
$L79531:

; 1316 : 		{
; 1317 : 			ifound = 0;

	xor	edx, edx

; 1318 : 			minix = ix - 1; if (minix < 0) minix = 0;

	lea	eax, DWORD PTR [ecx-2]
	cmp	eax, edx
	mov	DWORD PTR _ifound$[esp+284], edx
	mov	DWORD PTR _minix$[esp+284], eax
	jge	SHORT $L79534
	mov	DWORD PTR _minix$[esp+284], edx
$L79534:

; 1319 : 			maxix = ix + 1; if (maxix >= nx) maxix = nx - 1;

	mov	eax, DWORD PTR -252+[esp+284]
	mov	DWORD PTR _maxix$[esp+284], ecx
	cmp	ecx, eax
	jl	SHORT $L79535
	dec	eax
	mov	DWORD PTR _maxix$[esp+284], eax
$L79535:

; 1320 : 			for (iy = 0; iy < ny; iy++)

	mov	esi, DWORD PTR _ny$[esp+284]
	cmp	esi, edx
	jle	$L79532
	mov	ecx, 1
	mov	DWORD PTR -152+[esp+284], edi
	mov	DWORD PTR -160+[esp+284], ecx
	jmp	SHORT $L79536
$L80742:
	xor	edx, edx
$L79536:

; 1321 : 			{
; 1322 : 				miniy = iy - 1; if (miniy < 0) miniy = 0;

	lea	eax, DWORD PTR [ecx-2]
	cmp	eax, edx
	mov	DWORD PTR _miniy$[esp+284], eax
	jge	SHORT $L79539
	mov	DWORD PTR _miniy$[esp+284], edx
	mov	eax, edx
$L79539:

; 1323 : 				maxiy = iy + 1; if (maxiy >= ny) maxiy = ny - 1;

	mov	edx, ecx
	cmp	ecx, esi
	mov	DWORD PTR _maxiy$[esp+284], edx
	jl	SHORT $L79540
	dec	esi
	mov	DWORD PTR _maxiy$[esp+284], esi
	mov	edx, esi
$L79540:

; 1324 : 				Cell &ct = tp[iy * nx + ix];
; 1325 : 				IntGrain *pT = ct.FirstG;

	mov	esi, DWORD PTR [edi]

; 1326 : 				IntGrain *pTE = ct.FirstG + ct.Free;

	mov	edi, DWORD PTR [edi+4]
	mov	DWORD PTR _pT$79542[esp+284], esi
	lea	edi, DWORD PTR [edi+edi*4]
	lea	edi, DWORD PTR [esi+edi*4]

; 1327 : 				for (;pT < pTE; pT++)

	cmp	esi, edi
	mov	DWORD PTR _pTE$79543[esp+284], edi
	jae	$L80737
	jmp	SHORT $L79544
$L80736:
	mov	esi, DWORD PTR _pT$79542[esp+284]
$L79544:

; 1328 : 				{
; 1329 : 					IntGrain gt = *pT;

	mov	ecx, 5
	lea	edi, DWORD PTR _gt$79547[esp+284]
	rep movsd

; 1330 : 					for (iix = minix; iix <= maxix; iix++)

	mov	ecx, DWORD PTR _minix$[esp+284]
	mov	edi, DWORD PTR _maxix$[esp+284]
	mov	esi, ecx
	cmp	ecx, edi
	mov	DWORD PTR _iix$[esp+284], esi
	jg	$L79545
$L79548:

; 1331 : 						for (iiy = miniy; iiy <= maxiy; iiy++)

	cmp	eax, edx
	jg	$L79549
	mov	ecx, eax
	sub	edx, eax
	imul	ecx, DWORD PTR -252+[esp+284]
	add	ecx, esi
	mov	esi, DWORD PTR _bp$79530[esp+284]
	inc	edx
	lea	ecx, DWORD PTR [esi+ecx*8]
	mov	DWORD PTR -172+[esp+284], edx
	mov	DWORD PTR -140+[esp+284], ecx
$L79551:

; 1332 : 						{
; 1333 : 							Cell &cb = bp[iiy * nx + iix];
; 1334 : 							IntGrain *pB = cb.FirstG;
; 1335 : 							IntGrain *pBE = cb.FirstG + cb.Free;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pB$79555[esp+284], edx
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+eax*4]

; 1336 : 							for (;pB < pBE; pB++)

	cmp	edx, eax
	mov	DWORD PTR _pBE$79556[esp+284], eax
	jae	$L79552
$L79557:

; 1337 : 							{
; 1338 : /*								if (GetTickCount() > TimeLimit)
; 1339 : 								{
; 1340 : 									AR.Found = 0;
; 1341 : 									return S_FALSE;
; 1342 : 									}
; 1343 : */								IntGrain gb = *pB;
; 1344 : 								SlopeX = idz * (gt.Xcm - gb.Xcm);

	fld	DWORD PTR _gt$79547[esp+284]
	mov	ecx, 5
	mov	esi, edx
	lea	edi, DWORD PTR _gb$79560[esp+284]
	rep movsd
	fsub	DWORD PTR _gb$79560[esp+284]
	fmul	DWORD PTR _idz$[esp+284]
	fst	DWORD PTR _SlopeX$[esp+284]

; 1345 : 								if (fabs(SlopeX) >= MaxSlope) continue;

	fabs
	fld	DWORD PTR _MaxSlope$[esp+284]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L79558

; 1346 : 								SlopeY = idz * (gt.Ycm - gb.Ycm);

	fld	DWORD PTR _gt$79547[esp+288]
	fsub	DWORD PTR _gb$79560[esp+288]
	fmul	DWORD PTR _idz$[esp+284]
	fst	DWORD PTR _SlopeY$[esp+284]

; 1347 : 								if (fabs(SlopeY) >= MaxSlope) continue;

	fabs
	fld	DWORD PTR _MaxSlope$[esp+284]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L79558

; 1348 : 								Slope2 = SlopeX * SlopeX + SlopeY * SlopeY;

	fld	DWORD PTR _SlopeY$[esp+284]
	fmul	DWORD PTR _SlopeY$[esp+284]
	fld	DWORD PTR _SlopeX$[esp+284]
	fmul	DWORD PTR _SlopeX$[esp+284]
$restart$79563:
	faddp	ST(1), ST(0)

; 1349 : restart:
; 1350 : 								if (Slope2 < MaxSlope2)

	fcom	DWORD PTR _MaxSlope2$[esp+284]
	fnstsw	ax
	test	ah, 1
	je	$L80734

; 1351 : 								{
; 1352 : 									SlopeS = sqrt(Slope2);

	fsqrt
	fst	DWORD PTR _SlopeS$[esp+284]

; 1353 : 									if (SlopeS > 0.0f) ISlopeS = 1.0f / SlopeS;

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L80732
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _SlopeS$[esp+284]

; 1354 : 									avgds2 = avgdz2 * Slope2;
; 1355 : 									fastGetDirAndTol(SlopeS, ISlopeS, DirX, DirY, dirtol/*, aligntol2, avgds2*/);

	fld	ST(0)
	fmul	DWORD PTR _SlopeX$[esp+284]
	fstp	DWORD PTR _DirX$[esp+284]
	fmul	DWORD PTR _SlopeY$[esp+284]
	fstp	DWORD PTR _DirY$[esp+284]
	fld	DWORD PTR _SlopeS$[esp+284]
	fmul	DWORD PTR [ebp+168]
	fmul	DWORD PTR _avgdz$[esp+284]
	fadd	DWORD PTR [ebp+164]
	fstp	DWORD PTR _dirtol$[esp+284]
$L79567:

; 1356 : 									//GetDirAndTol(SlopeX, SlopeY, avgdz, &DirX, &DirY, &dirtol);
; 1357 : /*
; 1358 : 									for (ir = 0; ir < tr.TriggerCount; ir++)
; 1359 : 									{
; 1360 : 										int TriggerLayer = tr.Triggers[ir];
; 1361 : 										float ldz = (tz - ZLayer[TriggerLayer]) * idz;
; 1362 : 										float cdz = 1.0f - ldz;
; 1363 : 										ExpX = ldz * gb.Xcm + cdz * gt.Xcm;
; 1364 : 										ExpY = ldz * gb.Ycm + cdz * gt.Ycm;
; 1365 : 										eix = (int)((ExpX - T.Win.Xmin) / T.DxCell);
; 1366 : 										eiy = (int)((ExpY - T.Win.Ymin) / T.DyCell);
; 1367 : 										IntGrain *pTrg = CellSpace[(TriggerLayer * ny + eiy) * nx + eix].FindGrain(ExpX, ExpY, DirX, DirY, dirtol, T.AlignTol);
; 1368 : 										if (pTrg)
; 1369 : 										{
; 1370 : */											memset(pTempGrains, 0, T.Layer * sizeof(Grain *) * T.InitialMultiplicity);

	mov	ecx, DWORD PTR [ebp+992]
	mov	edi, DWORD PTR _pTempGrains$[esp+284]
	imul	ecx, DWORD PTR [ebp+928]
	shl	ecx, 2
	mov	esi, ecx
	xor	eax, eax
	shr	ecx, 2
	rep stosd
	mov	ecx, esi

; 1371 : 											float dz;
; 1372 : 											int seqlength = 0;

	mov	DWORD PTR _seqlength$79570[esp+284], 0
	and	ecx, 3

; 1373 : 											//int seqlength = 3;
; 1374 : /*
; 1375 : 											pTempGrains[tr.TopLayer] = pT;
; 1376 : 											pTempGrains[tr.BottomLayer] = pB;
; 1377 : 											pTempGrains[TriggerLayer] = pTrg;
; 1378 : */
; 1379 : 											CurrDeltaX = fabs(avgdz * SlopeX);
; 1380 : 											CurrDeltaY = fabs(avgdz * SlopeY);
; 1381 : /*
; 1382 : 											for (lay = tr.TopLayer; lay <= tr.BottomLayer; lay++)
; 1383 : 											{
; 1384 : 												dz = ZLayer[lay] - tz;
; 1385 : 												ExpX = dz * SlopeX + gt.Xcm;
; 1386 : 												ExpY = dz * SlopeY + gt.Ycm;
; 1387 : 												if (FindGrains(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, pTempGrains + lay * T.InitialMultiplicity, T.InitialMultiplicity)) seqlength++;												
; 1388 : 												};
; 1389 : 
; 1390 : 											Vector topv, bottomv;
; 1391 : 											topv.X = pT->Xcm;
; 1392 : 											topv.Y = pT->Ycm;
; 1393 : 											topv.Z = tz;
; 1394 : 											bottomv.X = pB->Xcm;
; 1395 : 											bottomv.Y = pB->Ycm;
; 1396 : 											bottomv.Z = ZLayer[tr.BottomLayer];
; 1397 : 											for (lay = (int)tr.TopLayer - 1; lay >= 0; lay--)
; 1398 : 											{
; 1399 : 												dz = (bottomv.Z - topv.Z);
; 1400 : 												float diz = 1.0f / dz;
; 1401 : 												dz = ZLayer[lay] - topv.Z;
; 1402 : 												ExpX = dz * SlopeX + topv.X;
; 1403 : 												ExpY = dz * SlopeY + topv.Y;
; 1404 : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, 0, DiscardShadows ? pTempGrains[lay + 1] : 0, ShadowXTol, ShadowYTol))
; 1405 : 												{
; 1406 : 													seqlength++;
; 1407 : 													}
; 1408 : 												else if (--availablevoids <= 0) break;
; 1409 : 												};
; 1410 : 											if (availablevoids <= 0) continue;
; 1411 : 											for (lay = (int)tr.BottomLayer + 1; lay <= EndLayer; lay++)
; 1412 : 											{
; 1413 : 												dz = (bottomv.Z - topv.Z);
; 1414 : 												float diz = 1.0f / dz;
; 1415 : 												dz = ZLayer[lay] - topv.Z;
; 1416 : 												ExpX = dz * SlopeX + topv.X;
; 1417 : 												ExpY = dz * SlopeY + topv.Y;
; 1418 : 												if (pTempGrains[lay] = FindGrain(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, DiscardShadows ? pTempGrains[lay - 1] : 0, 0, ShadowXTol, ShadowYTol))
; 1419 : 												{
; 1420 : 													seqlength++;
; 1421 : 													}
; 1422 : 												else if (--availablevoids <= 0) break;
; 1423 : 												};
; 1424 : */
; 1425 : 											for (lay = StartLayer; lay <= EndLayer; lay++)

	mov	esi, ebx
	rep stosb
	cmp	ebx, DWORD PTR _EndLayer$[esp+284]
	jg	$L79573
	mov	edi, DWORD PTR -104+[esp+284]
	mov	ebx, DWORD PTR _DirX$[esp+284]
$L79571:

; 1426 : 											{
; 1427 : 												dz = ZLayer[lay] - tz;
; 1428 : 												ExpX = dz * SlopeX + gt.Xcm;
; 1429 : 												ExpY = dz * SlopeY + gt.Ycm;
; 1430 : 												if (FindGrains(ExpX, ExpY, CellSpace + lay * T.CellsInLayer, DirX, DirY, dirtol, pTempGrains + lay * T.InitialMultiplicity, T.InitialMultiplicity)) seqlength++;

	mov	eax, DWORD PTR [ebp+928]
	mov	edx, DWORD PTR _pTempGrains$[esp+284]
	push	eax

; 1463 : 	return S_OK;

	imul	eax, esi
	fld	DWORD PTR [edi]
	fsub	DWORD PTR _tz$[esp+288]
	fld	ST(0)
	fmul	DWORD PTR _SlopeY$[esp+288]
	fadd	DWORD PTR _gt$79547[esp+292]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _dirtol$[esp+288]
	push	eax
	mov	eax, DWORD PTR [ebp+952]
	imul	eax, esi
	mov	edx, DWORD PTR _DirY$[esp+292]
	push	ecx
	mov	ecx, DWORD PTR _CellSpace$[esp+296]
	push	edx
	push	ebx
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	mov	ecx, ebp
	fmul	DWORD PTR _SlopeX$[esp+316]
	fadd	DWORD PTR _gt$79547[esp+316]
	fstp	DWORD PTR [esp]
	call	?FindGrains@CSmartTrackerClass@@IAEHMMPAUCell@@MMMPAPAUIntGrain@@H@Z ; CSmartTrackerClass::FindGrains
	test	eax, eax
	je	SHORT $L79572
	inc	DWORD PTR _seqlength$79570[esp+284]
$L79572:
	mov	eax, DWORD PTR _EndLayer$[esp+284]
	inc	esi
	add	edi, 4
	cmp	esi, eax
	jle	SHORT $L79571
	mov	ebx, DWORD PTR _StartLayer$[esp+284]
	mov	edx, DWORD PTR _pB$79555[esp+284]
$L79573:
	fild	DWORD PTR _seqlength$79570[esp+284]
	fld	DWORD PTR _SlopeS$[esp+284]
	fmul	DWORD PTR _tsl$[esp+284]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fdivr	DWORD PTR _td$[esp+284]
	fadd	DWORD PTR _tinf$[esp+284]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L80718

; 1431 : 												};											
; 1432 : 											
; 1433 : 											if ((float)seqlength > (tinf + td / (1.0f + tsl * SlopeS)))

	jmp	SHORT $L79558
$L80732:

; 1354 : 									avgds2 = avgdz2 * Slope2;
; 1355 : 									fastGetDirAndTol(SlopeS, ISlopeS, DirX, DirY, dirtol/*, aligntol2, avgds2*/);

	mov	ecx, DWORD PTR [ebp+164]
	mov	DWORD PTR _DirX$[esp+284], 1065353216	; 3f800000H
	mov	DWORD PTR _DirY$[esp+284], 0
	mov	DWORD PTR _dirtol$[esp+284], ecx
	jmp	$L79567
$L80734:

; 1431 : 												};											
; 1432 : 											
; 1433 : 											if ((float)seqlength > (tinf + td / (1.0f + tsl * SlopeS)))

	fstp	ST(0)
$L79558:

; 1336 : 							for (;pB < pBE; pB++)

	mov	eax, DWORD PTR _pBE$79556[esp+284]
	add	edx, 20					; 00000014H
	cmp	edx, eax
	mov	DWORD PTR _pB$79555[esp+284], edx
	jb	$L79557

; 1431 : 												};											
; 1432 : 											
; 1433 : 											if ((float)seqlength > (tinf + td / (1.0f + tsl * SlopeS)))

	jmp	$L79552
$L80718:

; 1434 : 											{								
; 1435 : 												if (AR.Found < AR.MaxTracks)

	mov	edx, DWORD PTR _AR$[esp+280]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [edx+12]
	cmp	eax, ecx
	jge	$L79552

; 1436 : 												{
; 1437 : 													Track2 &N = AR.pSpace[AR.Found++];

	mov	esi, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+eax*2]
	inc	eax
	mov	DWORD PTR [edx+16], eax

; 1438 : 													int i, j;
; 1439 : 													for (i = j = 0; i <= EndLayer * T.InitialMultiplicity; i++)

	mov	edx, DWORD PTR [ebp+928]
	imul	edx, DWORD PTR _EndLayer$[esp+284]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	edi, DWORD PTR [esi+ecx*4]
	xor	esi, esi
	test	edx, edx
	mov	DWORD PTR _j$79580[esp+284], esi
	jl	SHORT $L79583
	mov	eax, DWORD PTR _pTempGrains$[esp+284]
	xor	ebx, ebx
	mov	DWORD PTR -260+[esp+284], eax
$L79581:

; 1440 : 														if (pTempGrains[i])

	mov	ecx, DWORD PTR -260+[esp+284]
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $L79582
	mov	ecx, DWORD PTR [edi+12]

; 1441 : 														{
; 1442 : 															IntTrackGrain *pIG = ((IntTrackGrain *)N.pGrains) + j++;

	mov	edx, DWORD PTR _j$79580[esp+284]
	add	ecx, ebx
	inc	edx
	mov	DWORD PTR _j$79580[esp+284], edx
	add	ebx, 16					; 00000010H

; 1443 : 															pIG->T.pG = pTempGrains[i];

	mov	DWORD PTR [ecx], eax

; 1444 : 															pIG->T.Z = ZLayer[i / T.InitialMultiplicity];

	mov	eax, esi
	cdq
	idiv	DWORD PTR [ebp+928]
	mov	edx, DWORD PTR _ZLayer$[esp+284]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx+4], eax
$L79582:
	mov	ecx, DWORD PTR -260+[esp+284]
	inc	esi
	add	ecx, 4
	mov	DWORD PTR -260+[esp+284], ecx
	mov	ecx, DWORD PTR [ebp+928]
	imul	ecx, DWORD PTR _EndLayer$[esp+284]
	cmp	esi, ecx
	jle	SHORT $L79581

; 1438 : 													int i, j;
; 1439 : 													for (i = j = 0; i <= EndLayer * T.InitialMultiplicity; i++)

	mov	ebx, DWORD PTR _StartLayer$[esp+284]
$L79583:

; 1445 : 															}														
; 1446 : 													N.Field = (itr << 24) + (ix << 16) + ifound;

	mov	edx, DWORD PTR -244+[esp+284]
	mov	eax, DWORD PTR -240+[esp+284]
	add	edx, eax
	mov	eax, DWORD PTR _ifound$[esp+284]
	shl	edx, 16					; 00000010H

; 1447 : 													N.Valid = true;

	mov	BYTE PTR [edi+56], 1
	lea	ecx, DWORD PTR [edx+eax-65536]

; 1448 : 													N.Grains = j;//seqlength;

	mov	edx, DWORD PTR _j$79580[esp+284]

; 1449 : 													ifound++;

	inc	eax
	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR _ifound$[esp+284], eax
$L79552:
	mov	eax, DWORD PTR -252+[esp+284]
	mov	ecx, DWORD PTR -140+[esp+284]
	shl	eax, 3
	add	ecx, eax
	mov	eax, DWORD PTR -172+[esp+284]
	dec	eax
	mov	DWORD PTR -140+[esp+284], ecx
	mov	DWORD PTR -172+[esp+284], eax
	jne	$L79551
	mov	edx, DWORD PTR _maxiy$[esp+284]
	mov	eax, DWORD PTR _miniy$[esp+284]
	mov	esi, DWORD PTR _iix$[esp+284]
$L79549:
	mov	ecx, DWORD PTR _maxix$[esp+284]
	inc	esi
	cmp	esi, ecx
	mov	DWORD PTR _iix$[esp+284], esi
	jle	$L79548
$L79545:

; 1327 : 				for (;pT < pTE; pT++)

	mov	ecx, DWORD PTR _pT$79542[esp+284]
	mov	esi, DWORD PTR _pTE$79543[esp+284]
	add	ecx, 20					; 00000014H
	cmp	ecx, esi
	mov	DWORD PTR _pT$79542[esp+284], ecx
	jb	$L80736
	mov	ecx, DWORD PTR -160+[esp+284]
$L80737:

; 1320 : 			for (iy = 0; iy < ny; iy++)

	mov	edx, DWORD PTR -252+[esp+284]
	mov	edi, DWORD PTR -152+[esp+284]

; 1327 : 				for (;pT < pTE; pT++)

	mov	esi, DWORD PTR _ny$[esp+284]
	inc	ecx
	lea	eax, DWORD PTR [edx*8]
	mov	DWORD PTR -160+[esp+284], ecx
	add	edi, eax
	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, esi
	mov	DWORD PTR -152+[esp+284], edi
	jl	$L80742

; 1320 : 			for (iy = 0; iy < ny; iy++)

	mov	ecx, DWORD PTR -240+[esp+284]
$L79532:

; 1313 : 		idz = 1.0f / (tz - ZLayer[tr.BottomLayer]);
; 1314 : 
; 1315 : 		for (ix = bx; ix < wx; ix++)

	mov	edi, DWORD PTR -220+[esp+284]
	mov	eax, DWORD PTR _wx$[esp+284]
	inc	ecx
	add	edi, 8
	mov	DWORD PTR -240+[esp+284], ecx
	mov	DWORD PTR -220+[esp+284], edi
	lea	edx, DWORD PTR [ecx-1]
	cmp	edx, eax
	jl	$L79531
$L79524:

; 1304 : 	float td = (float)(T.NptMinV - T.NptMinH);
; 1305 : 
; 1306 : 	for (itr = 0; itr < T.TrialCount; itr++)

	mov	eax, DWORD PTR _itr$[esp+284]
	mov	esi, DWORD PTR -256+[esp+284]
	mov	edx, DWORD PTR -244+[esp+284]
	mov	ecx, DWORD PTR [ebp+172]
	inc	eax
	add	esi, 44					; 0000002cH
	add	edx, 256				; 00000100H
	cmp	eax, ecx
	mov	DWORD PTR _itr$[esp+284], eax
	mov	DWORD PTR -256+[esp+284], esi
	mov	DWORD PTR -244+[esp+284], edx
	jl	$L79523
$L79525:

; 1450 : 													}
; 1451 : 												break;
; 1452 : 												}
; 1453 : 											}
; 1454 : /*										}
; 1455 : 									}*/
; 1456 : 								}
; 1457 : 							}
; 1458 : 					}
; 1459 : 				}
; 1460 : 			}
; 1461 : 		}
; 1462 : 	free(pTempGrains);

	mov	eax, DWORD PTR _pTempGrains$[esp+284]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$L80743:
	pop	edi
	pop	esi
	pop	ebp

; 1463 : 	return S_OK;

	xor	eax, eax
	pop	ebx

; 1464 : 	};

	add	esp, 268				; 0000010cH
	ret	4
?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z ENDP ; CSmartTrackerClass::PartialGetTracks2
_TEXT	ENDS
EXTRN	__imp___endthreadex:NEAR
EXTRN	__imp__WaitForMultipleObjects@16:NEAR
;	COMDAT ?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z
_TEXT	SEGMENT
_Context$ = 8
_HEvsStart$ = -16
_HEvsReset$ = -8
?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z PROC NEAR ; CSmartTrackerClass::TrackerThreadHook, COMDAT

; 1468 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 1469 : 	ActivationRecord *pAR = (ActivationRecord *)Context;
; 1470 : 	HANDLE HEvsStart[2], HEvsReset[2];
; 1471 : 	HEvsStart[0] = HEvsReset[0] = pAR->pThis->HTerminate;

	mov	esi, DWORD PTR _Context$[esp+20]
	push	edi

; 1472 : 	HEvsStart[1] = pAR->pThis->HStart;
; 1473 : 	HEvsReset[1] = pAR->pThis->HReset;
; 1474 : 	while (WaitForMultipleObjects(2, HEvsStart, FALSE, INFINITE) != WAIT_OBJECT_0)

	mov	edi, DWORD PTR __imp__WaitForMultipleObjects@16
	push	-1
	mov	eax, DWORD PTR [esi]
	push	0
	mov	ecx, DWORD PTR [eax+1084]
	mov	DWORD PTR _HEvsReset$[esp+36], ecx
	mov	DWORD PTR _HEvsStart$[esp+36], ecx
	mov	ecx, DWORD PTR [eax+1080]
	mov	DWORD PTR _HEvsStart$[esp+40], ecx
	mov	edx, DWORD PTR [eax+1088]
	lea	eax, DWORD PTR _HEvsStart$[esp+36]
	mov	DWORD PTR _HEvsReset$[esp+40], edx
	push	eax
	push	2
	call	edi
	test	eax, eax
	je	SHORT $L80747

; 1477 : 		SetEvent(pAR->HFinished);

	mov	ebx, DWORD PTR __imp__SetEvent@4
$L79596:

; 1475 : 	{
; 1476 : 		pAR->pThis->PartialGetTracks2(*pAR);

	mov	ecx, DWORD PTR [esi]
	push	esi
	call	?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z ; CSmartTrackerClass::PartialGetTracks2

; 1477 : 		SetEvent(pAR->HFinished);

	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	call	ebx

; 1478 : 		if (WaitForMultipleObjects(2, HEvsReset, FALSE, INFINITE) == WAIT_OBJECT_0) break;

	push	-1
	lea	edx, DWORD PTR _HEvsReset$[esp+32]
	push	0
	push	edx
	push	2
	call	edi
	test	eax, eax
	je	SHORT $L80747

; 1479 : 		SetEvent(pAR->HFinished);

	mov	eax, DWORD PTR [esi+20]
	push	eax
	call	ebx
	push	-1
	lea	ecx, DWORD PTR _HEvsStart$[esp+32]
	push	0
	push	ecx
	push	2
	call	edi
	test	eax, eax
	jne	SHORT $L79596
$L80747:

; 1480 : 		}
; 1481 : 	_endthreadex(S_OK);

	push	0
	call	DWORD PTR __imp___endthreadex
	add	esp, 4

; 1482 : 	return S_OK;

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1483 : 	};

	add	esp, 16					; 00000010H
	ret	4
?TrackerThreadHook@CSmartTrackerClass@@KGIPAX@Z ENDP	; CSmartTrackerClass::TrackerThreadHook
_TEXT	ENDS
PUBLIC	?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z ; CSmartTrackerClass::GetTracks2
PUBLIC	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z ; CSmartTrackerClass::FinalizeTracks
EXTRN	__imp__GetTickCount@0:NEAR
;	COMDAT ?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z
_TEXT	SEGMENT
_pSpace$ = 12
_pMaxNumber$ = 16
_StartLayer$ = 20
_EndLayer$ = 24
_this$ = 8
_HEvs$ = -32
_p$ = -40
_i$ = -44
_maxtracksperthread$ = -44
_found$ = -48
_pTemp$ = -60
_TempF$ = -52
_TempG$ = -36
_TempV$ = 20
_TimeLimit$ = -60
?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z PROC NEAR ; CSmartTrackerClass::GetTracks2, COMDAT

; 1487 : {

	sub	esp, 68					; 00000044H

; 1488 : 	//AFX_MANAGE_STATE(AfxGetStaticModuleState())
; 1489 : 
; 1490 : 	// TODO: Add your implementation code here
; 1491 : 
; 1492 : 	HANDLE HEvs[MAX_PROCESSORS];
; 1493 : 	int p, i, j, k, maxtracksperthread = *pMaxNumber / T.Processors;

	mov	eax, DWORD PTR _pMaxNumber$[esp+64]
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR _this$[esp+76]
	cdq
	idiv	DWORD PTR [esi+900]
	push	edi

; 1494 : 	int found, seqlength;
; 1495 : 	Grain *pTemp;
; 1496 : 	int TempF, TempG;
; 1497 : 	bool TempV;
; 1498 : 
; 1499 : 	if (T.ShadowSigmaMeasures > 0)

	xor	edi, edi
	mov	ebp, eax
	mov	eax, DWORD PTR [esi+1020]
	cmp	eax, edi
	mov	DWORD PTR _maxtracksperthread$[esp+84], ebp
	mov	DWORD PTR -40+[esp+84], eax
	jle	SHORT $L79622

; 1500 : 	{
; 1501 : 		T.ShadowSigmaX = T.ShadowSigmaXAccumulator / T.ShadowSigmaMeasures;

	fild	DWORD PTR -40+[esp+84]
	fld	DWORD PTR [esi+1004]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR [esi+1012]

; 1502 : 		T.ShadowSigmaY = T.ShadowSigmaYAccumulator / T.ShadowSigmaMeasures;

	fld	DWORD PTR [esi+1008]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR [esi+1016]
	fstp	ST(0)

; 1503 : 		}
; 1504 : 	else	

	jmp	SHORT $L79623
$L79622:

; 1505 : 		T.ShadowSigmaX = T.ShadowSigmaY = 0.0f;

	mov	DWORD PTR [esi+1016], edi
	mov	DWORD PTR [esi+1012], edi
$L79623:

; 1506 : 	
; 1507 : 	int TimeLimit = GetTickCount() + T.MaxTrackingTime;

	call	DWORD PTR __imp__GetTickCount@0
	mov	ecx, DWORD PTR [esi+904]
	mov	ebx, eax

; 1508 : 	for (p = 0; p < T.Processors; p++)

	mov	eax, DWORD PTR [esi+900]
	add	ebx, ecx
	test	eax, eax
	mov	DWORD PTR _TimeLimit$[esp+84], ebx
	jle	SHORT $L79627
	mov	ecx, DWORD PTR _pSpace$[esp+80]
	lea	ebx, DWORD PTR [ebp+ebp*2]
	lea	edx, DWORD PTR _HEvs$[esp+84]
	lea	eax, DWORD PTR [esi+1100]
	lea	ebx, DWORD PTR [ebx+ebx*4]
	shl	ebx, 2
	jmp	SHORT $L79625
$L80768:

; 1506 : 	
; 1507 : 	int TimeLimit = GetTickCount() + T.MaxTrackingTime;

	mov	ebp, DWORD PTR _maxtracksperthread$[esp+84]
$L79625:

; 1509 : 	{
; 1510 : 		ThreadInfo[p].MaxTracks = maxtracksperthread;

	mov	DWORD PTR [eax+4], ebp

; 1511 : 		ThreadInfo[p].pSpace = pSpace + p * maxtracksperthread;

	mov	DWORD PTR [eax], ecx

; 1512 : 		HEvs[p] = ThreadInfo[p].HFinished;

	mov	ebp, DWORD PTR [eax+12]
	inc	edi
	mov	DWORD PTR [edx], ebp

; 1513 : 		ThreadInfo[p].StartLayer = StartLayer;

	mov	ebp, DWORD PTR _StartLayer$[esp+80]
	mov	DWORD PTR [eax+20], ebp

; 1514 : 		ThreadInfo[p].EndLayer = EndLayer;

	mov	ebp, DWORD PTR _EndLayer$[esp+80]
	mov	DWORD PTR [eax+24], ebp

; 1515 : 		ThreadInfo[p].TimeLimit = TimeLimit;

	mov	ebp, DWORD PTR _TimeLimit$[esp+84]
	mov	DWORD PTR [eax+28], ebp
	mov	ebp, DWORD PTR [esi+900]
	add	ecx, ebx
	add	edx, 4
	add	eax, 40					; 00000028H
	cmp	edi, ebp
	jl	SHORT $L80768

; 1508 : 	for (p = 0; p < T.Processors; p++)

	mov	ebx, DWORD PTR _TimeLimit$[esp+84]
$L79627:

; 1516 : 		}
; 1517 : 	ResetEvent(HReset);

	mov	ecx, DWORD PTR [esi+1088]
	mov	edi, DWORD PTR __imp__ResetEvent@4
	push	ecx
	call	edi

; 1518 : 	SetEvent(HStart);

	mov	edx, DWORD PTR [esi+1080]
	mov	ebp, DWORD PTR __imp__SetEvent@4
	push	edx
	call	ebp

; 1519 : 	PartialGetTracks2(ThreadInfo[0]);

	lea	eax, DWORD PTR [esi+1092]
	mov	ecx, esi
	push	eax
	call	?PartialGetTracks2@CSmartTrackerClass@@IAEIAAUActivationRecord@1@@Z ; CSmartTrackerClass::PartialGetTracks2

; 1520 : 
; 1521 : 	if (T.Processors > 1) WaitForMultipleObjects(T.Processors - 1, HEvs + 1, TRUE, INFINITE);

	mov	eax, DWORD PTR [esi+900]
	cmp	eax, 1
	jle	SHORT $L79628
	push	-1
	lea	ecx, DWORD PTR _HEvs$[esp+92]
	push	1
	dec	eax
	push	ecx
	push	eax
	call	DWORD PTR __imp__WaitForMultipleObjects@16
$L79628:

; 1522 : 	ResetEvent(HStart);

	mov	edx, DWORD PTR [esi+1080]
	push	edx
	call	edi

; 1523 : 	SetEvent(HReset);

	mov	eax, DWORD PTR [esi+1088]
	push	eax
	call	ebp

; 1524 : 	if (T.Processors > 1) WaitForMultipleObjects(T.Processors - 1, HEvs + 1, TRUE, INFINITE);

	mov	eax, DWORD PTR [esi+900]
	cmp	eax, 1
	jle	SHORT $L79629
	push	-1
	lea	ecx, DWORD PTR _HEvs$[esp+92]
	push	1
	dec	eax
	push	ecx
	push	eax
	call	DWORD PTR __imp__WaitForMultipleObjects@16
$L79629:

; 1525 : 
; 1526 : 	if (GetTickCount() > TimeLimit) 

	call	DWORD PTR __imp__GetTickCount@0
	cmp	eax, ebx
	jbe	SHORT $L79630

; 1527 : 	{
; 1528 : 		*pMaxNumber = 0;

	mov	edx, DWORD PTR _pMaxNumber$[esp+80]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [edx], 0

; 1529 : 		return S_FALSE;

	mov	eax, 1
	pop	ebx

; 1603 : 	}

	add	esp, 68					; 00000044H
	ret	20					; 00000014H
$L79630:

; 1530 : 		}
; 1531 : 
; 1532 : 	for (p = 0; p < T.Processors; p++)

	mov	eax, DWORD PTR [esi+900]
	xor	edi, edi
	test	eax, eax
	jle	SHORT $L79634
	lea	eax, DWORD PTR [esi+1108]
$L79632:

; 1533 : 		for (i = 0; i < ThreadInfo[p].Found; i++)

	mov	edx, DWORD PTR [eax]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $L79633
	xor	edx, edx
$L79635:

; 1534 : 		{
; 1535 : 			Track2 &K = ThreadInfo[p].pSpace[i];
; 1536 : 			seqlength = K.Grains;
; 1537 : /*			for (j = 0; (j < seqlength) && ((IntTrackGrain *)K.pGrains)[j].T.pG->TrackLength < seqlength; j++);
; 1538 : 	
; 1539 : 			if (j < seqlength) 
; 1540 : 			{
; 1541 : 				K.Valid = false;
; 1542 : 				K.Grains = 0;
; 1543 : 				continue;
; 1544 : 				}
; 1545 : 			for (j = 0; j < seqlength; j++)
; 1546 : 			{
; 1547 : 				IntTrackGrain *pIG = ((IntTrackGrain *)K.pGrains) + j;
; 1548 : 				if (pIG->T.pG->pTrack2)
; 1549 : 				{
; 1550 : 					Track2 &N = *pIG->T.pG->pTrack2;
; 1551 : 					for (k = 0; k < N.Grains; k++)
; 1552 : 					{
; 1553 : 						IntTrackGrain *pIJ = ((IntTrackGrain *)N.pGrains) + k;
; 1554 : 						pIJ->T.pG->pTrack2 = 0;
; 1555 : 						pIJ->T.pG->TrackLength = 0;
; 1556 : 						}
; 1557 : 					N.Valid = false;
; 1558 : 					N.Grains = 0;
; 1559 : 					}
; 1560 : 				}
; 1561 : 
; 1562 : 			for (j = 0; j < seqlength; j++)
; 1563 : 			{
; 1564 : 				IntTrackGrain *pIG = ((IntTrackGrain *)K.pGrains) + j;
; 1565 : 				pIG->T.pG->pTrack2 = &K;
; 1566 : 				pIG->T.pG->TrackLength = seqlength;
; 1567 : 				}
; 1568 : */			K.Valid = true;

	mov	ebx, DWORD PTR [eax-8]
	inc	ecx
	mov	BYTE PTR [ebx+edx+56], 1
	mov	ebx, DWORD PTR [eax]
	add	edx, 60					; 0000003cH
	cmp	ecx, ebx
	jl	SHORT $L79635
$L79633:

; 1530 : 		}
; 1531 : 
; 1532 : 	for (p = 0; p < T.Processors; p++)

	mov	ecx, DWORD PTR [esi+900]
	inc	edi
	add	eax, 40					; 00000028H
	cmp	edi, ecx
	jl	SHORT $L79632
$L79634:

; 1569 : 			}
; 1570 : 
; 1571 : 	found = ThreadInfo[0].Found;
; 1572 : 	pTemp = (Grain *)malloc(sizeof(Grain) * T.LayerNum * T.InitialMultiplicity);

	mov	eax, DWORD PTR [esi+928]
	mov	ebx, DWORD PTR [esi+1108]
	imul	eax, DWORD PTR [esi+140]
	shl	eax, 4
	push	eax
	mov	DWORD PTR _found$[esp+88], ebx
	call	DWORD PTR __imp__malloc

; 1573 : 	for (p = 1; p < T.Processors; p++)

	mov	ecx, DWORD PTR [esi+900]
	mov	DWORD PTR _pTemp$[esp+88], eax
	mov	eax, 1
	add	esp, 4
	cmp	ecx, eax
	mov	DWORD PTR _p$[esp+84], eax
	jle	$L79643
	lea	ecx, DWORD PTR [esi+1148]
	mov	DWORD PTR 24+[esp+80], ecx
$L79641:

; 1574 : 		for (i = 0; i < ThreadInfo[p].Found; i++)

	mov	edx, DWORD PTR 24+[esp+80]
	xor	eax, eax
	mov	DWORD PTR _i$[esp+84], eax
	cmp	DWORD PTR [edx], eax
	jle	$L79642
	mov	ecx, DWORD PTR _pSpace$[esp+80]
	mov	DWORD PTR -64+[esp+84], eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [ecx+eax*4-56]
	mov	DWORD PTR -68+[esp+84], edx
$L79644:

; 1575 : 		{
; 1576 : 			TempF = ThreadInfo[p].pSpace[i].Field;

	mov	eax, DWORD PTR 24+[esp+80]
	mov	edx, DWORD PTR -64+[esp+84]

; 1577 : 			TempG = ThreadInfo[p].pSpace[i].Grains;
; 1578 : 			//if (TempV = ThreadInfo[p].pSpace[i].Valid)
; 1579 : 			TempV = ThreadInfo[p].pSpace[i].Valid;
; 1580 : 			memcpy(pTemp, ThreadInfo[p].pSpace[i].pGrains, sizeof(Grain) * TempG);

	mov	edi, DWORD PTR _pTemp$[esp+84]
	mov	ecx, DWORD PTR [eax-8]
	mov	eax, DWORD PTR [edx+ecx]
	add	edx, ecx
	mov	DWORD PTR _TempF$[esp+84], eax
	mov	cl, BYTE PTR [edx+56]
	mov	eax, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR _TempG$[esp+84], eax
	test	cl, cl
	setne	BYTE PTR _TempV$[esp+80]
	shl	eax, 4
	mov	ecx, eax

; 1581 : 			for (j = 0; (j < found) && (pSpace[j].Field < TempF); j++);

	xor	ebp, ebp
	mov	edx, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	test	ebx, ebx
	rep movsb
	jle	SHORT $L79653

; 1575 : 		{
; 1576 : 			TempF = ThreadInfo[p].pSpace[i].Field;

	mov	ecx, DWORD PTR _pSpace$[esp+80]
$L79648:

; 1581 : 			for (j = 0; (j < found) && (pSpace[j].Field < TempF); j++);

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR _TempF$[esp+84]
	cmp	edx, esi
	jge	SHORT $L79650
	inc	ebp
	add	ecx, 60					; 0000003cH
	cmp	ebp, ebx
	jl	SHORT $L79648

; 1582 : 			for (k = found; k > j; k--)

	jmp	SHORT $L79653
$L79650:
	cmp	ebx, ebp
	jle	SHORT $L79653
	mov	edx, DWORD PTR -68+[esp+84]
	sub	ebx, ebp
	mov	DWORD PTR -56+[esp+84], ebx
$L79651:

; 1583 : 			{
; 1584 : 				pSpace[k].Field = pSpace[k - 1].Field;

	mov	ecx, DWORD PTR [edx-4]
	mov	DWORD PTR [edx+56], ecx

; 1585 : 				pSpace[k].Grains = pSpace[k - 1].Grains;

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx+60], ecx

; 1586 : 				//if (pSpace[k].Valid = pSpace[k - 1].Valid)
; 1587 : 				pSpace[k].Valid = pSpace[k - 1].Valid;

	mov	cl, BYTE PTR [edx+52]
	mov	BYTE PTR [edx+112], cl

; 1588 : 				memcpy(pSpace[k].pGrains, pSpace[k - 1].pGrains, sizeof(Grain) * pSpace[k].Grains);

	mov	ecx, DWORD PTR [edx+60]
	mov	esi, DWORD PTR [edx+8]
	mov	edi, DWORD PTR [edx+68]
	shl	ecx, 4
	mov	ebx, ecx
	sub	edx, 60					; 0000003cH
	shr	ecx, 2
	rep movsd
	mov	ecx, ebx
	and	ecx, 3
	rep movsb
	mov	ecx, DWORD PTR -56+[esp+84]
	dec	ecx
	mov	DWORD PTR -56+[esp+84], ecx
	jne	SHORT $L79651

; 1582 : 			for (k = found; k > j; k--)

	mov	ebx, DWORD PTR _found$[esp+84]
$L79653:

; 1589 : 				}
; 1590 : 			pSpace[j].Field = TempF;

	mov	ecx, DWORD PTR _pSpace$[esp+80]
	lea	ebp, DWORD PTR [ebp+ebp*2]

; 1591 : 			pSpace[j].Grains = TempG;
; 1592 : 			//if (pSpace[j].Valid = TempV)
; 1593 : 			pSpace[j].Valid = TempV;
; 1594 : 			memcpy(pSpace[j].pGrains, pTemp, sizeof(Grain) * TempG);

	mov	esi, DWORD PTR _pTemp$[esp+84]
	lea	edx, DWORD PTR [ebp+ebp*4]

; 1595 : 			found++;

	mov	ebp, DWORD PTR -68+[esp+84]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _TempF$[esp+84]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR _TempG$[esp+84]
	mov	DWORD PTR [edx+4], ecx
	mov	cl, BYTE PTR _TempV$[esp+80]
	mov	BYTE PTR [edx+56], cl
	mov	edi, DWORD PTR [edx+12]
	mov	ecx, eax
	mov	eax, DWORD PTR _i$[esp+84]
	mov	edx, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	inc	ebx
	rep movsb
	mov	esi, DWORD PTR -64+[esp+84]
	mov	ecx, 60					; 0000003cH
	add	ebp, ecx
	add	esi, ecx
	mov	ecx, DWORD PTR 24+[esp+80]
	inc	eax
	mov	DWORD PTR _found$[esp+84], ebx
	mov	DWORD PTR -68+[esp+84], ebp
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _i$[esp+84], eax
	cmp	eax, edx
	mov	DWORD PTR -64+[esp+84], esi
	jl	$L79644

; 1574 : 		for (i = 0; i < ThreadInfo[p].Found; i++)

	mov	esi, DWORD PTR _this$[esp+80]
$L79642:

; 1573 : 	for (p = 1; p < T.Processors; p++)

	mov	eax, DWORD PTR _p$[esp+84]
	mov	edx, DWORD PTR 24+[esp+80]
	mov	ecx, DWORD PTR [esi+900]
	inc	eax
	add	edx, 40					; 00000028H
	cmp	eax, ecx
	mov	DWORD PTR _p$[esp+84], eax
	mov	DWORD PTR 24+[esp+80], edx
	jl	$L79641
$L79643:

; 1596 : 			}
; 1597 : 	free(pTemp);

	mov	edx, DWORD PTR _pTemp$[esp+84]
	push	edx
	call	DWORD PTR __imp__free

; 1598 : 
; 1599 : 
; 1600 : 	*pMaxNumber = FinalizeTracks(found, pSpace);

	mov	eax, DWORD PTR _pSpace$[esp+84]
	add	esp, 4
	mov	ecx, esi
	push	eax
	push	ebx
	call	?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z ; CSmartTrackerClass::FinalizeTracks
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR _pMaxNumber$[esp+72]
	pop	ebp
	pop	ebx
	mov	DWORD PTR [ecx], eax

; 1601 : 
; 1602 : 	return S_OK;

	xor	eax, eax

; 1603 : 	}

	add	esp, 68					; 00000044H
	ret	20					; 00000014H
?GetTracks2@CSmartTrackerClass@@UAGJPAUTrack2@@PAHHH@Z ENDP ; CSmartTrackerClass::GetTracks2
_TEXT	ENDS
PUBLIC	?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z ; CSmartTrackerClass::GetMaxGrainsPerTrack
;	COMDAT ?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z
_TEXT	SEGMENT
_pMaxGrains$ = 12
_this$ = 8
?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z PROC NEAR ; CSmartTrackerClass::GetMaxGrainsPerTrack, COMDAT

; 1607 : 	*pMaxGrains = T.LayerNum * T.InitialMultiplicity;

	mov	eax, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR _pMaxGrains$[esp-4]
	mov	ecx, DWORD PTR [eax+928]
	imul	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR [edx], ecx

; 1608 : 	return S_OK;

	xor	eax, eax

; 1609 : 	}

	ret	8
?GetMaxGrainsPerTrack@CSmartTrackerClass@@UAGJPAH@Z ENDP ; CSmartTrackerClass::GetMaxGrainsPerTrack
_TEXT	ENDS
PUBLIC	?InitTrackerData@CSmartTrackerClass@@IAEXXZ	; CSmartTrackerClass::InitTrackerData
;	COMDAT ?InitTrackerData@CSmartTrackerClass@@IAEXXZ
_TEXT	SEGMENT
_Temp$ = -72
?InitTrackerData@CSmartTrackerClass@@IAEXXZ PROC NEAR	; CSmartTrackerClass::InitTrackerData, COMDAT

; 1614 : {

	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 1615 : 	SySalConfig Temp = {0, 0, 0};

	xor	ebx, ebx
	mov	ecx, 17					; 00000011H
	xor	eax, eax
	lea	edi, DWORD PTR _Temp$[esp+87]
	mov	BYTE PTR _Temp$[esp+84], bl
	mov	BYTE PTR _Temp$[esp+85], bl
	mov	BYTE PTR _Temp$[esp+86], bl

; 1616 : 	GetData(Temp, ConfigDataN, ConfigDataQDI, &T, true);

	push	1
	rep stosd
	stosb
	lea	eax, DWORD PTR [esi+136]
	lea	ecx, DWORD PTR _Temp$[esp+88]
	push	eax
	push	OFFSET FLAT:?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	ecx
	call	?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ; GetData
	add	esp, 20					; 00000014H

; 1617 : 
; 1618 : 	T.GrainSpace = 0;

	mov	DWORD PTR [esi+936], ebx

; 1619 : 	T.ZLayer = 0;

	mov	DWORD PTR [esi+940], ebx

; 1620 : 	T.LayerGrains = 0;

	mov	DWORD PTR [esi+944], ebx

; 1621 : 	T.CellSpace = 0;

	mov	DWORD PTR [esi+948], ebx

; 1622 : 	T.pDeltaHisto2d = 0;

	mov	DWORD PTR [esi+1040], ebx

; 1623 : 	T.pDeltaData = 0;

	mov	DWORD PTR [esi+1044], ebx

; 1624 : 	T.pX = T.pY = T.pDX = T.pDY = 0;

	mov	DWORD PTR [esi+1060], ebx
	mov	DWORD PTR [esi+1056], ebx
	mov	DWORD PTR [esi+1052], ebx
	mov	DWORD PTR [esi+1048], ebx

; 1625 : 	T.pReplicas = 0;

	mov	DWORD PTR [esi+1064], ebx
	pop	edi
	pop	esi
	pop	ebx

; 1626 : }

	add	esp, 72					; 00000048H
	ret	0
?InitTrackerData@CSmartTrackerClass@@IAEXXZ ENDP	; CSmartTrackerClass::InitTrackerData
_TEXT	ENDS
PUBLIC	?GetCell@CSmartTrackerClass@@IAEHMM@Z		; CSmartTrackerClass::GetCell
;	COMDAT ?GetCell@CSmartTrackerClass@@IAEHMM@Z
_TEXT	SEGMENT
_Xp$ = 8
_Yp$ = 12
?GetCell@CSmartTrackerClass@@IAEHMM@Z PROC NEAR		; CSmartTrackerClass::GetCell, COMDAT

; 1630 : 	int Icl;
; 1631 : 	if ((Xp < T.Win.Xmin) || (Xp >= T.Win.Xmax) ||
; 1632 : 		(Yp < T.Win.Ymin) || (Yp >= T.Win.Ymax)) return -1;

	fld	DWORD PTR _Xp$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	fcomp	DWORD PTR [esi+956]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L79676
	fld	DWORD PTR _Xp$[esp+4]
	fcomp	DWORD PTR [esi+960]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79676
	fld	DWORD PTR _Yp$[esp+4]
	fcomp	DWORD PTR [esi+964]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L79676
	fld	DWORD PTR _Yp$[esp+4]
	fcomp	DWORD PTR [esi+968]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79676

; 1633 : 	Icl = ((int)((Yp - T.Win.Ymin) / T.DyCell)) * T.CellNumX +
; 1634 : 		(int)((Xp - T.Win.Xmin) / T.DxCell);

	fld	DWORD PTR _Yp$[esp+4]
	fsub	DWORD PTR [esi+964]
	fdiv	DWORD PTR [esi+976]
	call	__ftol
	fld	DWORD PTR _Xp$[esp+4]
	fsub	DWORD PTR [esi+956]
	mov	edi, eax
	imul	edi, DWORD PTR [esi+148]
	fdiv	DWORD PTR [esi+972]
	call	__ftol
	add	edi, eax

; 1635 : 	if ((Icl >= 0) && (Icl < T.CellsInLayer)) return Icl;

	js	SHORT $L79676
	cmp	edi, DWORD PTR [esi+952]
	jge	SHORT $L79676
	mov	eax, edi
	pop	edi
	pop	esi

; 1636 : 	return -1;
; 1637 : 	};

	ret	8
$L79676:
	pop	edi

; 1630 : 	int Icl;
; 1631 : 	if ((Xp < T.Win.Xmin) || (Xp >= T.Win.Xmax) ||
; 1632 : 		(Yp < T.Win.Ymin) || (Yp >= T.Win.Ymax)) return -1;

	or	eax, -1
	pop	esi

; 1636 : 	return -1;
; 1637 : 	};

	ret	8
?GetCell@CSmartTrackerClass@@IAEHMM@Z ENDP		; CSmartTrackerClass::GetCell
_TEXT	ENDS
PUBLIC	__real@4@3fffc000000000000000
;	COMDAT __real@4@3fffc000000000000000
; File D:\SySal2\SmartTracker8\SmartTrackerClass.cpp
CONST	SEGMENT
__real@4@3fffc000000000000000 DD 03fc00000r	; 1.5
CONST	ENDS
;	COMDAT ?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_dirx$ = 16
_diry$ = 20
_dirtol$ = 24
_normtol$ = 28
_pDest$ = 32
_pDist$ = 36
_maxmult$ = 40
_normdist$ = -16
_dx$ = 36
_dy$ = -20
_pEnd$ = -4
_reddirtol$ = -12
_pScan$ = -8
?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z PROC NEAR ; Cell::FindGrains, COMDAT

; 1640 : {

	sub	esp, 20					; 00000014H

; 1641 : 	int i, j;
; 1642 : 	float normdist;
; 1643 : 	float dx, dy;
; 1644 : 	IntGrain *pStart = FirstG;
; 1645 : 	IntGrain *pEnd = FirstG + Free;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 1646 : 	float reddirtol = dirtol * 1.5f;

	fld	DWORD PTR _dirtol$[esp+16]
	fmul	DWORD PTR __real@4@3fffc000000000000000
	lea	ecx, DWORD PTR [ecx+ecx*4]
	push	edi

; 1647 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	mov	edi, eax
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pScan$[esp+24], edi
	fstp	DWORD PTR _reddirtol$[esp+24]
	cmp	edi, ecx
	mov	DWORD PTR _pEnd$[esp+24], ecx
	jae	$L79700
	push	ebx
	mov	ebx, DWORD PTR _pDist$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR _pDest$[esp+28]
	push	esi
	mov	esi, DWORD PTR _maxmult$[esp+32]
$L79698:

; 1648 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [edi]
	fsub	DWORD PTR _x$[esp+32]
	fst	DWORD PTR _dx$[esp+32]
	fabs
	fld	DWORD PTR _reddirtol$[esp+36]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	$L79699

; 1649 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [edi+4]
	fsub	DWORD PTR _y$[esp+32]
	fst	DWORD PTR _dy$[esp+36]
	fabs
	fld	DWORD PTR _reddirtol$[esp+36]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	$L79699

; 1650 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fld	DWORD PTR _dy$[esp+36]
	fmul	DWORD PTR _dirx$[esp+32]
	fld	DWORD PTR _dx$[esp+32]
	fmul	DWORD PTR _diry$[esp+32]
	fsubp	ST(1), ST(0)
	fabs
	fst	DWORD PTR _normdist$[esp+36]
	fcomp	DWORD PTR _normtol$[esp+32]
	fnstsw	ax
	test	ah, 1
	je	$L79699

; 1651 : 					if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	DWORD PTR _dx$[esp+32]
	fmul	DWORD PTR _dirx$[esp+32]
	fld	DWORD PTR _dy$[esp+36]
	fmul	DWORD PTR _diry$[esp+32]
	faddp	ST(1), ST(0)
	fabs
	fld	DWORD PTR _dirtol$[esp+32]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79699

; 1652 : 					{
; 1653 : 						for (i = 0; i < maxmult && pDist[i] <= normdist; i++);

	xor	edx, edx
	test	esi, esi
	jle	SHORT $L79707
	mov	ecx, ebx
$L79705:
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR _normdist$[esp+36]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L79707
	inc	edx
	add	ecx, 4
	cmp	edx, esi
	jl	SHORT $L79705
$L79707:

; 1654 : 						if (i == maxmult) continue;

	cmp	edx, esi
	je	SHORT $L79699

; 1655 : 						for (j = maxmult - 1; j > i; j--)

	lea	ecx, DWORD PTR [esi-1]
	cmp	ecx, edx
	jle	SHORT $L79711
	mov	edi, ebx
	lea	esi, DWORD PTR [ebx+ecx*4]
	lea	eax, DWORD PTR [ebp+ecx*4-4]
	sub	edi, ebp
	sub	ecx, edx
$L79709:

; 1656 : 						{
; 1657 : 							pDist[j] = pDist[j - 1];

	mov	ebp, DWORD PTR [edi+eax]
	sub	eax, 4
	mov	DWORD PTR [esi], ebp

; 1658 : 							pDest[j] = pDest[j - 1];

	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ebp
	sub	esi, 4
	dec	ecx
	jne	SHORT $L79709
	mov	edi, DWORD PTR _pScan$[esp+36]
	mov	ebp, DWORD PTR _pDest$[esp+32]
	mov	esi, DWORD PTR _maxmult$[esp+32]
$L79711:

; 1659 : 							}
; 1660 : 						pDest[i] = pScan;
; 1661 : 						pDist[i] = normdist;

	fld	DWORD PTR _normdist$[esp+36]
	mov	DWORD PTR [ebp+edx*4], edi
	fstp	DWORD PTR [ebx+edx*4]
$L79699:
	mov	eax, DWORD PTR _pEnd$[esp+36]
	add	edi, 20					; 00000014H
	cmp	edi, eax
	mov	DWORD PTR _pScan$[esp+36], edi
	jb	$L79698
	pop	esi
	pop	ebp
	pop	ebx
$L79700:
	pop	edi

; 1662 : 						};
; 1663 : 	}

	add	esp, 20					; 00000014H
	ret	36					; 00000024H
?FindGrains@Cell@@QAEXMMMMMMPAPAUIntGrain@@PAMH@Z ENDP	; Cell::FindGrains
_TEXT	ENDS
;	COMDAT ?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_dirx$ = 16
_diry$ = 20
_dirtol$ = 24
_normtol$ = 28
_bestnormdist$ = -4
_normdist$ = -12
_dx$ = -20
_dy$ = -16
_reddirtol$ = -8
?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z PROC NEAR	; Cell::FindGrain, COMDAT

; 1666 : {	

	sub	esp, 20					; 00000014H

; 1667 : 	IntGrain *pBest = 0;
; 1668 : 	int i;
; 1669 : 	float bestnormdist, normdist;
; 1670 : 	float dx, dy;
; 1671 : 	IntGrain *pStart = FirstG;
; 1672 : 	IntGrain *pEnd = FirstG + Free;
; 1673 : 	float reddirtol = dirtol * 1.5f;

	fld	DWORD PTR _dirtol$[esp+16]
	mov	eax, ecx
	push	esi
	fmul	DWORD PTR __real@4@3fffc000000000000000
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	xor	esi, esi
	lea	eax, DWORD PTR [eax+eax*4]
	fstp	DWORD PTR _reddirtol$[esp+24]
	lea	edx, DWORD PTR [ecx+eax*4]

; 1674 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	cmp	ecx, edx
	jae	$L80791
$L79731:

; 1675 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _x$[esp+20]
	fst	DWORD PTR _dx$[esp+24]
	fabs
	fld	DWORD PTR _reddirtol$[esp+24]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L79732

; 1676 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _y$[esp+20]
	fst	DWORD PTR _dy$[esp+24]
	fabs
	fld	DWORD PTR _reddirtol$[esp+24]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L79732

; 1677 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < normtol)

	fld	DWORD PTR _dy$[esp+24]
	fmul	DWORD PTR _dirx$[esp+20]
	fld	DWORD PTR _dx$[esp+24]
	fmul	DWORD PTR _diry$[esp+20]
	fsubp	ST(1), ST(0)
	fabs
	fst	DWORD PTR _normdist$[esp+24]
	fcomp	DWORD PTR _normtol$[esp+20]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79732

; 1678 : 					if (!pBest || normdist < bestnormdist)

	test	esi, esi
	je	SHORT $L79738
	fld	DWORD PTR _normdist$[esp+24]
	fcomp	DWORD PTR _bestnormdist$[esp+24]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79732
$L79738:

; 1679 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	DWORD PTR _dx$[esp+24]
	fmul	DWORD PTR _dirx$[esp+20]
	fld	DWORD PTR _dy$[esp+24]
	fmul	DWORD PTR _diry$[esp+20]
	faddp	ST(1), ST(0)
	fabs
	fld	DWORD PTR _dirtol$[esp+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79732

; 1680 : 						{
; 1681 : 							bestnormdist = normdist;

	mov	eax, DWORD PTR _normdist$[esp+24]

; 1682 : 							pBest = pScan;

	mov	esi, ecx
	mov	DWORD PTR _bestnormdist$[esp+24], eax
$L79732:
	add	ecx, 20					; 00000014H
	cmp	ecx, edx
	jb	$L79731
$L80791:

; 1683 : 							};
; 1684 : 	return pBest;

	mov	eax, esi
	pop	esi

; 1685 : 	};

	add	esp, 20					; 00000014H
	ret	24					; 00000018H
?FindGrain@Cell@@QAEPAUIntGrain@@MMMMMM@Z ENDP		; Cell::FindGrain
_TEXT	ENDS
;	COMDAT ?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_dirx$ = 16
_diry$ = 20
_dirtol$ = 24
_normtol$ = 28
_pTopShadow$ = 32
_pBottomShadow$ = 36
_xshadowtol$ = 40
_yshadowtol$ = 44
_normdist$ = 32
_dx$ = 28
_dy$ = 36
_reddirtol$ = -4
?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z PROC NEAR ; Cell::FindGrainNoShadow, COMDAT

; 1688 : {

	push	ecx

; 1689 : 	IntGrain *pBest = 0;
; 1690 : 	int i;
; 1691 : 	float bestnormdist = normtol, normdist;

	fld	DWORD PTR _normtol$[esp]

; 1692 : 	float dx, dy;
; 1693 : 	IntGrain *pStart = FirstG;
; 1694 : 	IntGrain *pEnd = FirstG + Free;
; 1695 : 	float reddirtol = dirtol * 1.5f;

	fld	DWORD PTR _dirtol$[esp]
	mov	eax, ecx
	push	ebx
	fmul	DWORD PTR __real@4@3fffc000000000000000
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	xor	ebx, ebx
	lea	eax, DWORD PTR [eax+eax*4]
	fstp	DWORD PTR _reddirtol$[esp+8]
	lea	edx, DWORD PTR [ecx+eax*4]

; 1696 : 	for (IntGrain *pScan = pStart; pScan < pEnd; pScan++)

	cmp	ecx, edx
	jae	$L80796
	push	esi
	mov	esi, DWORD PTR _pBottomShadow$[esp+8]
	push	edi
	mov	edi, DWORD PTR _pTopShadow$[esp+12]
$L79763:

; 1697 : 		if (fabs(dx = (pScan->Xcm - x)) <= reddirtol)

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _x$[esp+12]
	fst	DWORD PTR _dx$[esp+12]
	fabs
	fld	DWORD PTR _reddirtol$[esp+16]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	$L79764

; 1698 : 			if (fabs(dy = (pScan->Ycm - y)) <= reddirtol)

	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _y$[esp+12]
	fst	DWORD PTR _dy$[esp+12]
	fabs
	fld	DWORD PTR _reddirtol$[esp+16]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	$L79764

; 1699 : 				if ((normdist = fabs(dy * dirx - dx * diry)) < bestnormdist)

	fld	DWORD PTR _dy$[esp+12]
	fmul	DWORD PTR _dirx$[esp+12]
	fld	DWORD PTR _dx$[esp+12]
	fmul	DWORD PTR _diry$[esp+12]
	fsubp	ST(1), ST(0)
	fabs
	fst	DWORD PTR _normdist$[esp+12]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	je	$L79764

; 1700 : 				{
; 1701 : 					if (pTopShadow && fabs(pTopShadow->Xcm - pScan->Xcm) < xshadowtol && fabs(pTopShadow->Ycm - pScan->Ycm) < yshadowtol) continue;

	test	edi, edi
	je	SHORT $L79769
	fld	DWORD PTR [edi]
	fsub	DWORD PTR [ecx]
	fabs
	fld	DWORD PTR _xshadowtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79769
	fld	DWORD PTR [edi+4]
	fsub	DWORD PTR [ecx+4]
	fabs
	fld	DWORD PTR _yshadowtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L79764
$L79769:

; 1702 : 					if (pBottomShadow && fabs(pBottomShadow->Xcm - pScan->Xcm) < xshadowtol && fabs(pBottomShadow->Ycm - pScan->Ycm) < yshadowtol) continue;

	test	esi, esi
	je	SHORT $L79770
	fld	DWORD PTR [esi]
	fsub	DWORD PTR [ecx]
	fabs
	fld	DWORD PTR _xshadowtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79770
	fld	DWORD PTR [esi+4]
	fsub	DWORD PTR [ecx+4]
	fabs
	fld	DWORD PTR _yshadowtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L79764
$L79770:

; 1703 : 					if (normdist < bestnormdist)

	fld	DWORD PTR _normdist$[esp+12]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	je	SHORT $L79764

; 1704 : 						if (fabs(dx * dirx + dy * diry) < dirtol)

	fld	DWORD PTR _dx$[esp+12]
	fmul	DWORD PTR _dirx$[esp+12]
	fld	DWORD PTR _dy$[esp+12]
	fmul	DWORD PTR _diry$[esp+12]
	faddp	ST(1), ST(0)
	fabs
	fld	DWORD PTR _dirtol$[esp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L79764
	fstp	ST(0)

; 1705 : 						{
; 1706 : 							bestnormdist = normdist;

	fld	DWORD PTR _normdist$[esp+12]

; 1707 : 							pBest = pScan;

	mov	ebx, ecx
$L79764:
	add	ecx, 20					; 00000014H
	cmp	ecx, edx
	jb	$L79763
	pop	edi

; 1708 : 							};
; 1709 : 					}
; 1710 : 	return pBest;

	mov	eax, ebx
	pop	esi
	pop	ebx
	fstp	ST(0)

; 1711 : 	};

	pop	ecx
	ret	40					; 00000028H
$L80796:

; 1708 : 							};
; 1709 : 					}
; 1710 : 	return pBest;

	mov	eax, ebx
	pop	ebx
	fstp	ST(0)

; 1711 : 	};

	pop	ecx
	ret	40					; 00000028H
?FindGrainNoShadow@Cell@@QAEPAUIntGrain@@MMMMMMPAU2@0MM@Z ENDP ; Cell::FindGrainNoShadow
_TEXT	ENDS
;	COMDAT ?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z
_TEXT	SEGMENT
_pTempGrains$ = 8
_Layers$ = 12
_SequenceLength$ = 16
_pTracks$ = 20
_NTracks$ = 24
_this$ = -4
?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z PROC NEAR ; CSmartTrackerClass::InsertNewTrack, COMDAT

; 1714 : {

	sub	esp, 8
	push	ebx
	mov	DWORD PTR _this$[esp+12], ecx
	push	ebp

; 1715 : 	int i, j;
; 1716 : 	for (i = 0; i < Layers; i++)

	mov	ebp, DWORD PTR _Layers$[esp+12]
	xor	ecx, ecx
	xor	eax, eax
	push	esi
	cmp	ebp, ecx
	push	edi
	jle	SHORT $L79789
	mov	esi, DWORD PTR _pTempGrains$[esp+20]
$L79783:

; 1717 : 		if (pTempGrains[i] && pTempGrains[i]->TrackLength >= SequenceLength) return;

	mov	edx, DWORD PTR [esi]
	cmp	edx, ecx
	je	SHORT $L79784
	mov	edi, DWORD PTR _SequenceLength$[esp+20]
	mov	ebx, DWORD PTR [edx+12]
	cmp	ebx, edi
	jge	$L79780
$L79784:

; 1715 : 	int i, j;
; 1716 : 	for (i = 0; i < Layers; i++)

	inc	eax
	add	esi, 4
	cmp	eax, ebp
	jl	SHORT $L79783

; 1718 : 	for (i = 0; i < Layers; i++)

	cmp	ebp, ecx
	jle	SHORT $L79789
	mov	ebx, DWORD PTR _pTempGrains$[esp+20]
	mov	DWORD PTR -8+[esp+24], ebp
$L79787:

; 1719 : 		if (pTempGrains[i] && pTempGrains[i]->pTrack)

	mov	eax, DWORD PTR [ebx]
	cmp	eax, ecx
	je	SHORT $L79788
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, ecx
	je	SHORT $L79788

; 1722 : 			for (j = 0; j < N.PointsN; j++)

	mov	eax, DWORD PTR [edx+4]
	xor	esi, esi
	cmp	eax, ecx
	jbe	SHORT $L79794

; 1720 : 		{
; 1721 : 			Track &N = *pTempGrains[i]->pTrack;

	xor	edi, edi
$L79792:

; 1723 : 			{
; 1724 : 				IntGrain *pG = ((IntTrackVector *)N.pPoints)[j].T.pG;

	mov	eax, DWORD PTR [edx+8]
	inc	esi
	mov	eax, DWORD PTR [edi+eax]
	add	edi, 12					; 0000000cH

; 1725 : 				pG->TrackLength = 0;

	mov	DWORD PTR [eax+12], ecx

; 1726 : 				pG->pTrack = 0;

	mov	DWORD PTR [eax+16], ecx
	cmp	esi, DWORD PTR [edx+4]
	jb	SHORT $L79792
$L79794:

; 1727 : 				}
; 1728 : 			N.Valid = false;

	mov	BYTE PTR [edx+76], cl

; 1729 : 			N.PointsN = 0;

	mov	DWORD PTR [edx+4], ecx
$L79788:
	mov	eax, DWORD PTR -8+[esp+24]
	add	ebx, 4
	dec	eax
	mov	DWORD PTR -8+[esp+24], eax
	jne	SHORT $L79787
$L79789:

; 1730 : 			}
; 1731 : 	Track &N = pTracks[NTracks++];

	mov	esi, DWORD PTR _NTracks$[esp+20]
	mov	edi, DWORD PTR _pTracks$[esp+20]
	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+eax*4]
	shl	edx, 4
	add	edx, edi
	inc	eax

; 1732 : 	for (i = j = 0; i < Layers; i++)

	xor	edi, edi
	cmp	ebp, ecx
	mov	DWORD PTR [esi], eax
	jle	SHORT $L79800

; 1730 : 			}
; 1731 : 	Track &N = pTracks[NTracks++];

	xor	ebx, ebx
$L79798:

; 1733 : 		if (pTempGrains[i])

	mov	eax, DWORD PTR _pTempGrains$[esp+20]
	mov	esi, DWORD PTR [eax+edi*4]
	cmp	esi, ecx
	je	SHORT $L79799

; 1734 : 		{
; 1735 : 			IntTrackVector *pIG = ((IntTrackVector *)N.pPoints) + j++;

	mov	eax, DWORD PTR [edx+8]

; 1736 : 			pIG->T.pG = pTempGrains[i];
; 1737 : 			pIG->T.pG->pTrack = &N;
; 1738 : 			pIG->T.pG->TrackLength = SequenceLength;

	mov	ebp, DWORD PTR _SequenceLength$[esp+20]
	add	eax, ebx
	add	ebx, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi+16], edx
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [esi+12], ebp

; 1739 : 			pIG->T.Z = T.ZLayer[i];

	mov	esi, DWORD PTR _this$[esp+24]
	mov	ebp, DWORD PTR _Layers$[esp+20]
	mov	esi, DWORD PTR [esi+940]
	mov	esi, DWORD PTR [esi+edi*4]
	mov	DWORD PTR [eax+4], esi
$L79799:
	inc	edi
	cmp	edi, ebp
	jl	SHORT $L79798
$L79800:

; 1740 : 			}
; 1741 : 	N.Valid = true;
; 1742 : 	N.PointsN = SequenceLength;

	mov	ecx, DWORD PTR _SequenceLength$[esp+20]
	mov	BYTE PTR [edx+76], 1
	mov	DWORD PTR [edx+4], ecx
$L79780:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1743 : };

	add	esp, 8
	ret	20					; 00000014H
?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack@@AAH@Z ENDP ; CSmartTrackerClass::InsertNewTrack
_TEXT	ENDS
PUBLIC	?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z ; CSmartTrackerClass::InsertNewTrack
;	COMDAT ?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z
_TEXT	SEGMENT
_pTempGrains$ = 8
_Layers$ = 12
_SequenceLength$ = 16
_pTracks$ = 20
_NTracks$ = 24
_this$ = -4
?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z PROC NEAR ; CSmartTrackerClass::InsertNewTrack, COMDAT

; 1746 : {

	sub	esp, 8
	push	ebx
	mov	DWORD PTR _this$[esp+12], ecx
	push	ebp

; 1747 : 	int i, j;
; 1748 : 	for (i = 0; i < Layers; i++)

	mov	ebp, DWORD PTR _Layers$[esp+12]
	xor	ecx, ecx
	xor	eax, eax
	push	esi
	cmp	ebp, ecx
	push	edi
	jle	SHORT $L79820
	mov	esi, DWORD PTR _pTempGrains$[esp+20]
$L79814:

; 1749 : 		if (pTempGrains[i] && pTempGrains[i]->TrackLength >= SequenceLength) return;

	mov	edx, DWORD PTR [esi]
	cmp	edx, ecx
	je	SHORT $L79815
	mov	edi, DWORD PTR _SequenceLength$[esp+20]
	mov	ebx, DWORD PTR [edx+12]
	cmp	ebx, edi
	jge	$L79811
$L79815:

; 1747 : 	int i, j;
; 1748 : 	for (i = 0; i < Layers; i++)

	inc	eax
	add	esi, 4
	cmp	eax, ebp
	jl	SHORT $L79814

; 1750 : 	for (i = 0; i < Layers; i++)

	cmp	ebp, ecx
	jle	SHORT $L79820
	mov	ebx, DWORD PTR _pTempGrains$[esp+20]
	mov	DWORD PTR -8+[esp+24], ebp
$L79818:

; 1751 : 		if (pTempGrains[i] && pTempGrains[i]->pTrack2)

	mov	eax, DWORD PTR [ebx]
	cmp	eax, ecx
	je	SHORT $L79819
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, ecx
	je	SHORT $L79819

; 1754 : 			for (j = 0; j < N.Grains; j++)

	mov	eax, DWORD PTR [edx+4]
	xor	esi, esi
	cmp	eax, ecx
	jbe	SHORT $L79825

; 1752 : 		{
; 1753 : 			Track2 &N = *pTempGrains[i]->pTrack2;

	xor	edi, edi
$L79823:

; 1755 : 			{
; 1756 : 				IntGrain *pG = ((IntTrackGrain *)N.pGrains)[j].T.pG;

	mov	eax, DWORD PTR [edx+12]
	inc	esi
	mov	eax, DWORD PTR [edi+eax]
	add	edi, 16					; 00000010H

; 1757 : 				pG->TrackLength = 0;

	mov	DWORD PTR [eax+12], ecx

; 1758 : 				pG->pTrack2 = 0;

	mov	DWORD PTR [eax+16], ecx
	cmp	esi, DWORD PTR [edx+4]
	jb	SHORT $L79823
$L79825:

; 1759 : 				}
; 1760 : 			N.Valid = false;

	mov	BYTE PTR [edx+56], cl

; 1761 : 			N.Grains = 0;

	mov	DWORD PTR [edx+4], ecx
$L79819:
	mov	eax, DWORD PTR -8+[esp+24]
	add	ebx, 4
	dec	eax
	mov	DWORD PTR -8+[esp+24], eax
	jne	SHORT $L79818
$L79820:

; 1762 : 			}
; 1763 : 	Track2 &N = pTracks[NTracks++];

	mov	esi, DWORD PTR _NTracks$[esp+20]
	mov	edi, DWORD PTR _pTracks$[esp+20]
	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+eax*2]
	inc	eax
	mov	DWORD PTR [esi], eax

; 1764 : 	for (i = j = 0; i < Layers; i++)

	xor	esi, esi
	lea	edx, DWORD PTR [edx+edx*4]
	cmp	ebp, ecx
	lea	edi, DWORD PTR [edi+edx*4]
	jle	SHORT $L79831

; 1762 : 			}
; 1763 : 	Track2 &N = pTracks[NTracks++];

	xor	ebx, ebx
$L79829:

; 1765 : 		if (pTempGrains[i])

	mov	eax, DWORD PTR _pTempGrains$[esp+20]
	mov	edx, DWORD PTR [eax+esi*4]
	cmp	edx, ecx
	je	SHORT $L79830

; 1766 : 		{
; 1767 : 			IntTrackGrain *pIG = ((IntTrackGrain *)N.pGrains) + j++;

	mov	eax, DWORD PTR [edi+12]

; 1768 : 			pIG->T.pG = pTempGrains[i];
; 1769 : 			pIG->T.pG->pTrack2 = &N;
; 1770 : 			pIG->T.pG->TrackLength = SequenceLength;

	mov	ebp, DWORD PTR _SequenceLength$[esp+20]
	add	eax, ebx
	add	ebx, 16					; 00000010H
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [edx+16], edi
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [edx+12], ebp

; 1771 : 			pIG->T.Z = T.ZLayer[i];

	mov	edx, DWORD PTR _this$[esp+24]
	mov	ebp, DWORD PTR _Layers$[esp+20]
	mov	edx, DWORD PTR [edx+940]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [eax+4], edx
$L79830:
	inc	esi
	cmp	esi, ebp
	jl	SHORT $L79829
$L79831:

; 1772 : 			}
; 1773 : 	N.Valid = true;
; 1774 : 	N.Grains = SequenceLength;

	mov	eax, DWORD PTR _SequenceLength$[esp+20]
	mov	BYTE PTR [edi+56], 1
	mov	DWORD PTR [edi+4], eax
$L79811:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1775 : };

	add	esp, 8
	ret	20					; 00000014H
?InsertNewTrack@CSmartTrackerClass@@IAEXPAPAUIntGrain@@HHPAUTrack2@@AAH@Z ENDP ; CSmartTrackerClass::InsertNewTrack
_TEXT	ENDS
;	COMDAT ?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z
_TEXT	SEGMENT
_ntracks$ = 8
_pspace$ = 12
_j$ = 12
?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z PROC NEAR ; CSmartTrackerClass::FinalizeTracks, COMDAT

; 1778 : {

	push	ecx

; 1779 : 	int i, j, k;
; 1780 : 	for (i = j = 0; i < ntracks; i++)

	mov	ecx, DWORD PTR _ntracks$[esp]
	xor	eax, eax
	test	ecx, ecx
	jle	$L79845
	push	ebx
	mov	ebx, DWORD PTR _pspace$[esp+4]
	push	ebp
	push	esi
	mov	edx, ebx
	push	edi
	add	ebx, 76					; 0000004cH
	mov	DWORD PTR 8+[esp+16], ecx
$L79843:

; 1781 : 		if (pspace[i].Valid)

	cmp	BYTE PTR [ebx], 0
	je	SHORT $L79844

; 1784 : 			Track &N = pspace[j++];
; 1785 : 			N.PointsN = O.PointsN;

	mov	esi, DWORD PTR [ebx-72]
	mov	ecx, edx
	inc	eax
	add	edx, 80					; 00000050H
	mov	DWORD PTR [ecx+4], esi

; 1786 : 			O.Valid = false;

	mov	BYTE PTR [ebx], 0

; 1787 : 			N.Valid = true;
; 1788 : 			for (k = 0; k < N.PointsN; k++)

	mov	esi, DWORD PTR [ecx+4]
	xor	ebp, ebp
	test	esi, esi
	mov	DWORD PTR _j$[esp+16], eax
	mov	DWORD PTR -4+[esp+20], edx
	mov	BYTE PTR [ecx+76], 1
	jbe	SHORT $L79844

; 1782 : 		{
; 1783 : 			Track &O = pspace[i];

	xor	edx, edx
$L79849:

; 1789 : 			{
; 1790 : 				IntGrain *pG = ((IntTrackVector *)O.pPoints)[k].T.pG;

	mov	eax, DWORD PTR [ebx-68]
	inc	ebp
	mov	edi, DWORD PTR [eax+edx]
	lea	esi, DWORD PTR [eax+edx]

; 1791 : 				N.pPoints[k].Z = ((IntTrackVector *)O.pPoints)[k].T.Z;

	mov	eax, DWORD PTR [ecx+8]
	add	edx, 12					; 0000000cH
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+edx-4], esi

; 1792 : 				N.pPoints[k].X = pG->Xcm;

	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR [eax+edx-12], esi

; 1793 : 				N.pPoints[k].Y = pG->Ycm;

	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+edx-8], esi
	mov	eax, DWORD PTR [ecx+4]
	cmp	ebp, eax
	jb	SHORT $L79849
	mov	eax, DWORD PTR _j$[esp+16]
	mov	edx, DWORD PTR -4+[esp+20]
$L79844:
	mov	ecx, DWORD PTR 8+[esp+16]
	add	ebx, 80					; 00000050H
	dec	ecx
	mov	DWORD PTR 8+[esp+16], ecx
	jne	SHORT $L79843
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$L79845:

; 1794 : 				}
; 1795 : 			}
; 1796 : 	return j;
; 1797 : 	}

	pop	ecx
	ret	8
?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack@@@Z ENDP ; CSmartTrackerClass::FinalizeTracks
_TEXT	ENDS
;	COMDAT ?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z
_TEXT	SEGMENT
_ntracks$ = 8
_pspace$ = 12
_this$ = -12
_j$ = -8
_a$ = 8
_dsx$ = -20
?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z PROC NEAR ; CSmartTrackerClass::FinalizeTracks, COMDAT

; 1800 : {

	sub	esp, 20					; 00000014H

; 1801 : 	int i, j, k, a, ta;
; 1802 : 	float dsx, dsy;
; 1803 : 	if (T.Layer > 1)

	mov	edx, DWORD PTR [ecx+992]
	mov	DWORD PTR _this$[esp+20], ecx
	cmp	edx, 1
	jle	SHORT $L79867

; 1804 : 	{
; 1805 : 		dsx = T.DispX / (T.ZLayer[0] - T.ZLayer[T.Layer - 1]);

	mov	eax, DWORD PTR [ecx+940]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [eax+edx*4-4]
	fld	DWORD PTR [ecx+996]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _dsx$[esp+20]

; 1806 : 		dsy = T.DispY / (T.ZLayer[0] - T.ZLayer[T.Layer - 1]);

	fdivr	DWORD PTR [ecx+1000]

; 1807 : 		}
; 1808 : 	else dsx = dsy = 0.0f;

	jmp	SHORT $L79868
$L79867:
	fld	DWORD PTR __real@4@00000000000000000000
	mov	DWORD PTR _dsx$[esp+20], 0
$L79868:

; 1809 : 	for (i = j = 0; i < ntracks; i++)

	mov	ecx, DWORD PTR _ntracks$[esp+16]
	xor	eax, eax
	test	ecx, ecx
	jle	$L80837
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pspace$[esp+28]
	push	edi
	mov	DWORD PTR -16+[esp+36], ecx
	lea	edi, DWORD PTR [esi+56]
	mov	DWORD PTR 12+[esp+32], edi
$L79869:

; 1810 : 		if (pspace[i].Valid)

	mov	dl, BYTE PTR [edi]
	xor	ecx, ecx
	cmp	dl, cl
	je	$L79870

; 1813 : 			Track2 &N = pspace[j++];
; 1814 : 			N.Grains = O.Grains;

	mov	ebx, DWORD PTR [edi-52]
	mov	edx, esi
	inc	eax
	add	esi, 60					; 0000003cH
	mov	DWORD PTR [edx+4], ebx

; 1815 : 			O.Valid = false;

	mov	BYTE PTR [edi], cl

; 1816 : 			N.Valid = true;
; 1817 : 			a = 0;
; 1818 : 			for (k = 0; k < N.Grains; k++)

	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR _j$[esp+36], eax
	cmp	ebx, ecx
	mov	DWORD PTR -4+[esp+36], esi
	mov	BYTE PTR [edx+56], 1
	mov	DWORD PTR _a$[esp+32], ecx
	jbe	SHORT $L79877

; 1811 : 		{
; 1812 : 			Track2 &O = pspace[i];

	xor	esi, esi
	jmp	SHORT $L79875
$L80838:
	mov	edi, DWORD PTR 12+[esp+32]
$L79875:

; 1819 : 			{
; 1820 : 				IntGrain *pG = ((IntTrackGrain *)O.pGrains)[k].T.pG;

	mov	eax, DWORD PTR [edi-44]
	mov	edi, DWORD PTR [eax+esi]

; 1821 : 				a += (ta = pG->Area);

	mov	ebp, DWORD PTR [edi+8]
	lea	ebx, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR _a$[esp+32]

; 1822 : 				float dz = (N.pGrains[k].Z = ((IntTrackGrain *)O.pGrains)[k].T.Z) - T.ZLayer[0];

	mov	ebx, DWORD PTR [ebx+4]
	add	eax, ebp
	mov	DWORD PTR _a$[esp+32], eax
	mov	eax, DWORD PTR [edx+12]
	inc	ecx
	mov	DWORD PTR [esi+eax+12], ebx
	mov	eax, DWORD PTR [edx+12]
	fld	DWORD PTR [esi+eax+12]
	lea	ebx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR _this$[esp+36]
	mov	eax, DWORD PTR [eax+940]
	add	esi, 16					; 00000010H
	fsub	DWORD PTR [eax]

; 1823 : 				N.pGrains[k].X = pG->Xcm + dsx * dz;

	fld	ST(0)
	fmul	DWORD PTR _dsx$[esp+36]
	fadd	DWORD PTR [edi]
	fstp	DWORD PTR [ebx+4]

; 1824 : 				N.pGrains[k].Y = pG->Ycm + dsy * dz;				

	mov	eax, DWORD PTR [edx+12]
	fmul	ST(0), ST(1)
	fadd	DWORD PTR [edi+4]
	fstp	DWORD PTR [esi+eax-8]

; 1825 : 				N.pGrains[k].Area = ta;

	mov	eax, DWORD PTR [edx+12]
	mov	WORD PTR [esi+eax-16], bp
	mov	eax, DWORD PTR [edx+4]
	cmp	ecx, eax
	jb	SHORT $L80838
	mov	eax, DWORD PTR _j$[esp+36]
	mov	edi, DWORD PTR 12+[esp+32]
	mov	esi, DWORD PTR -4+[esp+36]
$L79877:

; 1826 : 				}
; 1827 : 			N.AreaSum = a;

	mov	ecx, DWORD PTR _a$[esp+32]
	mov	DWORD PTR [edx+8], ecx
$L79870:
	mov	ecx, DWORD PTR -16+[esp+36]
	add	edi, 60					; 0000003cH
	dec	ecx
	mov	DWORD PTR 12+[esp+32], edi
	mov	DWORD PTR -16+[esp+36], ecx
	jne	$L79869
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	fstp	ST(0)

; 1828 : 			}
; 1829 : 	return j;
; 1830 : }

	add	esp, 20					; 00000014H
	ret	8
$L80837:

; 1807 : 		}
; 1808 : 	else dsx = dsy = 0.0f;

	fstp	ST(0)

; 1828 : 			}
; 1829 : 	return j;
; 1830 : }

	add	esp, 20					; 00000014H
	ret	8
?FinalizeTracks@CSmartTrackerClass@@IAEHHPAUTrack2@@@Z ENDP ; CSmartTrackerClass::FinalizeTracks
_TEXT	ENDS
;	COMDAT ?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ
_TEXT	SEGMENT
?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ PROC NEAR	; CSmartTrackerClass::ResetDeltaHisto, COMDAT

; 1834 : {

	push	esi
	mov	esi, ecx

; 1835 : 	if (T.pDeltaHisto2d) GlobalFree(T.pDeltaHisto2d);

	mov	eax, DWORD PTR [esi+1040]
	test	eax, eax
	je	SHORT $L79885
	push	eax
	call	DWORD PTR __imp__GlobalFree@4
$L79885:

; 1836 : 	T.pDeltaHisto2d = 0;
; 1837 : 	T.DeltaDX = fabs(T.PixelToMicronX);

	fld	DWORD PTR [esi+980]
	fabs
	fst	DWORD PTR [esi+1024]

; 1838 : 	T.DeltaDY = fabs(T.PixelToMicronY);

	fld	DWORD PTR [esi+984]
	fabs
	fstp	DWORD PTR [esi+1028]

; 1839 : 	T.DeltaBinsX = (int)floor(T.ReplicaRadius / T.DeltaDX + 1) * 2 + 5;

	fld	DWORD PTR [esi+908]
	fdiv	ST(0), ST(1)
	sub	esp, 8
	mov	DWORD PTR [esi+1040], 0
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	QWORD PTR [esp]
	fstp	ST(0)
	call	DWORD PTR __imp__floor
	call	__ftol

; 1840 : 	T.DeltaBinsY = (int)floor(T.ReplicaRadius / T.DeltaDY + 1) * 2 + 5;

	fld	DWORD PTR [esi+908]
	fdiv	DWORD PTR [esi+1028]
	lea	eax, DWORD PTR [eax+eax+5]
	mov	DWORD PTR [esi+1032], eax
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	add	esp, 8
	call	__ftol

; 1841 : 	return T.pDeltaHisto2d = (int *)GlobalAlloc(GMEM_FIXED, sizeof(int) * T.DeltaBinsX * T.DeltaBinsY);

	mov	ecx, DWORD PTR [esi+1032]
	lea	eax, DWORD PTR [eax+eax+5]
	imul	ecx, eax
	shl	ecx, 2
	push	ecx
	push	0
	mov	DWORD PTR [esi+1036], eax
	call	DWORD PTR __imp__GlobalAlloc@8
	xor	edx, edx
	mov	DWORD PTR [esi+1040], eax
	test	eax, eax
	setne	dl
	mov	al, dl
	pop	esi

; 1842 : }

	ret	0
?ResetDeltaHisto@CSmartTrackerClass@@IAE_NXZ ENDP	; CSmartTrackerClass::ResetDeltaHisto
_TEXT	ENDS
PUBLIC	?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z ; CSmartTrackerClass::PutData
;	COMDAT ?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z
_TEXT	SEGMENT
_pConfig$ = 8
_pC$ = 12
?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z PROC NEAR ; CSmartTrackerClass::PutData, COMDAT

; 1850 : 	::PutData(*pConfig, ConfigDataN, ConfigDataQDI, pC);

	mov	eax, DWORD PTR _pC$[esp-4]
	mov	ecx, DWORD PTR _pConfig$[esp-4]
	push	eax
	push	OFFSET FLAT:?ConfigDataQDI@@3PAUQueryDataInfo@@A ; ConfigDataQDI
	push	200					; 000000c8H
	push	ecx
	call	?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutData
	add	esp, 16					; 00000010H

; 1851 : }

	ret	0
?PutData@CSmartTrackerClass@@SAXPAUSySalConfig@@PAUConfigData@@@Z ENDP ; CSmartTrackerClass::PutData
_TEXT	ENDS
PUBLIC	?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z ; CSmartTrackerClass::IsSigmaValid
;	COMDAT ?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z
_TEXT	SEGMENT
?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z PROC NEAR ; CSmartTrackerClass::IsSigmaValid, COMDAT

; 1855 : 	return false;

	xor	al, al

; 1856 : }

	ret	8
?IsSigmaValid@CSmartTrackerClass@@IAE_NPAPAUIntGrain@@H@Z ENDP ; CSmartTrackerClass::IsSigmaValid
_TEXT	ENDS
PUBLIC	??_C@_02MECO@?$CFd?$AA@				; `string'
PUBLIC	??_C@_02JBAA@?$CFf?$AA@				; `string'
EXTRN	__imp__sscanf:NEAR
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
; File D:\SySal2\SmartTracker8\..\Common\Config2.cpp
_DATA	SEGMENT
??_C@_02MECO@?$CFd?$AA@ DB '%d', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02JBAA@?$CFf?$AA@
_DATA	SEGMENT
??_C@_02JBAA@?$CFf?$AA@ DB '%f', 00H			; `string'
_DATA	ENDS
;	COMDAT ?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z
_TEXT	SEGMENT
_C$ = 8
_QueryDataCount$ = 12
_pQDI$ = 16
_pC$ = 20
_UseDefault$ = 24
_i$ = -4
?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z PROC NEAR ; GetData, COMDAT

; 6    : {

	push	ecx

; 7    : 	int i, j;
; 8    : 	char *pD;
; 9    : 	for (i = 0; i < QueryDataCount; i++)

	mov	eax, DWORD PTR _QueryDataCount$[esp]
	push	ebx
	push	ebp
	push	esi
	test	eax, eax
	push	edi
	mov	DWORD PTR _i$[esp+20], 0
	jle	$L79917
	mov	eax, DWORD PTR _pQDI$[esp+16]
	lea	ebx, DWORD PTR [eax+68]
$L79910:

; 10   : 	{
; 11   : 		for (j = 0; (j < C.CountOfItems) && strcmp(pQDI[i].Name, C.pItems + j * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN)); j++);

	mov	ecx, DWORD PTR _C$[esp+16]
	xor	edi, edi
	mov	eax, DWORD PTR [ecx+64]
	test	eax, eax
	mov	DWORD PTR 16+[esp+16], eax
	jle	SHORT $L79915
	mov	ebp, DWORD PTR [ecx+68]
$L79913:
	mov	esi, ebp
	lea	eax, DWORD PTR [ebx-68]
$L80854:
	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $L80855
	test	cl, cl
	je	SHORT $L80856
	mov	dl, BYTE PTR [eax+1]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $L80855
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L80854
$L80856:
	xor	eax, eax
	jmp	SHORT $L80857
$L80855:
	sbb	eax, eax
	sbb	eax, -1
$L80857:
	test	eax, eax
	je	SHORT $L80860
	mov	eax, DWORD PTR 16+[esp+16]
	inc	edi
	add	ebp, 128				; 00000080H
	cmp	edi, eax
	jl	SHORT $L79913
	jmp	SHORT $L79915
$L80860:
	mov	eax, DWORD PTR 16+[esp+16]
$L79915:

; 12   : 		if (j == C.CountOfItems)

	cmp	edi, eax
	jne	SHORT $L79916

; 13   : 		{
; 14   : 			if (UseDefault) pD = pQDI[i].Default;

	mov	al, BYTE PTR _UseDefault$[esp+16]
	test	al, al
	je	$L79917
	lea	eax, DWORD PTR [ebx+4]

; 15   : 			else return i;
; 16   : 			}
; 17   : 		else pD = C.pItems + j * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN;

	jmp	SHORT $L79919
$L79916:
	mov	eax, DWORD PTR _C$[esp+16]
	shl	edi, 7
	mov	ecx, DWORD PTR [eax+68]
	lea	eax, DWORD PTR [edi+ecx+64]
$L79919:

; 18   : 		switch (pQDI[i].Format)
; 19   : 		{

	movsx	ecx, BYTE PTR [ebx-4]
	dec	ecx
	je	SHORT $L79924
	dec	ecx
	je	SHORT $L79929
	dec	ecx
	jne	SHORT $L79917

; 25   : 
; 26   : 			case ST_STRING:	strncpy(((char *)pC + pQDI[i].Position), pD, SYSAL_MAXCONFIG_ENTRY_VALUE_LEN);

	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR _pC$[esp+16]
	push	64					; 00000040H
	add	edx, esi
	push	eax
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 27   : 							break;

	jmp	SHORT $L79911
$L79929:

; 21   : 							break;
; 22   : 
; 23   : 			case ST_FLOAT:	if (sscanf(pD, "%f", (float *)((char *)pC + pQDI[i].Position)) != 1) return i;

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _pC$[esp+16]
	add	ecx, edx
	push	ecx
	push	OFFSET FLAT:??_C@_02JBAA@?$CFf?$AA@	; `string'
	push	eax
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $L79917

; 24   : 							break;

	jmp	SHORT $L79911
$L79924:

; 20   : 			case ST_INT:	if (sscanf(pD, "%d", (int *)((char *)pC + pQDI[i].Position)) != 1) return i;

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _pC$[esp+16]
	add	edx, ecx
	push	edx
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	eax
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $L79917
$L79911:

; 7    : 	int i, j;
; 8    : 	char *pD;
; 9    : 	for (i = 0; i < QueryDataCount; i++)

	mov	eax, DWORD PTR _i$[esp+20]
	mov	ecx, DWORD PTR _QueryDataCount$[esp+16]
	inc	eax
	add	ebx, 136				; 00000088H
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+20], eax
	jl	$L79910
$L79917:

; 28   : 
; 29   : 			default:		return i;			
; 30   : 			};
; 31   : 		};
; 32   : 	return i;

	mov	eax, DWORD PTR _i$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 33   : 	};

	pop	ecx
	ret	0
?GetData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX_N@Z ENDP ; GetData
_TEXT	ENDS
PUBLIC	??_C@_02DLJH@?$CFg?$AA@				; `string'
EXTRN	__imp__sprintf:NEAR
EXTRN	__imp__CoTaskMemAlloc@4:NEAR
EXTRN	__imp__CoTaskMemFree@4:NEAR
;	COMDAT ??_C@_02DLJH@?$CFg?$AA@
; File D:\SySal2\SmartTracker8\..\Common\Config2.cpp
_DATA	SEGMENT
??_C@_02DLJH@?$CFg?$AA@ DB '%g', 00H			; `string'
_DATA	ENDS
;	COMDAT ?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z
_TEXT	SEGMENT
_C$ = 8
_QueryDataCount$ = 12
_pQDI$ = 16
_pC$ = 20
?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z PROC NEAR ; PutData, COMDAT

; 36   : {

	push	ebx
	push	esi

; 37   : 	if (C.pItems) CoTaskMemFree(C.pItems);

	mov	esi, DWORD PTR _C$[esp+4]
	push	edi
	xor	edi, edi
	mov	eax, DWORD PTR [esi+68]
	cmp	eax, edi
	je	SHORT $L79943
	push	eax
	call	DWORD PTR __imp__CoTaskMemFree@4
$L79943:

; 38   : 	C.pItems = 0;
; 39   : 	C.CountOfItems = 0;
; 40   : 	if (!QueryDataCount) return 0;

	mov	ebx, DWORD PTR _QueryDataCount$[esp+8]
	mov	DWORD PTR [esi+68], edi
	cmp	ebx, edi
	mov	DWORD PTR [esi+64], edi
	jne	SHORT $L79944
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 64   : 	};

	ret	0
$L79944:

; 41   : 	if (!(C.pItems = (char *)CoTaskMemAlloc(QueryDataCount * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN)))) return 0;

	mov	edi, ebx
	shl	edi, 7
	push	edi
	call	DWORD PTR __imp__CoTaskMemAlloc@4
	mov	edx, eax
	test	edx, edx
	mov	DWORD PTR [esi+68], edx
	jne	SHORT $L79946
	pop	edi
	pop	esi
	pop	ebx

; 64   : 	};

	ret	0
$L79946:

; 42   : 	memset(C.pItems, 0, QueryDataCount * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN));

	mov	ecx, edi
	mov	edi, edx
	mov	edx, ecx
	xor	eax, eax
	shr	ecx, 2
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb

; 43   : 	for (C.CountOfItems = 0; C.CountOfItems < QueryDataCount; C.CountOfItems++)

	test	ebx, ebx
	mov	DWORD PTR [esi+64], 0
	jle	$L79963
	mov	edi, DWORD PTR _pC$[esp+8]
	mov	ebx, DWORD PTR __imp__strncpy
$L79947:

; 44   : 	{
; 45   : 		switch (pQDI[C.CountOfItems].Format)
; 46   : 		{

	mov	eax, DWORD PTR [esi+64]
	mov	edx, DWORD PTR _pQDI$[esp+8]
	mov	ecx, eax
	shl	ecx, 4
	add	ecx, eax
	lea	ecx, DWORD PTR [edx+ecx*8]
	movsx	edx, BYTE PTR [ecx+64]
	dec	edx
	je	SHORT $L79954
	dec	edx
	je	SHORT $L79957
	dec	edx
	jne	$L79963

; 54   : 
; 55   : 			case ST_STRING:	strncpy(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 56   : 								((char *)pC + pQDI[C.CountOfItems].Position), SYSAL_MAXCONFIG_ENTRY_VALUE_LEN);

	mov	ecx, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [esi+68]
	shl	eax, 7
	add	ecx, edi
	push	64					; 00000040H
	lea	eax, DWORD PTR [eax+edx+64]
	push	ecx
	push	eax
	call	ebx

; 57   : 							break;

	jmp	SHORT $L80868
$L79957:

; 49   : 							break;
; 50   : 
; 51   : 			case ST_FLOAT:	sprintf(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 52   : 								"%g", *(float *)((char *)pC + pQDI[C.CountOfItems].Position));

	mov	ecx, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [esi+68]
	sub	esp, 8
	fld	DWORD PTR [ecx+edi]
	shl	eax, 7
	fstp	QWORD PTR [esp]
	lea	eax, DWORD PTR [eax+edx+64]
	push	OFFSET FLAT:??_C@_02DLJH@?$CFg?$AA@	; `string'
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 53   : 							break;

	jmp	SHORT $L79951
$L79954:

; 47   : 			case ST_INT:	sprintf(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 48   : 								"%d", *(int *)((char *)pC + pQDI[C.CountOfItems].Position));

	mov	ecx, DWORD PTR [ecx+68]
	shl	eax, 7
	mov	edx, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR [esi+68]
	push	edx
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	lea	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	DWORD PTR __imp__sprintf
$L80868:
	add	esp, 12					; 0000000cH
$L79951:

; 58   : 
; 59   : 			default:		return C.CountOfItems;
; 60   : 			};
; 61   : 		strncpy(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN), pQDI[C.CountOfItems].Name, SYSAL_MAXCONFIG_ENTRY_NAME_LEN);

	mov	eax, DWORD PTR [esi+64]
	mov	edx, DWORD PTR _pQDI$[esp+8]
	mov	ecx, eax
	push	64					; 00000040H
	shl	ecx, 4
	add	ecx, eax
	shl	eax, 7
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR [esi+68]
	add	eax, edx
	push	ecx
	push	eax
	call	ebx
	mov	ecx, DWORD PTR [esi+64]
	mov	edx, DWORD PTR _QueryDataCount$[esp+20]
	add	esp, 12					; 0000000cH
	inc	ecx
	mov	eax, ecx
	mov	DWORD PTR [esi+64], ecx
	cmp	eax, edx
	jl	$L79947
$L79963:

; 62   : 		};	
; 63   : 	return C.CountOfItems;

	mov	eax, DWORD PTR [esi+64]
	pop	edi
	pop	esi
	pop	ebx

; 64   : 	};

	ret	0
?PutData@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ENDP ; PutData
_TEXT	ENDS
PUBLIC	?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ; PutDataPreserve
EXTRN	__imp__CoTaskMemRealloc@8:NEAR
;	COMDAT ?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z
_TEXT	SEGMENT
_C$ = 8
_QueryDataCount$ = 12
_pQDI$ = 16
_pC$ = 20
?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z PROC NEAR ; PutDataPreserve, COMDAT

; 67   : {

	push	ebx

; 68   : 	C.pItems = (char *)CoTaskMemRealloc(C.pItems, (QueryDataCount + C.CountOfItems) * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN));

	mov	ebx, DWORD PTR _QueryDataCount$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _C$[esp+8]
	mov	eax, ebx
	push	edi
	mov	ecx, DWORD PTR [esi+64]
	add	eax, ecx
	mov	ecx, DWORD PTR [esi+68]
	shl	eax, 7
	push	eax
	push	ecx
	call	DWORD PTR __imp__CoTaskMemRealloc@8

; 69   : 	memset(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN), 0, QueryDataCount * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN));

	mov	edi, DWORD PTR [esi+64]
	mov	ecx, ebx
	mov	edx, eax
	xor	eax, eax
	shl	edi, 7
	shl	ecx, 7
	mov	DWORD PTR [esi+68], edx
	add	edi, edx
	mov	edx, ecx
	shr	ecx, 2
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb

; 70   : 	int OldCount = C.CountOfItems;

	mov	edi, DWORD PTR [esi+64]

; 71   : 	for (; C.CountOfItems < (QueryDataCount + OldCount); C.CountOfItems++)

	add	ebx, edi
	cmp	edi, ebx
	mov	DWORD PTR 8+[esp+12], ebx
	jge	$L79987
	mov	ebx, DWORD PTR _pC$[esp+12]
	mov	ebp, DWORD PTR _pQDI$[esp+12]
$L79972:

; 72   : 	{
; 73   : 		switch (pQDI[C.CountOfItems - OldCount].Format)
; 74   : 		{

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, eax
	sub	ecx, edi
	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	lea	ecx, DWORD PTR [ebp+edx*8]
	movsx	edx, BYTE PTR [ebp+edx*8+64]
	dec	edx
	je	SHORT $L79979
	dec	edx
	je	SHORT $L79982
	dec	edx
	jne	$L79987

; 82   : 
; 83   : 			case ST_STRING:	strncpy(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 84   : 								((char *)pC + pQDI[C.CountOfItems - OldCount].Position), SYSAL_MAXCONFIG_ENTRY_VALUE_LEN);

	mov	ecx, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [esi+68]
	shl	eax, 7
	add	ecx, ebx
	push	64					; 00000040H
	lea	eax, DWORD PTR [eax+edx+64]
	push	ecx
	push	eax
	call	DWORD PTR __imp__strncpy

; 85   : 							break;

	jmp	SHORT $L80875
$L79982:

; 77   : 							break;
; 78   : 
; 79   : 			case ST_FLOAT:	sprintf(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 80   : 								"%g", *(float *)((char *)pC + pQDI[C.CountOfItems - OldCount].Position));

	mov	ecx, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [esi+68]
	sub	esp, 8
	fld	DWORD PTR [ecx+ebx]
	shl	eax, 7
	fstp	QWORD PTR [esp]
	lea	eax, DWORD PTR [eax+edx+64]
	push	OFFSET FLAT:??_C@_02DLJH@?$CFg?$AA@	; `string'
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 81   : 							break;

	jmp	SHORT $L79976
$L79979:

; 75   : 			case ST_INT:	sprintf(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN) + SYSAL_MAXCONFIG_ENTRY_NAME_LEN,
; 76   : 								"%d", *(int *)((char *)pC + pQDI[C.CountOfItems - OldCount].Position));

	mov	ecx, DWORD PTR [ecx+68]
	shl	eax, 7
	mov	edx, DWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR [esi+68]
	push	edx
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	lea	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	DWORD PTR __imp__sprintf
$L80875:
	add	esp, 12					; 0000000cH
$L79976:

; 86   : 
; 87   : 			default:		return C.CountOfItems;
; 88   : 			};
; 89   : 		strncpy(C.pItems + C.CountOfItems * (SYSAL_MAXCONFIG_ENTRY_NAME_LEN + SYSAL_MAXCONFIG_ENTRY_VALUE_LEN), pQDI[C.CountOfItems - OldCount].Name, SYSAL_MAXCONFIG_ENTRY_NAME_LEN);

	mov	eax, DWORD PTR [esi+64]
	push	64					; 00000040H
	mov	ecx, eax
	sub	ecx, edi
	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	shl	eax, 7
	lea	ecx, DWORD PTR [ebp+edx*8]
	mov	edx, DWORD PTR [esi+68]
	add	eax, edx
	push	ecx
	push	eax
	call	DWORD PTR __imp__strncpy
	mov	ecx, DWORD PTR [esi+64]
	mov	edx, DWORD PTR 8+[esp+24]
	add	esp, 12					; 0000000cH
	inc	ecx
	mov	eax, ecx
	mov	DWORD PTR [esi+64], ecx
	cmp	eax, edx
	jl	$L79972
$L79987:

; 90   : 		};	
; 91   : 	return C.CountOfItems;

	mov	eax, DWORD PTR [esi+64]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 92   : 	};

	ret	0
?PutDataPreserve@@YAHAAUSySalConfig@@HPAUQueryDataInfo@@PAX@Z ENDP ; PutDataPreserve
_TEXT	ENDS
END
